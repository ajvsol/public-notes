- [C#](https://learn.microsoft.com/en-us/dotnet/csharp/)
- Pros/Cons
  collapsed:: true
	- Pros
		- There are version of [PHP](http://www.peachpie.io/) and [Python](https://github.com/Microsoft/Pyjion 108) running on top of .NET runtime.
		- code in interpreted languages gets faster in later versions of the runtime (.NET CLR or Java VM), without you doing anything. And there are a lot of useful optimizations JIT compilers can do that are simply impossible in languages with pointers
		  collapsed:: true
			- code in interpreted languages gets faster in later versions of the runtime</quote> As code compiled by a better version of the compiler will also get faster.
		- is pure OOP, forcing rules in your code that helps keep your code more readable, 'maintainable' and execution is more stable. Productivity rate surpasses C++ by at least 10%, the best C++ programmer could be an even better C# programmer.
		- Applications that require the benefits of the .NET framework in the language it was designed for.
		- It has native garbage-collection, unlike C++ which has
		- Easier and thus faster to code in
			- The syntax of C# is certainly less demanding (and error prone) than C/C++ and has, for the initiated programmer, a shallower learning curve.
			- Rapid client application development.
		- More quality of life features
		  collapsed:: true
			- C# prevents you from doing certain things that C/C++ allows you to, but some of these things were things that you would never want to do anyways and were probably some mistake that was going to lead to some really weird behavior and you not knowing why, like assigning in a conditional field, or having `5;` as an expression. That line of code isn’t “doing” anything, so C# won’t let that run because it was probably a mistake.
	- Cons
		- .NET still not open platform
		  collapsed:: true
			- Note: this is C#, F# and C++
			- https://isdotnetopen.com/
				- problems:
					- [ramming in a proprietary extension to continue to lockdown .NET.](https://github.com/omnisharp/omnisharp-vscode/issues/5276)
					- [an open programming language is missing a debugger](https://github.com/dotnet/core/issues/505)
					- [leadership decision to remove hotreload angers community and devdiv employees](https://www.theverge.com/2021/10/22/22740701/microsoft-dotnet-hot-reload-removal-decision-open-source)
					- [.NET foundation serves the interests of Microsoft](https://www.theregister.com/2021/10/05/microsoft_net_foundation_under_fire/)
					-
			- [Despite best efforts .NET is still not an open platform | Hacker News](https://news.ycombinator.com/item?id=31762778)
			-
	- Comparisons
		- With ((646349e5-6faa-4638-a681-e2218087d789))
- Documentation
	- Learning resources sorted by priority
	  id:: 64400aaf-af93-4739-a73b-97b213f053d6
		- ((64400a8a-5cda-48bb-850a-572516e63317))
	- Cheatsheet
	  collapsed:: true
		- To ingrain
		  id:: 650bfd83-b79c-4eb6-aeb3-2578fd73df32
			- ((650c05e4-ec3c-4711-857d-7e22f4e53d97)) like in [[JavaScript]]
			-
			- ((643c49e4-393a-4dc9-ae4d-1cb5f1a05481))
			- Type conversion
				- ((643bdb01-3ba2-4ece-aaa8-da84dcab4a64))
		- Categories
			- Syntax
			  id:: 6439ddbe-c1d0-4643-adf2-68cca691b9bb
				- Assorted
					- `dotnet run` = compile and execute program
					- `using` = equivalent to `import` in [[JavaScript]]
				- [C# cheat sheet](https://programming-idioms.org/cheatsheet/Csharp)
					- Functions
						- [Create a function](https://programming-idioms.org/idiom/4/create-a-function) - returns the square of an integer
							- ```c#
							  int Square(int x)
							  {
							      return x * x;
							  }
							  ```
							- ```c#
							  int Square(int x) => (int)Math.Pow(x, 2);
							  ```
					- [Iterate over list values](https://programming-idioms.org/idiom/6/iterate-over-list-values)
						- ```c#
						  foreach (var x in items)
						  {
						      DoSomething(x);
						  }
						  ```
				- [Learn C# in Y Minutes](https://learnxinyminutes.com/docs/csharp/)
					- Strings are immutable: you can't do `fooString[1] = 'X';`
					- Arrays
						- // The array size must be decided upon declaration
						- The format for declaring an array is
						  `<datatype>[] <var name> = new <datatype>[<array size>];`
						- Example: 
						  ```c#
						  int[] intArray = new int[10];
						  ```
						- Another way to declare & initialize an array
							- `int[] y = { 9000, 1000, 1337 };`
				- ((643a7179-82c1-4452-a66f-53c389bfac13))
					- `Console.WriteLine("Hello World!");` = Print "Hello World!"
					- `string aFriend = "Bill";` = Declare a string
					- String interpolation
						- Concatenation
						  ```c#
						  Console.WriteLine("Hello " + aFriend);
						  ```
						- Interpolation
						  ```c#
						  string firstFriend = "Maria";
						  string secondFriend = "Sage";
						  Console.WriteLine($"My friends are {firstFriend} and {secondFriend}");
						  ```
				- Related: ((642714a5-1d61-4067-a9fd-87d003c13a07))
	- Overview
	  collapsed:: true
		- Main language for the .NET framework, alongside F# and Visual Basic
		- C# runs aided by a JIT compiler
		- .NET Core = desktop apps
		- Xamarin = mobile apps
		- Blazor = web apps
		- Unity = videogames
	- Editors
		- ((63209272-1088-4824-a762-4ac7ded04b0a))
		- ((643a7412-56f4-4612-a067-12ea6d2f51d6))
	- References
		- [C# documentation](https://learn.microsoft.com/en-us/dotnet/csharp/)
		  collapsed:: true
			- 1) [Get started](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/)
			  id:: 643aaea3-1255-47c9-abe2-948d39fa1470
			  collapsed:: true
				- Notes
					- ## [Introduction](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/)
						- C# is a modern, object-oriented, and type-safe programming language
						- Language has roots in C, so will be familiar to C, C++, Java, and JavaScript programmers
						- Features
						  collapsed:: true
							- [**Garbage collection**](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/) automatically reclaims memory occupied by unreachable unused objects.
							- [**Nullable types**](https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references) guard against variables that don't refer to allocated objects.
							- [**Exception handling**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/) provides a structured and extensible approach to error detection and recovery.
							- [**Lambda expressions**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions) support functional programming techniques
							- [**Language Integrated Query (LINQ)**](https://learn.microsoft.com/en-us/dotnet/csharp/linq/) syntax creates a common pattern for working with data from any source.
							- Language support for [**asynchronous operations**](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/) provides syntax for building distributed systems
							- ((6463496d-d42a-4e5d-bfd3-c25979a00742))
							- All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.
							- All types share a set of common operations. Values of any type can be stored, transported, and operated upon in a consistent manner. Furthermore, C# supports both user-defined [reference types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types) and [value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types).
							- C# allows dynamic allocation of objects and in-line storage of lightweight structures.
							- C# supports generic methods and types, which provide increased type safety and performance.
							- C# provides iterators, which enable implementers of collection classes to define custom behaviors for client code.
						- ### Types and variables
						  collapsed:: true
							- A *variable* is a label that refers to an instance of a specific type.
							- An **identifier** is a variable name. An identifier is a sequence of unicode characters without any whitespace. An identifier may be a C# reserved word, if it's prefixed by `@`. Using a reserved word as an identifier can be useful when interacting with other languages.
							- Types
								- Meta
									- Differences between ((643af26a-8c2a-4835-9ca1-5cf007849274)) and ((3244e01c-d292-42f3-8e8c-8f6e616c4424))
									  collapsed:: true
										- Variables of value types directly contain their data. Variables of reference types store references to their data, the latter being known as objects.
										- With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.
										- With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).
								- [Value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types)
								  id:: 643af26a-8c2a-4835-9ca1-5cf007849274
									- [Simple types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types#built-in-value-types)
									  collapsed:: true
										- [Signed integral](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)
										  `sbyte`, `short`, `int`, `long`
										- [Unsigned integral](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)
										  `byte`, `ushort`, `uint`, `ulong`
										- [Unicode characters](https://learn.microsoft.com/en-us/dotnet/standard/base-types/character-encoding-introduction)
										  `char`, which represents a UTF-16 code unit
										- [IEEE binary floating-point](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)
										  `float`, `double`
										- [High-precision decimal floating-point](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)
										  `decimal`
										- Boolean
										  `bool`, which represents Boolean values—values that are either `true` or `false`
									- [Enum types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum)
									  id:: 4e17bd2a-51db-4f5e-ab56-e7363948d37c
									  collapsed:: true
									  User-defined types of the form `enum E {...}`.
										- An `enum` type is a distinct type with named constants. Every `enum` type has an underlying type, which must be one of the eight integral types. The set of values of an `enum` type is the same as the set of values of the underlying type.
									- [Struct types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct)
									  id:: d817704d-73a8-4144-9ae0-c992c687bc8c
									  collapsed:: true
									  User-defined types of the form `struct S {...}`
										- A `struct` type is similar to a class type in that it represents a structure with data members and function members. However, unlike classes, structs are value types and don't typically require heap allocation. Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.
									- [Nullable value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types)
									  collapsed:: true
									  Extensions of all other value types with a `null` value
										- Nullable types don't require a separate definition. For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`. For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.
									- [Tuple value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples)
									  id:: a557ab46-64e8-43c0-89bc-2148fd5fe66a
									  User-defined types of the form `(T1, T2, ...)`
								- [Reference types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types)
								  id:: 3244e01c-d292-42f3-8e8c-8f6e616c4424
									- [Class types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class)
									  id:: 43141a03-cbe4-4075-b211-45cd12b58e96
									  collapsed:: true
									  User-defined types of the form `class C {...}`
										- Ultimate base class of all other types: `object`
										- [Unicode strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/character-encoding-introduction): `string`, which represents a sequence of UTF-16 code units
										- A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others). Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.
									- [Interface types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface)
									  id:: 99bedac8-fcfa-41da-83cc-55d8cb912394
									  collapsed:: true
									  User-defined types of the form `interface I {...}`
										- An `interface` type defines a contract as a named set of public members. A `class` or `struct` that implements an `interface` must provide implementations of the interface's members. An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.
									- [Array types](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/)
									  collapsed:: true
									  Single-dimensional, multi-dimensional, and jagged. For example: `int[]`, `int[,]`, and `int[][]`
										- C# supports single-dimensional and multi-dimensional arrays of any type. Unlike the types listed above, array types don't have to be declared before they can be used. Instead, array types are constructed by following a type name with square brackets. For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of `int`.
									- [Delegate types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types#the-delegate-type)
									  id:: 1680483c-7ddb-40cb-96be-65f90312d208
									  collapsed:: true
									  User-defined types of the form `delegate int D(...)`
										- A `delegate` type represents references to methods with a particular parameter list and return type. Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters. Delegates are analogous to function types provided by functional languages. They're also similar to the concept of function pointers found in some other languages. Unlike function pointers, delegates are object-oriented and type-safe.
							- C# programs use *type declarations* to create new types. A type declaration specifies the name and the members of the new type.
							- 6 categories of types are user-definable:
								- ((4e17bd2a-51db-4f5e-ab56-e7363948d37c))
								- ((d817704d-73a8-4144-9ae0-c992c687bc8c))
								- ((a557ab46-64e8-43c0-89bc-2148fd5fe66a))
								- ((43141a03-cbe4-4075-b211-45cd12b58e96))
								- ((99bedac8-fcfa-41da-83cc-55d8cb912394))
								- ((1680483c-7ddb-40cb-96be-65f90312d208))
							- You can also declare `record` types, either `record struct`, or `record class`. Record types have compiler-synthesized members. You use records primarily for storing values, with minimal associated behavior.
							- These types support generics, whereby they can be parameterized with other types:
								- ((d817704d-73a8-4144-9ae0-c992c687bc8c))
								- ((43141a03-cbe4-4075-b211-45cd12b58e96))
								- ((99bedac8-fcfa-41da-83cc-55d8cb912394))
								- ((1680483c-7ddb-40cb-96be-65f90312d208))
							- C# has a [**unified type system**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/).
							  id:: 6463496d-d42a-4e5d-bfd3-c25979a00742
								- C#'s type system is unified such that a value of any type can be treated as an `object`. Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.
								- Values of reference types are treated as objects simply by viewing the values as type `object`.
								- Values of value types are treated as objects by performing *boxing* and *unboxing operations*.
									- In the following example, an `int` value is converted to `object` and back again to `int`:
									  id:: 643bdb01-3ba2-4ece-aaa8-da84dcab4a64
									  ```c#
									  int i = 123;
									  object o = i;    // Boxing
									  int j = (int)o;  // Unboxing
									  ```
									- When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value. That box is an instance of a reference type, and the value is copied into that box.
									- Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type. If the check succeeds, the value in the box is copied to the value type.
							- Every variable has a type that determines what values can be stored in the variable, as shown below.
								- Non-nullable value type
									- A value of that exact type
								- Nullable value type
									- A `null` value or a value of that exact type
								- object
									- A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type
								- Class type
									- A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type
								- Interface type
									- A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type
								- Array type
									- A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type
								- Delegate type
									- A `null` reference or a reference to an instance of a compatible delegate type
							-
						- ### Program structure
						  collapsed:: true
							- The key organizational concepts in C# are [**programs**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/), [**namespaces**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/namespaces), [**types**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/), [**members**](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members), and [**assemblies**](https://learn.microsoft.com/en-us/dotnet/standard/assembly/).
								- Programs declare types, which contain members and can be organized into namespaces.
								- Types include classes, structs, interfaces, etc.
								- Members include fields, methods, properties, events, etc. When C# programs are compiled, they're physically packaged into assemblies.
								- Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement **applications** or **libraries**, respectively.
							- Example assembly
								- ```c#
								  namespace Acme.Collections;
								  
								  public class Stack<T>
								  {
								      Entry _top;
								  
								      public void Push(T data)
								      {
								          _top = new Entry(_top, data);
								      }
								  
								      public T Pop()
								      {
								          if (_top == null)
								          {
								              throw new InvalidOperationException();
								          }
								          T result = _top.Data;
								          _top = _top.Next;
								  
								          return result;
								      }
								  
								      class Entry
								      {
								          public Entry Next { get; set; }
								          public T Data { get; set; }
								  
								          public Entry(Entry next, T data)
								          {
								              Next = next;
								              Data = data;
								          }
								      }
								  }
								  ```
									- The fully qualified name of this class is `Acme.Collections.Stack`. The class contains several members: a field named `_top`, two methods named `Push` and `Pop`, and a nested class named `Entry`. The `Entry` class further contains three members: a property named `Next`, a property named `Data`, and a constructor. The `Stack` is a *generic* class. It has one type parameter, `T` that is replaced with a concrete type when it's used.
									- A *stack* is a "first in - last out" (FILO) collection. New elements are added to the top of the stack. When an element is removed, it's removed from the top of the stack. The previous example declares the `Stack` type that defines the storage and behavior for a stack. You can declare a variable that refers to an instance of the `Stack` type to use that functionality.
							- Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata. Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.
								- Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#. The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.
								- For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:
									- ```c#
									  class Example
									  {
									      public static void Main()
									      {
									          var s = new Acme.Collections.Stack<int>();
									          s.Push(1); // stack contains 1
									          s.Push(10); // stack contains 1, 10
									          s.Push(100); // stack contains 1, 10, 100
									          Console.WriteLine(s.Pop()); // stack contains 1, 10
									          Console.WriteLine(s.Pop()); // stack contains 1
									          Console.WriteLine(s.Pop()); // stack is empty
									      }
									  }
									  ```
								- To compile this program, you would need to reference the assembly containing the stack class defined in the earlier example.
								  
								  C# programs can be stored in several source files. When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other. Conceptually, it's as if all the source files were concatenated into one large file before being processed. Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant. C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.
								- Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant. C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.
					- ## [Types and Members](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/types)
					  id:: 6463496d-287c-40c3-917d-f039c1b8e70a
						- As an object-oriented language, C# supports the concepts of encapsulation, inheritance, and polymorphism.
						  collapsed:: true
							- A class may inherit directly from one parent class, and it may implement any number of interfaces.
							- Polymorphism? - Methods that override virtual methods in a parent class require the `override` keyword as a way to avoid accidental redefinition.
							- A struct is like a lightweight class; it's a stack-allocated type that can implement interfaces but doesn't support inheritance. C# provides `record class` and `record struct` types, which are types whose purpose is primarily storing data values.
						- ### Classes and objects
						  collapsed:: true
							- A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit. A class provides a definition for *instances* of the class, also known as *objects*. Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.
							- New classes are created using class declarations. A class declaration starts with a header. The header specifies:
							  collapsed:: true
								- The attributes and modifiers of the class
								- The name of the class
								- The base class (when inheriting from a [base class](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/types#base-classes))
								- The interfaces implemented by the class.
							- The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.
							- Class example
							  collapsed:: true
								- ```c#
								  public class Point
								  {
								      public int X { get; }
								      public int Y { get; }
								      
								      public Point(int x, int y) => (X, Y) = (x, y);
								  }
								  ```
							- Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.
							  collapsed:: true
								- The following statements create two `Point` objects and store references to those objects in two variables:
								  ```c#
								  var p1 = new Point(0, 0);
								  var p2 = new Point(10, 20);
								  ```
							- #### Type parameters
							  collapsed:: true
								- Generic classes define [**type parameters**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics). Type parameters are a list of type parameter names enclosed in angle brackets. Type parameters follow the class name. The type parameters can then be used in the body of the class declarations to define the members of the class.
								  collapsed:: true
									- In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:
									  ```c#
									  public class Pair<TFirst, TSecond>
									  {
									      public TFirst First { get; }
									      public TSecond Second { get; }
									      
									      public Pair(TFirst first, TSecond second) => 
									          (First, Second) = (first, second);
									  }
									  ```
								- A class type that is declared to take type parameters is called a *generic class type*. Struct, interface, and delegate types can also be generic. When the generic class is used, type arguments must be provided for each of the type parameters:
								  collapsed:: true
									- ```c#
									  var pair = new Pair<int, string>(1, "two");
									  int i = pair.First;     //TFirst int
									  string s = pair.Second; //TSecond string
									  ```
									- A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.
							- #### Base classes
							  collapsed:: true
								- A class declaration may specify a base class.
								  collapsed:: true
									- Follow the class name and type parameters with a colon and the name of the base class. Omitting a base class specification is the same as deriving from type `object`.
									- In the following example, the base class of `Point3D` is `Point`. From the first example, the base class of `Point` is `object`:
									  id:: 643c463e-dcb9-4b23-893c-87b16ff6525d
									  collapsed:: true
										- id:: 643c4652-5ae9-47e8-a873-5f0205fc0a48
										  ```c#
										  public class Point3D : Point
										  {
										      public int Z { get; set; }
										      
										      public Point3D(int x, int y, int z) : base(x, y)
										      {
										          Z = z;
										      }
										  }
										  ```
								- A class inherits the members of its base class. Inheritance means that a class implicitly contains almost all members of its base class. A class doesn't inherit the instance and static constructors, and the finalizer. A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.
								  collapsed:: true
									- [In the previous example](((643c463e-dcb9-4b23-893c-87b16ff6525d))), `Point3D` inherits the `X` and `Y` members from `Point`, and every `Point3D` instance contains three properties, `X`, `Y`, and `Z`.
								- An implicit conversion exists from a class type to any of its base class types. A variable of a class type can reference an instance of that class or an instance of any derived class.
								  collapsed:: true
									- For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:
									  ```c#
									  Point a = new(10, 20);
									  Point b = new Point3D(10, 20, 30);
									  ```
						- ### Structs
						  collapsed:: true
							- Classes define types that support inheritance and polymorphism. They enable you to create sophisticated behaviors based on hierarchies of derived classes. By contrast, [**struct**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct) types are simpler types whose primary purpose is to store data values. Structs can't declare a base type; they implicitly derive from [System.ValueType](https://learn.microsoft.com/en-us/dotnet/api/system.valuetype). You can't derive other `struct` types from a `struct` type. They're implicitly sealed.
							- Example
							  collapsed:: true
								- ```c#
								  public struct Point
								  {
								      public double X { get; }
								      public double Y { get; }
								      
								      public Point(double x, double y) => (X, Y) = (x, y);
								  }
								  ```
						- ### Interfaces
						  collapsed:: true
							- An [**interface**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/interfaces) defines a contract that can be implemented by classes and structs. You define an *interface* to declare capabilities that are shared among distinct types. For example, the [System.Collections.Generic.IEnumerable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1) interface defines a consistent way to traverse all the items in a collection, such as an array. An interface can contain methods, properties, events, and indexers. An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.
							- Interfaces may employ **multiple inheritance**. In the following example, the interface `IComboBox` inherits from both `ITextBox` and `IListBox`.
							  collapsed:: true
								- ```c#
								  interface IControl
								  {
								      void Paint();
								  }
								  
								  interface ITextBox : IControl
								  {
								      void SetText(string text);
								  }
								  
								  interface IListBox : IControl
								  {
								      void SetItems(string[] items);
								  }
								  
								  interface IComboBox : ITextBox, IListBox { }
								  ```
							- Classes and structs can implement (utilise/inherit?) multiple interfaces. In the following example, the class `EditBox` implements both `IControl` and `IDataBound`.
							  collapsed:: true
								- ```c#
								  interface IDataBound
								  {
								      void Bind(Binder b);
								  }
								  
								  public class EditBox : IControl, IDataBound
								  {
								      public void Paint() { }
								      public void Bind(Binder b) { }
								  }
								  ```
							- When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type. For example
							  collapsed:: true
								- ```c#
								  EditBox editBox = new();
								  IControl control = editBox;
								  IDataBound dataBound = editBox;
								  ```
						- ### Enums
						  collapsed:: true
							- Also exists in ((629ccb26-1eab-4686-a7b8-f9433a871440))
							- An [**Enum**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum) type defines a set of constant values. The following `enum` declares constants that define different root vegetables:
							  collapsed:: true
								- ```c#
								  public enum SomeRootVegetable
								  {
								      HorseRadish,
								      Radish,
								      Turnip
								  }
								  ```
							- You can also define an `enum` to be used in combination as flags. The following declaration declares a set of flags for the four seasons. Any combination of the seasons may be applied, including an `All` value that includes all seasons:
							  collapsed:: true
								- ```c#
								  [Flags]
								  public enum Seasons
								  {
								      None = 0,
								      Summer = 1,
								      Autumn = 2,
								      Winter = 4,
								      Spring = 8,
								      All = Summer | Autumn | Winter | Spring
								  }
								  ```
							- The following example shows declarations of both the preceding enums:
							  collapsed:: true
								- ```c#
								  var turnip = SomeRootVegetable.Turnip;
								  
								  var spring = Seasons.Spring;
								  var startingOnEquinox = Seasons.Spring | Seasons.Autumn;
								  var theYear = Seasons.All;
								  ```
						- ### Nullable types
						  collapsed:: true
							- Variables of any type may be declared as **non-nullable** or **nullable**. A nullable variable can hold an additional `null` value, indicating no value. Nullable Value types (structs or enums) are represented by [System.Nullable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1). Non-nullable and Nullable Reference types are both represented by the underlying reference type. The distinction is represented by metadata read by the compiler and some libraries. The compiler provides warnings when nullable references are dereferenced without first checking their value against `null`. The compiler also provides warnings when non-nullable references are assigned a value that may be `null`. The following example declares a **nullable int**, initializing it to `null`. Then, it sets the value to `5`. It demonstrates the same concept with a **nullable string**. For more information, see [nullable value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types) and [nullable reference types](https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references).
							- ```c#
							  int? optionalInt = default; 
							  optionalInt = 5;
							  string? optionalText = default;
							  optionalText = "Hello World.";
							  ```
						- ### Tuples
						  collapsed:: true
							- C# supports [**tuples**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples), which provides concise syntax to group multiple data elements in a lightweight data structure. You instantiate a tuple by declaring the types and names of the members between `(` and `)`, as shown in the following example:
							- ```c#
							  (double Sum, int Count) t2 = (4.5, 3);
							  Console.WriteLine($"Sum of {t2.Count} elements is {t2.Sum}.");
							  //Output:
							  //Sum of 3 elements is 4.5.
							  ```
							- Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.
					- ## [Program building blocks](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/program-building-blocks)
					  id:: 64400a8a-5cda-48bb-850a-572516e63317
						- The types described in ((6463496d-287c-40c3-917d-f039c1b8e70a)) are built using these building blocks:
							- Members, such as properties, fields, methods, and events.
							- Expressions
							- Statements
						- ### Members
						  id:: 64f07c93-2539-4af9-99cb-7363a2105046
						  collapsed:: true
							- Intro
								- The members of a `class` are either **static members** or **instance members**. Static members belong to classes, and instance members belong to objects (instances of classes).
								- The following list provides an overview of the kinds of members a class can contain.
									- **Constants**: Constant values associated with the class
									- ((64f07dad-3a65-4e23-9b8d-c9966a9ece88)) - A variable that is associated with a class or with an instance of a class.
									- ((64f07db4-a0a5-4056-8a1d-e5997114ad54)) - Actions that can be performed by the class
									- ((64f0a783-cd94-45cb-950d-6b7593e355d0)) - Actions associated with reading and writing named properties of the class
									- ((64f0a7b3-bbca-4fa9-a7e6-b98328da288b)) - Actions associated with indexing instances of the class like an array
									- ((64f0a7e4-d4f5-40dd-b66d-a09c1177254c)) - Notifications that can be generated by the class
									- ((64f0a823-bd55-46e1-a221-18af0839abd9)) - Conversions and expression operators supported by the class
									- ((64f0a73f-d187-4c7d-ad86-1798d8eb5f2e)) - Actions required to initialize instances of the class or the class itself
									- ((64f0a84d-edf1-4a5d-a586-2c5889e6aa2a)) - Actions done before instances of the class are permanently discarded
									- **Types**: Nested types declared by the class
							- Accessibility
							  collapsed:: true
								- Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.
								- There are six possible forms of accessibility. The access modifiers are summarized below.
									- `public`: Access isn't limited.
									- `private`: Access is limited to this class.
									- `protected`: Access is limited to this class or classes derived from this class.
									- `internal`: Access is limited to the current assembly (`.exe` or `.dll`).
									- `protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.
									- `private protected`: Access is limited to this class or classes derived from this type within the same assembly.
							- #### Fields
							  id:: 64f07dad-3a65-4e23-9b8d-c9966a9ece88
							  collapsed:: true
							  A variable that is associated with a class or with an instance of a class.
								- A field declared with the static modifier defines a static field. A static field identifies exactly one storage location. No matter how many instances of a class are created, there's only ever one copy of a static field.
								- A field declared without the static modifier defines an instance field. Every instance of a class contains a separate copy of all the instance fields of that class.
								- In the following example, each instance of the `Color` class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:
								  collapsed:: true
									- ```c#
									  public class Color
									  {
									      public static readonly Color Black = new(0, 0, 0);
									      public static readonly Color White = new(255, 255, 255);
									      public static readonly Color Red = new(255, 0, 0);
									      public static readonly Color Green = new(0, 255, 0);
									      public static readonly Color Blue = new(0, 0, 255);
									      
									      public byte R;
									      public byte G;
									      public byte B;
									  
									      public Color(byte r, byte g, byte b)
									      {
									          R = r;
									          G = g;
									          B = b;
									      }
									  }
									  ```
									- As shown in the previous example, *read-only fields* may be declared with a `readonly`modifier. Assignment to a read-only field can only occur as part of the field's declaration or in a constructor in the same class.
							- #### Methods
							  id:: 64f07db4-a0a5-4056-8a1d-e5997114ad54
							  collapsed:: true
							  Actions that can be performed by the class
								- A *method* is a member that implements a computation or action that can be performed by an object or class. *Static methods* are accessed through the class. *Instance methods* are accessed through instances of the class.
								- Methods may have a list of *parameters*, which represent values or variable references passed to the method. Methods have a *return type*, which specifies the type of the value computed and returned by the method. A method's return type is `void` if it doesn't return a value.
								- Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called. Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.
								- The *signature* of a method must be unique in the class in which the method is declared. The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters. The signature of a method doesn't include the return type.
								- https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/program-building-blocks#methods
								- When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:
								  ```c#
								  public override string ToString() => "This is an object";
								  ```
								- **Parameters**
								  collapsed:: true
									- Parameters are used to pass values or variable references to methods. The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked. There are four kinds of  parameters: value parameters, reference parameters, output parameters, and parameter arrays.
									- A *value parameter* is used for passing input arguments. A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter. Modifications to a value parameter don't affect the argument that was passed for the parameter.
									- Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.
									- A *reference parameter* is used for passing arguments by reference. The argument passed for a reference parameter must be a variable with a definite value. During execution of the method, the reference parameter represents the same storage location as the argument variable. A reference parameter is declared with the `ref` modifier. The following example shows the use of `ref` parameters:
										- ```c#
										  static void Swap(ref int x, ref int y)
										  {
										      int temp = x;
										      x = y;
										      y = temp;
										  }
										  
										  public static void SwapExample()
										  {
										      int i = 1, j = 2;
										      Swap(ref i, ref j);
										      Console.WriteLine($"{i} {j}");    // "2 1"
										  }
										  ```
									- An *output parameter* is used for passing arguments by reference. It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument. An output parameter is declared with the `out` modifier. The following example shows the use of `out` parameters.
										- ```c#
										  static void Divide(int x, int y, out int quotient, out int remainder)
										  {
										      quotient = x / y;
										      remainder = x % y;
										  }
										  
										  public static void OutUsage()
										  {
										      Divide(10, 3, out int quo, out int rem);
										      Console.WriteLine($"{quo} {rem}");	// "3 1"
										  }
										  ```
									- A *parameter array* permits a variable number of arguments to be passed to a method. A parameter array is declared with the `params` modifier. Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type. The `Write` and `WriteLine` methods of the [System.Console](https://learn.microsoft.com/en-us/dotnet/api/system.console) class are good examples of parameter array usage. They're declared as follows:
										- ```c#
										  public class Console
										  {
										      public static void Write(string fmt, params object[] args) { }
										      public static void WriteLine(string fmt, params object[] args) { }
										      // ...
										  }
										  ```
									- Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type. However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array. In the latter case, an array instance is automatically created and initialized with the given arguments.
										- This example:
										  ```c#
										  int x, y, z;
										  x = 3;
										  y = 4;
										  z = 5;
										  Console.WriteLine("x={0} y={1} z={2}", x, y, z);
										  ```
										- is equivalent to writing the following:
											- ```c#
											  int x = 3, y = 4, z = 5;
											  
											  string s = "x={0} y={1} z={2}";
											  object[] args = new object[3];
											  args[0] = x;
											  args[1] = y;
											  args[2] = z;
											  Console.WriteLine(s, args);
											  ```
									-
								- **Method body and local variables**
								  collapsed:: true
									- A method's body specifies the statements to execute when the method is invoked.
									- A method body can declare variables that are specific to the invocation of the method. Such variables are called *local variables*. A local variable declaration specifies a type name, a variable name, and possibly an initial value. The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.
									- ```c#
									  class Squares
									  {
									      public static void WriteSquares()
									      {
									          int i = 0;
									          int j;
									          while (i < 10)
									          {
									              j = i * i;
									              Console.WriteLine($"{i} x {i} = {j}");
									              i++;
									          }
									      }
									  }
									  ```
									- C# requires a local variable to be *definitely assigned* before its value can be obtained. For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.
									- A method can use `return` statements to return control to its caller. In a method returning `void`, `return` statements can't specify an expression. In a method returning non-void, `return` statements must include an expression that computes the return value.
								- **Static and instance methods**
								  collapsed:: true
									- A method declared with a `static` modifier is a *static method*. A static method doesn't operate on a specific instance and can only directly access static members.
									- A method declared without a `static` modifier is an *instance method*.An instance method operates on a specific instance and can access both static and instance members. The instance on which an instance method was invoked can be explicitly accessed as `this`. It's an error to refer to `this` in a static method.
									- The following `Entity` class has both static and instance members:
									  collapsed:: true
										- ```c#
										  class Entity
										  {
										      static int s_nextSerialNo;
										      int _serialNo;
										      
										      public Entity()
										      {
										          _serialNo = s_nextSerialNo++;
										      }
										      
										      public int GetSerialNo()
										      {
										          return _serialNo;
										      }
										      
										      public static int GetNextSerialNo()
										      {
										          return s_nextSerialNo;
										      }
										      
										      public static void SetNextSerialNo(int value)
										      {
										          s_nextSerialNo = value;
										      }
										  }
										  ```
									- Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here). The `Entity`constructor (which is like an instance method) initializes the new instance with the next available serial number. Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.
									- The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.
									- The following example shows the use of the `Entity` class:
										- ```c#
										  Entity.SetNextSerialNo(1000);
										  Entity e1 = new();
										  Entity e2 = new();
										  Console.WriteLine(e1.GetSerialNo());          // Outputs "1000"
										  Console.WriteLine(e2.GetSerialNo());          // Outputs "1001"
										  Console.WriteLine(Entity.GetNextSerialNo());  // Outputs "1002"
										  ```
									- The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.
								- **Virtual, override, and abstract methods**
								  collapsed:: true
									- You use virtual, override, and abstract methods to define the behavior for a hierarchy of class types. Because a class can derive from a base class, those derived classes may need to modify the behaviour implemented in the base class. A **virtual** method is one declared and implemented in a base class where any derived class may provide a more specific implementation. An **override** method is a method implemented in a derived class that modifies the behaviour of the base class' implementation. An **abstract** method is a method declared in a base class that *must* be overridden in all derived classes. In fact, abstract methods don't define an implementation in the base class.
									- Method calls to instance methods may resolve to either base class or derived class implementations. The type of a variable determines its *compile-time type*. The *compile-time type* is the type the compiler uses to determine its members. However, a variable may be assigned to an instance of any type derived from its *compile-time type*. The *run-time type* is the type of the actual instance a variable refers to.
									- When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke. In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.
									- A virtual method can be *overridden* in a derived class. When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature. A virtual method declaration introduces a new method. An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.
									- An *abstract method* is a virtual method with no implementation. An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class. An abstract method must be overridden in every non-abstract derived class.
									- The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations. (This example is similar to, but not related to the expression tree types).
									  collapsed:: true
										- ```c#
										  public abstract class Expression
										  {
										      public abstract double Evaluate(Dictionary<string, object> vars);
										  }
										  
										  public class Constant : Expression
										  {
										      double _value;
										      
										      public Constant(double value)
										      {
										          _value = value;
										      }
										      
										      public override double Evaluate(Dictionary<string, object> vars)
										      {
										          return _value;
										      }
										  }
										  
										  public class VariableReference : Expression
										  {
										      string _name;
										      
										      public VariableReference(string name)
										      {
										          _name = name;
										      }
										      
										      public override double Evaluate(Dictionary<string, object> vars)
										      {
										          object value = vars[_name] ?? throw new Exception($"Unknown variable: {_name}");
										          return Convert.ToDouble(value);
										      }
										  }
										  
										  public class Operation : Expression
										  {
										      Expression _left;
										      char _op;
										      Expression _right;
										      
										      public Operation(Expression left, char op, Expression right)
										      {
										          _left = left;
										          _op = op;
										          _right = right;
										      }
										      
										      public override double Evaluate(Dictionary<string, object> vars)
										      {
										          double x = _left.Evaluate(vars);
										          double y = _right.Evaluate(vars);
										          switch (_op)
										          {
										              case '+': return x + y;
										              case '-': return x - y;
										              case '*': return x * y;
										              case '/': return x / y;
										              
										              default: throw new Exception("Unknown operator");
										          }
										      }
										  }
										  ```
									- The previous four classes can be used to model arithmetic expressions. For example, using instances of these classes, the expression `x + 3` can be represented as follows.
										- ```c#
										  Expression e = new Operation(
										      new VariableReference("x"),
										      '+',
										      new Constant(3));
										  ```
									- The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value. The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries). Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.
									- A `Constant`'s implementation of `Evaluate` simply returns the stored constant. A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value. An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.
									- The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.
									  collapsed:: true
										- ```c#
										  Expression e = new Operation(
										      new VariableReference("x"),
										      '*',
										      new Operation(
										          new VariableReference("y"),
										          '+',
										          new Constant(2)
										      )
										  );
										  Dictionary<string, object> vars = new();
										  vars["x"] = 3;
										  vars["y"] = 5;
										  Console.WriteLine(e.Evaluate(vars)); // "21"
										  vars["x"] = 1.5;
										  vars["y"] = 9;
										  Console.WriteLine(e.Evaluate(vars)); // "16.5"
										  ```
								- **Method overloading**
								  collapsed:: true
									- Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures. When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke. Overload resolution finds 
									  the one method that best matches the arguments. If no single best match can be found, an error is reported. The following example shows overload resolution in effect. The comment for each invocation in the `UsageExample` method shows which method is invoked.
										- ```c#
										  class OverloadingExample
										  {
										      static void F() => Console.WriteLine("F()");
										      static void F(object x) => Console.WriteLine("F(object)");
										      static void F(int x) => Console.WriteLine("F(int)");
										      static void F(double x) => Console.WriteLine("F(double)");
										      static void F<T>(T x) => Console.WriteLine($"F<T>(T), T is {typeof(T)}");            
										      static void F(double x, double y) => Console.WriteLine("F(double, double)");
										      
										      public static void UsageExample()
										      {
										          F();            // Invokes F()
										          F(1);           // Invokes F(int)
										          F(1.0);         // Invokes F(double)
										          F("abc");       // Invokes F<T>(T), T is System.String
										          F((double)1);   // Invokes F(double)
										          F((object)1);   // Invokes F(object)
										          F<int>(1);      // Invokes F<T>(T), T is System.Int32
										          F(1, 1);        // Invokes F(double, double)
										      }
										  }
										  ```
									- As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type 
									  arguments.
							- #### Other function members
								- Members that contain executable code are collectively known as the *function members* of a class. The preceding section describes methods, which are the 
								  primary types of function members. This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.
								- The following example shows a generic class called `MyList<T>`, which implements a growable list of objects. The class contains several examples of the most common kinds of function members.
								  collapsed:: true
									- ```c#
									  public class MyList<T>
									  {
									      const int DefaultCapacity = 4;
									  
									      T[] _items;
									      int _count;
									  
									      public MyList(int capacity = DefaultCapacity)
									      {
									          _items = new T[capacity];
									      }
									  
									      public int Count => _count;
									  
									      public int Capacity
									      {
									          get =>  _items.Length;
									          set
									          {
									              if (value < _count) value = _count;
									              if (value != _items.Length)
									              {
									                  T[] newItems = new T[value];
									                  Array.Copy(_items, 0, newItems, 0, _count);
									                  _items = newItems;
									              }
									          }
									      }
									  
									      public T this[int index]
									      {
									          get => _items[index];
									          set
									          {
									              if (!object.Equals(_items[index], value)) {
									                  _items[index] = value;
									                  OnChanged();
									              }
									          }
									      }
									  
									      public void Add(T item)
									      {
									          if (_count == Capacity) Capacity = _count * 2;
									          _items[_count] = item;
									          _count++;
									          OnChanged();
									      }
									      protected virtual void OnChanged() =>
									          Changed?.Invoke(this, EventArgs.Empty);
									  
									      public override bool Equals(object other) =>
									          Equals(this, other as MyList<T>);
									  
									      static bool Equals(MyList<T> a, MyList<T> b)
									      {
									          if (Object.ReferenceEquals(a, null)) return Object.ReferenceEquals(b, null);
									          if (Object.ReferenceEquals(b, null) || a._count != b._count)
									              return false;
									          for (int i = 0; i < a._count; i++)
									          {
									              if (!object.Equals(a._items[i], b._items[i]))
									              {
									                  return false;
									              }
									          }
									          return true;
									      }
									  
									      public event EventHandler Changed;
									  
									      public static bool operator ==(MyList<T> a, MyList<T> b) =>
									          Equals(a, b);
									  
									      public static bool operator !=(MyList<T> a, MyList<T> b) =>
									          !Equals(a, b);
									  }
									  ```
								- **Constructors**
								  id:: 64f0a73f-d187-4c7d-ad86-1798d8eb5f2e
								  collapsed:: true
								  Actions required to initialize instances of the class or the class itself
									- C# supports both instance and static constructors. An *instance constructor* is a member that implements the actions required to initialize an instance of a class. A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.
									- A constructor is declared like a method with no return type and the same name as the containing class. If a constructor declaration includes a `static` modifier, it declares a static constructor. Otherwise, it declares an instance constructor.
									- Instance constructors can be overloaded and can have optional parameters. For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter. Instance constructors are invoked using the `new` operator. The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.
									  collapsed:: true
										- ```c#
										  MyList<string> list1 = new();
										  MyList<string> list2 = new(10);
										  ```
									- Unlike other members, instance constructors aren't inherited. A class has no instance constructors other than those constructors actually declared in the class. If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.
								- **Properties**
								  id:: 64f0a783-cd94-45cb-950d-6b7593e355d0
								  collapsed:: true
								  Actions associated with reading and writing named properties of the class
									- *Properties* are a natural extension of fields. Both are named members with associated types, and the syntax for accessing fields and properties is the same. However, unlike fields, properties don't denote storage locations. Instead, properties have *accessors* that specify the statements executed when their values are read or written. A *get accessor* reads the value. A *set accessor* writes the value.
									- A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon. A property that has both a get accessor and a set accessor is a *read-write property*. A property that has only a get accessor is a *read-only property*. A property that has only a set accessor is a *write-only property*.
									- A get accessor corresponds to a parameterless method with a return value of the property type. A set accessor corresponds to a method with a single parameter named value and no return type. The get accessor computes the value of the property. The set accessor provides a new value for the property. When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked. In other cases where the property is referenced, the get accessor is invoked.
									- The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively. The following code is an example of use of these properties:
									  collapsed:: true
										- ```c#
										  MyList<string> names = new();
										  names.Capacity = 100;   // Invokes set accessor
										  int i = names.Count;    // Invokes get accessor
										  int j = names.Capacity; // Invokes get accessor
										  ```
									- Similar to fields and methods, C# supports both instance properties and static properties. Static properties are declared with the static modifier, and instance properties are declared without it.
									- The accessor(s) of a property can be virtual. When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.
								- **Indexers**
								  id:: 64f0a7b3-bbca-4fa9-a7e6-b98328da288b
								  collapsed:: true
								  Actions associated with indexing instances of the class like an array
									- An *indexer* is a member that enables objects to be indexed in the same way as an array. An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`. The parameters are available in the accessor(s) of the indexer. Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.
									- The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter. The indexer makes it possible to index `MyList<T>` instances with `int` values. For example:
									  collapsed:: true
										- ```c#
										  MyList<string> names = new();
										  names.Add("Liz");
										  names.Add("Martha");
										  names.Add("Beth");
										  for (int i = 0; i < names.Count; i++)
										  {
										      string s = names[i];
										      names[i] = s.ToUpper();
										  }
										  ```
									- Indexers can be overloaded. A class can declare multiple indexers as long as the number or types of their parameters differ.
								- **Events**
								  id:: 64f0a7e4-d4f5-40dd-b66d-a09c1177254c
								  collapsed:: true
								  Notifications that can be generated by the class
									- An *event* is a member that enables a class or object to provide notifications. An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.
									- Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors). The field stores a reference to a delegate that represents the event handlers that have been added to the event. If no event handlers are present, the field is `null`.
									- The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list or a list item has been changed using the indexer set accessor. The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null`
									  (meaning that no handlers are present). The notion of raising an event is precisely equivalent to invoking the delegate represented by the event. There are no special language constructs for raising events.
									- Clients react to events through *event handlers*. Event handlers are attached using the `+=` operator and removed using the `-=` operator. The following example attaches an event handler to the `Changed` event of a `MyList<string>`.
									  collapsed:: true
										- ```c#
										  class EventExample
										  {
										      static int s_changeCount;
										      
										      static void ListChanged(object sender, EventArgs e)
										      {
										          s_changeCount++;
										      }
										      
										      public static void Usage()
										      {
										          var names = new MyList<string>();
										          names.Changed += new EventHandler(ListChanged);
										          names.Add("Liz");
										          names.Add("Martha");
										          names.Add("Beth");
										          Console.WriteLine(s_changeCount); // "3"
										      }
										  }
										  ```
									- For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.
								- **Operators**
								  id:: 64f0a823-bd55-46e1-a221-18af0839abd9
								  collapsed:: true
								  Conversions and expression operators supported by the class
									- An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class. Three kinds of operators can be defined: unary operators, binary operators, and conversion operators. All operators must be declared as `public` and `static`.
									- The `MyList<T>` class declares two operators, `operator ==` and `operator !=`. These overridden operators give new meaning to expressions that apply those operators to `MyList` instances. Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods. The following example uses the `==` operator to compare two `MyList<int>` instances.
									  collapsed:: true
										- ```c#
										  MyList<int> a = new();
										  a.Add(1);
										  a.Add(2);
										  MyList<int> b = new();
										  b.Add(1);
										  b.Add(2);
										  Console.WriteLine(a == b);  // Outputs "True"
										  b.Add(3);
										  Console.WriteLine(a == b);  // Outputs "False"
										  ```
									- The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order. Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.
								- **Finalizers**
								  id:: 64f0a84d-edf1-4a5d-a586-2c5889e6aa2a
								  collapsed:: true
								  Actions done before instances of the class are permanently discarded
									- A *finalizer* is a member that implements the actions required to finalize an instance of a class. Typically, a finalizer is needed to release unmanaged resources. Finalizers can't have parameters, they  can't have accessibility modifiers, and they can't be invoked explicitly. The finalizer for an instance is invoked automatically during garbage collection. For more information, see the article on [finalizers](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers).
									- The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers. Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread. For these and other reasons, classes should implement finalizers only when no other solutions are feasible.
									- The `using` statement provides a better approach to object destruction.
						- ### Expressions
						  collapsed:: true
							- *Expressions* are constructed from *operands* and *operators*. The operators of an expression indicate which operations to apply to the operands. Examples of operators include `+`, `-`, `*`, `/`, and `new`. Examples of operands include literals, fields, local variables, and expressions.
							- When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated. For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.
							- When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:
								- Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right. For example, `x + y + z` is evaluated as `(x + y) + z`.
								- The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left. For example, `x = y = z` is evaluated as `x = (y = z)`.
							- Precedence and associativity can be controlled using parentheses. For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.
							- Most operators can be [*overloaded*](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading). Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.
							- C# provides operators to perform [arithmetic](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators), [logical](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/boolean-logical-operators), [bitwise and shift](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators) operations and [equality](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators) and [order](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/comparison-operators) comparisons.
							- For the complete list of C# operators ordered by precedence level, see [C# operators](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/).
						- ### Statements
						  collapsed:: true
							- The actions of a program are expressed using *statements*. C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.
								- A *block* permits multiple statements to be written in contexts where a single statement is allowed. A block consists of a list of statements written between the delimiters `{` and `}`.
								- *Declaration statements* are used to declare local variables and constants.
								- *Expression statements* are used to evaluate expressions. Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.
								- *Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression. This group contains the `if` and `switch` statements.
								- *Iteration statements* are used to execute repeatedly an embedded statement. This group contains the `while`, `do`, `for`, and `foreach` statements.
								- *Jump statements* are used to transfer control. This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.
								- The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.
								- The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.
								- The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.
								- The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.
							- The following lists the kinds of statements that can be used:
								- Local variable declaration.
								- Local constant declaration.
								- Expression statement.
								- `if` statement.
								- `switch` statement.
								- `while` statement.
								- `do` statement.
								- `for` statement.
								- `foreach` statement.
								- `break` statement.
								- `continue` statement.
								- `goto` statement.
								- `return` statement.
								- `yield` statement.
								- `throw` statements and `try` statements.
								- `checked` and `unchecked` statements.
								- `lock` statement.
								- `using` statement.
					- ## [Major language areas](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/features)
						- ### Arrays, collections and LINQ
						  collapsed:: true
							- C# and .NET provide many different collection types. Arrays have syntax defined by the language. Generic collection types are listed in the [System.Collections.Generic](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic) namespace. Specialized collections include [System.Span<T>](https://learn.microsoft.com/en-us/dotnet/api/system.span-1) for accessing continuous memory on the stack frame, and [System.Memory<T>](https://learn.microsoft.com/en-us/dotnet/api/system.memory-1) for accessing continuous memory on the managed heap. All collections, including arrays, [Span<T>](https://learn.microsoft.com/en-us/dotnet/api/system.span-1), and [Memory<T>](https://learn.microsoft.com/en-us/dotnet/api/system.memory-1) share a unifying principle for iteration. You use the [System.Collections.Generic.IEnumerable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1) interface. This unifying principle means that any of the collection types can be used with LINQ queries or other algorithms. You write methods using [IEnumerable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1) and those algorithms work with any collection.
							- #### Arrays
							  collapsed:: true
								- An [**array**](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/) is a data structure that contains a number of variables that are accessed through computed indices. The variables contained in an array, also called the **elements** of the array, are all of the same type. This type is called the **element type** of the array.
								- Array types are reference types, and the declaration of an array variable simply sets aside space for a reference to an array instance. Actual array instances are created dynamically at run time using the `new` operator. The `new` operation specifies the **length** of the new array instance, which is then fixed for the lifetime of the instance. The indices of the elements of an array range from `0` to `Length - 1`. The `new`operator automatically initializes the elements of an array to their default value, which, for example, is zero for all numeric types and `null` for all reference types.
								- The following example creates an array of `int` elements, initializes the array, and prints the contents of the array.
								  collapsed:: true
									- ```c#
									  int[] a = new int[10];
									  for (int i = 0; i < a.Length; i++)
									  {
									      a[i] = i * i;
									  }
									  for (int i = 0; i < a.Length; i++)
									  {
									      Console.WriteLine($"a[{i}] = {a[i]}");
									  }
									  ```
								- This example creates and operates on a **single-dimensional array**. C# also supports **multi-dimensional arrays**. The number of dimensions of an array type, also known as the **rank** of the array type, is one plus the number of commas between the square brackets of the array type. The following example allocates a 
								  collapsed:: true
								  single-dimensional, a two-dimensional, and a three-dimensional array, respectively.
									- ```c#
									  int[] a1 = new int[10];
									  int[,] a2 = new int[10, 5];
									  int[,,] a3 = new int[10, 5, 2];
									  ```
								- The `a1` array contains 10 elements, the `a2` array contains 50 (10 × 5) elements, and the `a3` array contains 100 (10 × 5 × 2) elements. The element type of an array can be any type, including an array type. An array with elements of an array type is sometimes called a **jagged array** because the lengths of the element arrays don't all have to be the same. The following example allocates an array of arrays of `int`:
								  collapsed:: true
									- ```c#
									  int[][] a = new int[3][];
									  a[0] = new int[10];
									  a[1] = new int[5];
									  a[2] = new int[20];
									  ```
								- The first line creates an array with three elements, each of type `int[]` and each with an initial value of `null`. The next lines then initialize the three elements with references to individual array instances of varying lengths.
								- The `new` operator permits the initial values of the array elements to be specified using an **array initializer**, which is a list of expressions written between the delimiters `{` and `}`. The following example allocates and initializes an `int[]` with three elements.
								  collapsed:: true
									- ```c#
									  int[] a = new int[] { 1, 2, 3 };
									  ```
								- The length of the array is inferred from the number of expressions between `{` and `}`. Array initialization can be shortened further such that the array type doesn't have to be restated.
								  collapsed:: true
									- ```c#
									  int[] a = { 1, 2, 3 };
									  ```
								- Both of the previous examples are equivalent to the following code:
								  collapsed:: true
									- ```c#
									  int[] t = new int[3];
									  t[0] = 1;
									  t[1] = 2;
									  t[2] = 3;
									  int[] a = t;
									  ```
								- The `foreach` statement can be used to enumerate the elements of any collection. The following code enumerates the array from the preceding example:
								  collapsed:: true
									- ```c#
									  foreach (int item in a)
									  {
									      Console.WriteLine(item);
									  }
									  ```
								- The `foreach` statement uses the [IEnumerable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1) interface, so it can work with any collection.
						- ### String interpolation
						  collapsed:: true
							- C# [**string interpolation**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated) enables you to format strings by defining expressions whose results are placed in a format string. For example, the following example prints the temperature on a given day from a set of weather data:
							  collapsed:: true
								- ```c#
								  Console.WriteLine($"The low and high temperature on {weatherData.Date:MM-dd-yyyy}");
								  Console.WriteLine($"    was {weatherData.LowTemp} and {weatherData.HighTemp}.");
								  // Output (similar to):
								  // The low and high temperature on 08-11-2020
								  //     was 5 and 30.
								  ```
							- An interpolated string is declared using the `$` token. String interpolation evaluates the expressions between `{` and `}`, then converts the result to a `string`, and replaces the text between the brackets with the string result of the expression. The `:` in the first expression, `{weatherData.Date:MM-dd-yyyy}` specifies the *format string*. In the preceding example, it specifies that the date should be printed in "MM-dd-yyyy" format.
						- ### Pattern matching
						  collapsed:: true
							- The C# language provides [**pattern matching**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching) expressions to query the state of an object and execute code based on that state. You can inspect types and the values of properties and fields to determine which action to take. You can inspect the elements of a list or array as well. The `switch` expression is the primary expression for pattern matching.
						- ### Delegates and lambda expressions
						  collapsed:: true
							- A [**delegate type**](https://learn.microsoft.com/en-us/dotnet/csharp/delegates-overview) represents references to methods with a particular parameter list and 
							  return type. Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters. Delegates are similar to the concept of function pointers found in some other languages. Unlike function pointers, delegates are object-oriented and type-safe.
							- The following example declares and uses a delegate type named `Function`.
							  collapsed:: true
								- ```c#
								  delegate double Function(double x);
								  
								  class Multiplier
								  {
								      double _factor;
								  
								      public Multiplier(double factor) => _factor = factor;
								  
								      public double Multiply(double x) => x * _factor;
								  }
								  
								  class DelegateExample
								  {
								      static double[] Apply(double[] a, Function f)
								      {
								          var result = new double[a.Length];
								          for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
								          return result;
								      }
								  
								      public static void Main()
								      {
								          double[] a = { 0.0, 0.5, 1.0 };
								          double[] squares = Apply(a, (x) => x * x);
								          double[] sines = Apply(a, Math.Sin);
								          Multiplier m = new(2.0);
								          double[] doubles = Apply(a, m.Multiply);
								      }
								  }
								  ```
							- An instance of the `Function` delegate type can reference any method that takes a `double` argument and returns a `double` value. The `Apply` method applies a given `Function` to the elements of a `double[]`, returning a `double[]` with the results. In the `Main` method, `Apply` is used to apply three different functions to a `double[]`.
							- A delegate can reference either a lambda expression to create an anonymous function (such as `(x) => x * x` in the previous example), a static method (such as `Math.Sin` in the previous example) or an instance method (such as `m.Multiply`in the previous example). A delegate that references an instance method
							  also references a particular object, and when the instance method is invoked through the delegate, that object becomes `this` in the invocation.
							- Delegates can also be created using anonymous functions or lambda expressions, which are "inline methods" that are created when declared. Anonymous functions can see the local variables of the surrounding methods. The following example doesn't create a class:
							  collapsed:: true
								- ```c#
								  double[] doubles = Apply(a, (double x) => x * 2.0);
								  ```
							- A delegate doesn't know or care about the class of the method it references. The referenced method must have the same parameters and return type as the delegate.
						- ### async / await
						  collapsed:: true
							- C# supports asynchronous programs with two keywords: `async` and `await`. You add the `async` modifier to a method declaration to declare the method is asynchronous. The `await` operator tells the compiler to asynchronously await for a result to finish. Control is returned to the caller, and the method returns a 
							  collapsed:: true
							  structure that manages the state of the asynchronous work. The structure is typically a [System.Threading.Tasks.Task<TResult>](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1), but can be any type that supports the awaiter pattern. These features enable you to write code that reads as its synchronous counterpart, but executes asynchronously. For example, the following code downloads the home page for [Microsoft docs](https://learn.microsoft.com/en-us/):
								- ```c#
								  public async Task<int> RetrieveDocsHomePage()
								  {
								      var client = new HttpClient();
								      byte[] content = await client.GetByteArrayAsync("[Content Issue](https://learn.microsoft.com/");)
								  
								      Console.WriteLine($"{nameof(RetrieveDocsHomePage)}: Finished downloading.");
								      return content.Length;
								  }
								  ```
							- This small sample shows the major features for asynchronous programming:
							  collapsed:: true
								- The method declaration includes the `async` modifier.
								- The body of the method `await`s the return of the `GetByteArrayAsync` method.
								- The type specified in the `return` statement matches the type argument in the `Task<T>` declaration for the method. (A method that returns a `Task` would use `return` statements without any argument).
						- ### Attributes
						  collapsed:: true
							- Types, members, and other entities in a C# program support modifiers that control certain aspects of their behavior. For example, the accessibility of a method is controlled using the `public`, `protected`, `internal`, and `private`modifiers. C# generalizes this capability such that user-defined types of declarative information can be attached to program entities and retrieved at run-time. Programs specify this declarative information by defining and using [**attributes**](https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/reflection-and-attributes).
							- The following example declares a `HelpAttribute` attribute that can be placed on program entities to provide links to their associated documentation.
							  collapsed:: true
								- ```c#
								  public class HelpAttribute : Attribute
								  {
								      string _url;
								      string _topic;
								  
								      public HelpAttribute(string url) => _url = url;
								  
								      public string Url => _url;
								  
								      public string Topic
								      {
								          get => _topic;
								          set => _topic = value;
								      }
								  }
								  ```
							- All attribute classes derive from the [Attribute](https://learn.microsoft.com/en-us/dotnet/api/system.attribute) base class provided by the .NET library. Attributes can be applied by giving their name, along with any arguments, inside square brackets just before the associated declaration. If an attribute's name ends in `Attribute`, that part of the name can be omitted when the attribute is referenced. For example, the `HelpAttribute` can be used as follows.
							  collapsed:: true
								- ```c#
								  [Help("[Content Issue](https://learn.microsoft.com/dotnet/csharp/tour-of-csharp/features")])
								  public class Widget
								  {
								      [Help("[Content Issue](https://learn.microsoft.com/dotnet/csharp/tour-of-csharp/features",)
								      Topic = "Display")]
								      public void Display(string text) { }
								  }
								  ```
							- This example attaches a `HelpAttribute` to the `Widget` class. It adds another `HelpAttribute` to the `Display`method in the class. The public constructors of an attribute class control the information that must be provided when the attribute is attached to a program entity. Additional information can be provided by 
							  referencing public read-write properties of the attribute class (such as the reference to the `Topic` property previously).
							- The metadata defined by attributes can be read and manipulated at run time using reflection. When a particular attribute is requested using this technique, the constructor for the attribute class is invoked with the information provided in the program source. The resulting attribute instance is returned. If additional information was provided through properties, those properties are set to the given values before the attribute instance is returned.
							- The following code sample demonstrates how to get the `HelpAttribute` instances associated to the `Widget` class and its `Display` method:
							  collapsed:: true
								- ```c#
								  Type widgetType = typeof(Widget);
								  
								  object[] widgetClassAttributes = widgetType.GetCustomAttributes(typeof(HelpAttribute), false);
								  
								  if (widgetClassAttributes.Length > 0)
								  {
								      HelpAttribute attr = (HelpAttribute)widgetClassAttributes[0];
								      Console.WriteLine($"Widget class help URL : {attr.Url} - Related topic : {attr.Topic}");
								  }
								  
								  System.Reflection.MethodInfo displayMethod = widgetType.GetMethod(nameof(Widget.Display));
								  
								  object[] displayMethodAttributes = displayMethod.GetCustomAttributes(typeof(HelpAttribute), false);
								  
								  if (displayMethodAttributes.Length > 0)
								  {
								      HelpAttribute attr = (HelpAttribute)displayMethodAttributes[0];
								      Console.WriteLine($"Display method help URL : {attr.Url} - Related topic : {attr.Topic}");
								  }
								  ```
							-
				- [Tutorials](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/)
				  id:: 643a7b39-a636-4105-a23f-49fc662cdd4f
				  collapsed:: true
					- [Hello World](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/hello-world) - added notes to ((643a7f7d-e036-4029-9342-498f14235cdb))
					  collapsed:: true
						- Example
							- ```c#
							  using System;
							  
							  class Hello
							  {
							      static void Main()
							      {
							          // This line prints "Hello, World" 
							          Console.WriteLine("Hello, World");
							      }
							  }
							  ```
								- Namespaces and `using`
									- `using` directive that references the `System` namespace. Namespaces provide a hierarchical means of organizing C# programs and libraries. Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and many other namespaces, such as `IO` and `Collections`.
									- A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace. Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.
									- Alternatively without `using System`:
									  collapsed:: true
										- ```c#
										  class Hello
										  {
										      static void Main()
										      {
										          // This line prints "Hello, World" 
										          System.Console.WriteLine("Hello, World");
										      }
										  }
										  ```
								- `Main` is a method, declared with a `static` modifier
									- By convention, a static method named `Main` serves as the entry point of a C# program.
									- While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.
								- ((643aaea3-e008-4339-98a5-42d23d0eec80))
					- [Numbers in C#](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/numbers-in-csharp)
					- [Branches and loops](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/branches-and-loops)
					- [Data collections](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/list-collection)
					- [101 Linq Samples](https://github.com/dotnet/try-samples/tree/main/101-linq-samples)
						- This sample requires the [dotnet-try](https://github.com/dotnet/try/blob/main/README.md#setup) global tool. Once you install the tool, and clone the [try-samples](https://github.com/dotnet/try-samples) repo, you can learn Language Integrated Query (LINQ) through a set of 101 samples you can run interactively. You can explore different ways to query, explore, and transform data sequences.
			- 2) Fundamentals
			  id:: 6463496d-822c-447a-8c11-a21b44348fdd
			  collapsed:: true
				- Notes
					- ## [Program structure](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/)
					- ## [Type system](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/)
					- ## Object-oriented programming
					- ## Functional techniques
					- ## Exceptions and errors
					- ## Coding style
				- Tutorials
				  id:: 6463496d-b165-4d8b-8d84-654376a37512
					- [How to display command-line arguments](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/how-to-display-command-line-arguments)
					- [Introduction to classes](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/classes)
					- [Object-oriented C#](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop)
					- [Inheritance in C# and .NET](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance)
					- [Converting types](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/safely-cast-using-pattern-matching-is-and-as-operators)
					- [Build data-driven algorithms with pattern matching](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/pattern-matching)
					- [How to handle an exception using try-catch](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/how-to-handle-an-exception-using-try-catch)
					- [How to execute cleanup code using finally](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/how-to-execute-cleanup-code-using-finally)
			- 3) What's new in [[C#]]
			  id:: 6463496d-d38a-4a73-995d-a03a0b4c9ea8
			  collapsed:: true
				- Notes
					- C# 12
					- C# 11
					- C# 10
					- C# 9.0
					- Relationships to .NET library
				- Tutorials
				  id:: 6463496d-1426-4bfd-a939-1f3c12ae8501
					- [Explore static interface members](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members)
					- [Explore record types](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/records)
					- [Explore top-level statements](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements)
					- [Explore patterns in objects](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/patterns-objects)
					- [Write a custom string interpolation handler](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/interpolated-string-handler)
			- 4) Tutorials
			  collapsed:: true
				- Earlier tutorials
					- ((643aaea3-1255-47c9-abe2-948d39fa1470)) : ((643a7b39-a636-4105-a23f-49fc662cdd4f))
					  collapsed:: true
						- {{embed ((643a7b39-a636-4105-a23f-49fc662cdd4f))}}
					- ((6463496d-822c-447a-8c11-a21b44348fdd)) : ((6463496d-b165-4d8b-8d84-654376a37512))
					- ((6463496d-d38a-4a73-995d-a03a0b4c9ea8)) : ((6463496d-1426-4bfd-a939-1f3c12ae8501))
				- [Explore indexes and ranges](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes)
				- [Work with nullable reference types](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/nullable-reference-types)
				- [Explore string interpolation - interactive](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/exploration/interpolated-strings)
				- [Explore string interpolation - in your environment](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/exploration/interpolated-strings-local)
				- [Advanced scenarios for string Interpolation](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/string-interpolation)
				- [Console Application](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/console-teleprompter)
				- [REST Client](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/console-webapiclient)
				- [Work with LINQ](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/working-with-linq)
			- ..
			- [C# Programming Guide](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/)
			  id:: 643aaea3-1dfd-4793-a1f6-4ba2cf253944
			  collapsed:: true
				- Classes, Structs and Records
					- Polymorphism
					- Members
						- [Access Modifiers](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)
						  id:: 643c4a4f-98cc-404b-beff-d58e8266009c
						  collapsed:: true
							- All types and type members have an accessibility level. The accessibility level controls whether they can be used from other code in your assembly or other assemblies. An [assembly](https://learn.microsoft.com/en-us/dotnet/standard/glossary#assembly) is a *.dll* or *.exe* created by compiling one or more *.cs* files in a single compilation. Use the following access modifiers to specify the accessibility of a type or member when you declare it:
								- [public](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public): The type or member can be accessed by any other code in the same assembly or another assembly that references it. The accessibility level of public members of a type is controlled by the accessibility level of the type itself.
								- [private](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private): The type or member can be accessed only by code in the same `class` or `struct`.
								- [protected](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected): The type or member can be accessed only by code in the same `class`, or in a `class` that is derived from that `class`.
								- [internal](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/internal): The type or member can be accessed by any code in the same assembly, but not from another assembly. In other words, `internal` types or members can be accessed from code that is part of the same compilation.
								- [protected internal](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal): The type or member can be accessed by any code in the assembly in which it's declared, or from within a derived `class` in another assembly.
								- [private protected](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private-protected): The type or member can be accessed by types derived from the `class` that are declared within its containing assembly.
							- Summary table
								- ![image.png](../assets/image_1681672897319_0.png)
							- See webpage for more info
							- Related: ((643c49e4-393a-4dc9-ae4d-1cb5f1a05481))
			- [C# reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/)
			  collapsed:: true
			  Incomplete
				- Overview
				- Configure language version
				- Types
				- Keywords
					- Modifiers
						- Access Modifiers
						  id:: 643c49e4-393a-4dc9-ae4d-1cb5f1a05481
						  collapsed:: true
							- [Quick reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers)
							  id:: 643c49ed-6772-4f80-a99a-911b967b48b6
							  collapsed:: true
								- Access modifiers are keywords used to specify the declared accessibility of a member or a type. This section introduces the five access modifiers:
									- `public`
									- `protected`
									- `internal`
									- `private`
									- `file`
								- Declaring an access modifier isn't mandatory, but the default is `private`
								- The following seven accessibility levels can be specified using the access modifiers:
									- [`public`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public): Access isn't restricted.
										- e.g. if you have a `public class` in a particular namespace, now it'll be accessible to other classes in the same namespace without need to use a `using` statement or fully-qualify the class name with its namespace
									- [`protected`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected): Access is limited to the containing class or types derived from the containing class.
									- [`internal`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/internal): Access is limited to the current assembly.
									- [`protected internal`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal): Access is limited to the current assembly or types derived from the containing class.
									- [`private`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private): Access is limited to the containing type.
									- [`private protected`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private-protected): Access is limited to the containing class or types derived from the containing class within the current assembly.
									- [`file`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/file): The declared type is only visible in the current source file. File scoped types are generally used for source generators.
								- This section also introduces the following concepts:
									- [Accessibility Levels](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels): Using the four access modifiers to declare six levels of accessibility.
									- [Accessibility Domain](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-domain): Specifies where, in the program sections, a member can be referenced.
									- [Restrictions on Using Accessibility Levels](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/restrictions-on-using-accessibility-levels): A summary of the restrictions on using declared accessibility levels.
							- Related: ((643c4a4f-98cc-404b-beff-d58e8266009c))
				- Operators and expressions
				- Statements
					- [Declaration statements](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/declarations)
					  collapsed:: true
						- A declaration statement declares a new local variable, local constant, or [local reference variable](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/declarations#reference-variables). To declare a local variable, specify its type and provide its name. You can declare multiple variables of the same type in one statement,
							- Example
								- ```c#
								  string greeting;
								  int a, b, c;
								  List<double> xs;
								  ```
					- Exception-handling statemetns
					- Iteration statements
					- Selection statements
					- Jump statements
					- checked and unchecked statements
					- fixed statement
					- lock statement
					- using ctatement
					- yield statement
				- Special characters
				- Attributes read by the compiler
				- Unsafe code and pointers
				- Preprocessor directives
				- Compiler options
				- XML documentation comments
				- Compiler messages
		- [.NET API](https://learn.microsoft.com/en-us/dotnet/api/)
		  id:: 643a7f7d-e036-4029-9342-498f14235cdb
		  collapsed:: true
			- .NET 7
				- [System Namespace](https://learn.microsoft.com/en-us/dotnet/api/system?view=net-7.0)
				  id:: 643a7fac-0ab2-4e76-9c2e-a3dc715fcc66
					- [Classes](https://learn.microsoft.com/en-us/dotnet/standard/class-library-overview)
						- *Notable*
							- [Boolean](https://learn.microsoft.com/en-us/dotnet/api/system.boolean)
							  collapsed:: true
								- Methods
									- [CompareTo](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.compareto?view=net-7.0)
									- [Equals](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.equals?view=net-7.0)
									- [GetHashCode](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.gethashcode?view=net-7.0)
									- [GetTypeCode](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.gettypecode?view=net-7.0)
									- [Parse](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.parse?view=net-7.0)
									- [ToString](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.tostring?view=net-7.0)
									- [TryFormat](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.tryformat?view=net-7.0)
									- [TryParse](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.tryparse?view=net-7.0)
								- https://learn.microsoft.com/en-us/dotnet/api/system.boolean
							- [Console](https://learn.microsoft.com/en-us/dotnet/api/system.console?view=net-7.0)
							  collapsed:: true
								- Methods
									- [Beep](https://learn.microsoft.com/en-us/dotnet/api/system.console.beep?view=net-7.0)
									- [Clear](https://learn.microsoft.com/en-us/dotnet/api/system.console.clear?view=net-7.0)
									- [GetCursorPosition](https://learn.microsoft.com/en-us/dotnet/api/system.console.getcursorposition?view=net-7.0)
									- [MoveBufferArea](https://learn.microsoft.com/en-us/dotnet/api/system.console.movebufferarea?view=net-7.0)
									- [OpenStandardError](https://learn.microsoft.com/en-us/dotnet/api/system.console.openstandarderror?view=net-7.0)
									- [OpenStandardInput](https://learn.microsoft.com/en-us/dotnet/api/system.console.openstandardinput?view=net-7.0)
									- [OpenStandardOutput](https://learn.microsoft.com/en-us/dotnet/api/system.console.openstandardoutput?view=net-7.0)
									- [Read](https://learn.microsoft.com/en-us/dotnet/api/system.console.read?view=net-7.0)
									- [ReadKey](https://learn.microsoft.com/en-us/dotnet/api/system.console.readkey?view=net-7.0)
									- [ReadLine](https://learn.microsoft.com/en-us/dotnet/api/system.console.readline?view=net-7.0)
									- [ResetColor](https://learn.microsoft.com/en-us/dotnet/api/system.console.resetcolor?view=net-7.0)
									- [SetBufferSize](https://learn.microsoft.com/en-us/dotnet/api/system.console.setbuffersize?view=net-7.0)
									- [SetCursorPosition](https://learn.microsoft.com/en-us/dotnet/api/system.console.setcursorposition?view=net-7.0)
									- [SetError](https://learn.microsoft.com/en-us/dotnet/api/system.console.seterror?view=net-7.0)
									- [SetIn](https://learn.microsoft.com/en-us/dotnet/api/system.console.setin?view=net-7.0)
									- [SetOut](https://learn.microsoft.com/en-us/dotnet/api/system.console.setout?view=net-7.0)
									- [SetWindowPosition](https://learn.microsoft.com/en-us/dotnet/api/system.console.setwindowposition?view=net-7.0)
									- [SetWindowSize](https://learn.microsoft.com/en-us/dotnet/api/system.console.setwindowsize?view=net-7.0)
									- [Write](https://learn.microsoft.com/en-us/dotnet/api/system.console.write?view=net-7.0)
									- [WriteLine](https://learn.microsoft.com/en-us/dotnet/api/system.console.writeline?view=net-7.0)
									  id:: 643aaea3-e008-4339-98a5-42d23d0eec80
									  Equivalent to ((63904f40-40ea-45ad-b746-cc99692a819d)) . ((64024e42-a0ab-4278-9c5b-4cc98409efd8))
										- Note: To use this method you'll need to import the `System` namespace at the top of the file
										- Example
											- With `using System`:
											  ```c#
											  using System;
											  
											  class Hello
											  {
											      static void Main()
											      {
											          // This line prints "Hello, World" 
											          Console.WriteLine("Hello, World");
											      }
											  }
											  ```
											- Without `using System`:
											  ```c#
											  class Hello
											  {
											    static void Main()
											    {
											        // This line prints "Hello, World" 
											        System.Console.WriteLine("Hello, World");
											    }
											  }
											  ```
							- [Enum](https://learn.microsoft.com/en-us/dotnet/api/system.enum?view=net-7.0)
							  collapsed:: true
								- Methods
									- [CompareTo](https://learn.microsoft.com/en-us/dotnet/api/system.enum.compareto?view=net-7.0)
									- [Equals](https://learn.microsoft.com/en-us/dotnet/api/system.enum.equals?view=net-7.0)
									- [Format](https://learn.microsoft.com/en-us/dotnet/api/system.enum.format?view=net-7.0)
									- [GetHashCode](https://learn.microsoft.com/en-us/dotnet/api/system.enum.gethashcode?view=net-7.0)
									- [GetName](https://learn.microsoft.com/en-us/dotnet/api/system.enum.getname?view=net-7.0)
									- [GetNames](https://learn.microsoft.com/en-us/dotnet/api/system.enum.getnames?view=net-7.0)
									- [GetTypeCode](https://learn.microsoft.com/en-us/dotnet/api/system.enum.gettypecode?view=net-7.0)
									- [GetUnderlyingType](https://learn.microsoft.com/en-us/dotnet/api/system.enum.getunderlyingtype?view=net-7.0)
									- [GetValues](https://learn.microsoft.com/en-us/dotnet/api/system.enum.getvalues?view=net-7.0)
									- [GetValuesAsUnderlyingType](https://learn.microsoft.com/en-us/dotnet/api/system.enum.getvaluesasunderlyingtype?view=net-7.0)
									- [HasFlag](https://learn.microsoft.com/en-us/dotnet/api/system.enum.hasflag?view=net-7.0)
									- [IsDefined](https://learn.microsoft.com/en-us/dotnet/api/system.enum.isdefined?view=net-7.0)
									- [Parse](https://learn.microsoft.com/en-us/dotnet/api/system.enum.parse?view=net-7.0)
									- [ToObject](https://learn.microsoft.com/en-us/dotnet/api/system.enum.toobject?view=net-7.0)
									- [ToString](https://learn.microsoft.com/en-us/dotnet/api/system.enum.tostring?view=net-7.0)
									- [TryParse](https://learn.microsoft.com/en-us/dotnet/api/system.enum.tryparse?view=net-7.0)
							- [Math](https://learn.microsoft.com/en-us/dotnet/api/system.math?view=net-7.0)
							  collapsed:: true
								- Methods
									- [Abs](https://learn.microsoft.com/en-us/dotnet/api/system.math.abs?view=net-7.0)
									- [Acos](https://learn.microsoft.com/en-us/dotnet/api/system.math.acos?view=net-7.0)
									- [Acosh](https://learn.microsoft.com/en-us/dotnet/api/system.math.acosh?view=net-7.0)
									- [Asin](https://learn.microsoft.com/en-us/dotnet/api/system.math.asin?view=net-7.0)
									- [Asinh](https://learn.microsoft.com/en-us/dotnet/api/system.math.asinh?view=net-7.0)
									- [Atan](https://learn.microsoft.com/en-us/dotnet/api/system.math.atan?view=net-7.0)
									- [Atan2](https://learn.microsoft.com/en-us/dotnet/api/system.math.atan2?view=net-7.0)
									- [Atanh](https://learn.microsoft.com/en-us/dotnet/api/system.math.atanh?view=net-7.0)
									- [BigMul](https://learn.microsoft.com/en-us/dotnet/api/system.math.bigmul?view=net-7.0)
									- [BitDecrement](https://learn.microsoft.com/en-us/dotnet/api/system.math.bitdecrement?view=net-7.0)
									- [BitIncrement](https://learn.microsoft.com/en-us/dotnet/api/system.math.bitincrement?view=net-7.0)
									- [Cbrt](https://learn.microsoft.com/en-us/dotnet/api/system.math.cbrt?view=net-7.0)
									- [Ceiling](https://learn.microsoft.com/en-us/dotnet/api/system.math.ceiling?view=net-7.0)
									- [Clamp](https://learn.microsoft.com/en-us/dotnet/api/system.math.clamp?view=net-7.0)
									- [CopySign](https://learn.microsoft.com/en-us/dotnet/api/system.math.copysign?view=net-7.0)
									- [Cos](https://learn.microsoft.com/en-us/dotnet/api/system.math.cos?view=net-7.0)
									- [Cosh](https://learn.microsoft.com/en-us/dotnet/api/system.math.cosh?view=net-7.0)
									- [DivRem](https://learn.microsoft.com/en-us/dotnet/api/system.math.divrem?view=net-7.0)
									- [Exp](https://learn.microsoft.com/en-us/dotnet/api/system.math.exp?view=net-7.0)
									- [Floor](https://learn.microsoft.com/en-us/dotnet/api/system.math.floor?view=net-7.0)
									- [FusedMultiplyAdd](https://learn.microsoft.com/en-us/dotnet/api/system.math.fusedmultiplyadd?view=net-7.0)
									- [IEEERemainder](https://learn.microsoft.com/en-us/dotnet/api/system.math.ieeeremainder?view=net-7.0)
									- [ILogB](https://learn.microsoft.com/en-us/dotnet/api/system.math.ilogb?view=net-7.0)
									- [Log](https://learn.microsoft.com/en-us/dotnet/api/system.math.log?view=net-7.0)
									- [Log10](https://learn.microsoft.com/en-us/dotnet/api/system.math.log10?view=net-7.0)
									- [Log2](https://learn.microsoft.com/en-us/dotnet/api/system.math.log2?view=net-7.0)
									- [Max](https://learn.microsoft.com/en-us/dotnet/api/system.math.max?view=net-7.0)
									- [MaxMagnitude](https://learn.microsoft.com/en-us/dotnet/api/system.math.maxmagnitude?view=net-7.0)
									- [Min](https://learn.microsoft.com/en-us/dotnet/api/system.math.min?view=net-7.0)
									- [MinMagnitude](https://learn.microsoft.com/en-us/dotnet/api/system.math.minmagnitude?view=net-7.0)
									- [Pow](https://learn.microsoft.com/en-us/dotnet/api/system.math.pow?view=net-7.0)
									- [ReciprocalEstimate](https://learn.microsoft.com/en-us/dotnet/api/system.math.reciprocalestimate?view=net-7.0)
									- [ReciprocalSqrtEstimate](https://learn.microsoft.com/en-us/dotnet/api/system.math.reciprocalsqrtestimate?view=net-7.0)
									- [Round](https://learn.microsoft.com/en-us/dotnet/api/system.math.round?view=net-7.0)
									- [ScaleB](https://learn.microsoft.com/en-us/dotnet/api/system.math.scaleb?view=net-7.0)
									- [Sign](https://learn.microsoft.com/en-us/dotnet/api/system.math.sign?view=net-7.0)
									- [Sin](https://learn.microsoft.com/en-us/dotnet/api/system.math.sin?view=net-7.0)
									- [SinCos](https://learn.microsoft.com/en-us/dotnet/api/system.math.sincos?view=net-7.0)
									- [Sinh](https://learn.microsoft.com/en-us/dotnet/api/system.math.sinh?view=net-7.0)
									- [Sqrt](https://learn.microsoft.com/en-us/dotnet/api/system.math.sqrt?view=net-7.0)
									- [Tan](https://learn.microsoft.com/en-us/dotnet/api/system.math.tan?view=net-7.0)
									- [Tanh](https://learn.microsoft.com/en-us/dotnet/api/system.math.tanh?view=net-7.0)
									- [Truncate](https://learn.microsoft.com/en-us/dotnet/api/system.math.truncate?view=net-7.0)
							- [Object](https://learn.microsoft.com/en-us/dotnet/api/system.object?view=net-7.0)
							  collapsed:: true
								- Methods
									- [Equals](https://learn.microsoft.com/en-us/dotnet/api/system.object.equals?view=net-7.0)
									- [Finalize](https://learn.microsoft.com/en-us/dotnet/api/system.object.finalize?view=net-7.0)
									- [GetHashCode](https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-7.0)
									- [GetType](https://learn.microsoft.com/en-us/dotnet/api/system.object.gettype?view=net-7.0)
									- [MemberwiseClone](https://learn.microsoft.com/en-us/dotnet/api/system.object.memberwiseclone?view=net-7.0)
									- [ReferenceEquals](https://learn.microsoft.com/en-us/dotnet/api/system.object.referenceequals?view=net-7.0)
									- [ToString](https://learn.microsoft.com/en-us/dotnet/api/system.object.tostring?view=net-7.0)
							- [String](https://learn.microsoft.com/en-us/dotnet/api/system.string?view=net-7.0)
							  collapsed:: true
								- Methods
									- [Clone](https://learn.microsoft.com/en-us/dotnet/api/system.string.clone?view=net-7.0)
									- [Compare](https://learn.microsoft.com/en-us/dotnet/api/system.string.compare?view=net-7.0)
									- [CompareOrdinal](https://learn.microsoft.com/en-us/dotnet/api/system.string.compareordinal?view=net-7.0)
									- [CompareTo](https://learn.microsoft.com/en-us/dotnet/api/system.string.compareto?view=net-7.0)
									- [Concat](https://learn.microsoft.com/en-us/dotnet/api/system.string.concat?view=net-7.0)
									- [Contains](https://learn.microsoft.com/en-us/dotnet/api/system.string.contains?view=net-7.0)
									  id:: 37afa87a-5bdc-403e-a94b-e30627308290
									  collapsed:: true
									  Check if a substring is inside it | Similar to ((502a2eb1-0412-4a8f-9651-155e7389102f)), ((b3f829c5-ae83-4971-9290-a6b93a6f4e51))
										- Example
											- ```c#
											  string songLyrics = "You say goodbye, and I say hello";
											  Console.WriteLine(songLyrics.Contains("goodbye"));
											  // True
											  Console.WriteLine(songLyrics.Contains("greetings"));
											  // False
											  ```
									- [Copy](https://learn.microsoft.com/en-us/dotnet/api/system.string.copy?view=net-7.0)
									- [CopyTo](https://learn.microsoft.com/en-us/dotnet/api/system.string.copyto?view=net-7.0)
									- [Create](https://learn.microsoft.com/en-us/dotnet/api/system.string.create?view=net-7.0)
									- [EndsWith](https://learn.microsoft.com/en-us/dotnet/api/system.string.endswith?view=net-7.0)
									  id:: b3f829c5-ae83-4971-9290-a6b93a6f4e51
									  Similar to ((502a2eb1-0412-4a8f-9651-155e7389102f)), ((37afa87a-5bdc-403e-a94b-e30627308290))
										- Example
											- ```c#
											  string songLyrics = "You say goodbye, and I say hello";
											  Console.WriteLine(songLyrics.EndsWith("hello"));
											  // True
											  ```
									- [EnumerateRunes](https://learn.microsoft.com/en-us/dotnet/api/system.string.enumeraterunes?view=net-7.0)
									- [Equals](https://learn.microsoft.com/en-us/dotnet/api/system.string.equals?view=net-7.0)
									- [Format](https://learn.microsoft.com/en-us/dotnet/api/system.string.format?view=net-7.0)
									- [GetEnumerator](https://learn.microsoft.com/en-us/dotnet/api/system.string.getenumerator?view=net-7.0)
									- [GetHashCode](https://learn.microsoft.com/en-us/dotnet/api/system.string.gethashcode?view=net-7.0)
									- [GetPinnableReference](https://learn.microsoft.com/en-us/dotnet/api/system.string.getpinnablereference?view=net-7.0)
									- [GetTypeCode](https://learn.microsoft.com/en-us/dotnet/api/system.string.gettypecode?view=net-7.0)
									- [IndexOf](https://learn.microsoft.com/en-us/dotnet/api/system.string.indexof?view=net-7.0)
									- [IndexOfAny](https://learn.microsoft.com/en-us/dotnet/api/system.string.indexofany?view=net-7.0)
									- [Insert](https://learn.microsoft.com/en-us/dotnet/api/system.string.insert?view=net-7.0)
									- [Intern](https://learn.microsoft.com/en-us/dotnet/api/system.string.intern?view=net-7.0)
									- [IsInterned](https://learn.microsoft.com/en-us/dotnet/api/system.string.isinterned?view=net-7.0)
									- [IsNormalized](https://learn.microsoft.com/en-us/dotnet/api/system.string.isnormalized?view=net-7.0)
									- [IsNullOrEmpty](https://learn.microsoft.com/en-us/dotnet/api/system.string.isnullorempty?view=net-7.0)
									- [IsNullOrWhiteSpace](https://learn.microsoft.com/en-us/dotnet/api/system.string.isnullorwhitespace?view=net-7.0)
									- [Join](https://learn.microsoft.com/en-us/dotnet/api/system.string.join?view=net-7.0)
									- [LastIndexOf](https://learn.microsoft.com/en-us/dotnet/api/system.string.lastindexof?view=net-7.0)
									- [LastIndexOfAny](https://learn.microsoft.com/en-us/dotnet/api/system.string.lastindexofany?view=net-7.0)
									- [Normalize](https://learn.microsoft.com/en-us/dotnet/api/system.string.normalize?view=net-7.0)
									- [PadLeft](https://learn.microsoft.com/en-us/dotnet/api/system.string.padleft?view=net-7.0)
									- [PadRight](https://learn.microsoft.com/en-us/dotnet/api/system.string.padright?view=net-7.0)
									- [Remove](https://learn.microsoft.com/en-us/dotnet/api/system.string.remove?view=net-7.0)
									- [Replace](https://learn.microsoft.com/en-us/dotnet/api/system.string.replace?view=net-7.0)
									  collapsed:: true
										- Example
										  collapsed:: true
											- ```c#
											  string sayHello = "Hello World!";
											  Console.WriteLine(sayHello);
											  // Hello World!
											  sayHello = sayHello.Replace("Hello", "Greetings");
											  Console.WriteLine(sayHello);
											  // Greetings World!
											  ```
									- [ReplaceLineEndings](https://learn.microsoft.com/en-us/dotnet/api/system.string.replacelineendings?view=net-7.0)
									- [Split](https://learn.microsoft.com/en-us/dotnet/api/system.string.split?view=net-7.0)
									- [StartsWith](https://learn.microsoft.com/en-us/dotnet/api/system.string.startswith?view=net-7.0)
									  id:: 502a2eb1-0412-4a8f-9651-155e7389102f
									  Similar to ((b3f829c5-ae83-4971-9290-a6b93a6f4e51)), ((37afa87a-5bdc-403e-a94b-e30627308290))
										- Example
											- ```c#
											  string songLyrics = "You say goodbye, and I say hello";
											  Console.WriteLine(songLyrics.StartsWith("You"));
											  // True
											  ```
									- [Substring](https://learn.microsoft.com/en-us/dotnet/api/system.string.substring?view=net-7.0)
									- [ToCharArray](https://learn.microsoft.com/en-us/dotnet/api/system.string.tochararray?view=net-7.0)
									- [ToLower](https://learn.microsoft.com/en-us/dotnet/api/system.string.tolower?view=net-7.0)
									  collapsed:: true
										- Example
										  collapsed:: true
											- ```c#
											  string sayHello = "Hello World!";
											  Console.WriteLine(sayHello.ToLower());
											  // hello world!
											  ```
									- [ToLowerInvariant](https://learn.microsoft.com/en-us/dotnet/api/system.string.tolowerinvariant?view=net-7.0)
									- [ToString](https://learn.microsoft.com/en-us/dotnet/api/system.string.tostring?view=net-7.0)
									- [ToUpper](https://learn.microsoft.com/en-us/dotnet/api/system.string.toupper?view=net-7.0)
									  collapsed:: true
										- Example
										  collapsed:: true
											- ```c#
											  string sayHello = "Hello World!";
											  Console.WriteLine(sayHello.ToUpper());
											  // HELLO WORLD!
											  ```
									- [ToUpperInvariant](https://learn.microsoft.com/en-us/dotnet/api/system.string.toupperinvariant?view=net-7.0)
									- [Trim](https://learn.microsoft.com/en-us/dotnet/api/system.string.trim?view=net-7.0)
									  collapsed:: true
										- Can be used to easily remove whitespace
										  collapsed:: true
											- ```c#
											  string greeting = "      Hello World!       ";
											  Console.WriteLine($"[{greeting}]");
											  // [      Hello World!       ]
											  
											  string trimmedGreeting = greeting.TrimStart();
											  Console.WriteLine($"[{trimmedGreeting}]");
											  // [Hello World!       ]
											  
											  trimmedGreeting = greeting.TrimEnd();
											  Console.WriteLine($"[{trimmedGreeting}]");
											  // [      Hello World!]
											  
											  trimmedGreeting = greeting.Trim();
											  Console.WriteLine($"[{trimmedGreeting}]");
											  // [Hello World!]
											  ```
									- [TrimEnd](https://learn.microsoft.com/en-us/dotnet/api/system.string.trimend?view=net-7.0)
									- [TrimStart](https://learn.microsoft.com/en-us/dotnet/api/system.string.trimstart?view=net-7.0)
									- [TryCopyTo](https://learn.microsoft.com/en-us/dotnet/api/system.string.trycopyto?view=net-7.0)
							- [Tuple](https://learn.microsoft.com/en-us/dotnet/api/system.tuple?view=net-7.0)
							  collapsed:: true
								- Methods
									- [Create](https://learn.microsoft.com/en-us/dotnet/api/system.tuple.create?view=net-7.0)
- _Example codebases to read/enhance_
  collapsed:: true
	- [SS3D](https://github.com/RE-SS3D/SS3D)
	- [Unitystation](https://github.com/unitystation/unitystation)
	- [Space Station 14](https://github.com/space-wizards/space-station-14)
- [Learning Resources]
  collapsed:: true
	- [SS14 recommended resources](https://docs.spacestation14.io/en/getting-started/how-do-i-code)
		- ((643aaea3-1255-47c9-abe2-948d39fa1470)) : ((643a7b39-a636-4105-a23f-49fc662cdd4f))
		  id:: 643a7179-82c1-4452-a66f-53c389bfac13
		- ((643aaea3-1dfd-4793-a1f6-4ba2cf253944))
		- **[C# A Player's Guide 5th Edition](https://www.amazon.com/dp/0985580151)**
		  A very engaging book for beginner's to C#. Very modern, making use of [[C#]] 10 and .NET 6 with tons of projects and challenges to actually make use of your coding skills. Highly recommended. Buy whatever the newest edition is (regardless of what this says), as we always stay up to date.
		- **[CSharp Fundamentals for Absolute Beginners | Channel 9](https://channel9.msdn.com/Series/CSharp-Fundamentals-for-Absolute-Beginners)**
		  A video series covering the absolute basics of programming, C# style. Also walks you through installing an IDE (a program that makes it much easier for you to write code).
		- **[Learn C# in Y minutes](https://learnxinyminutes.com/docs/csharp/)**
		  Reference sheet presented through a massive C# file. Again, this is more useful for those who already understand how to program and just need a quick reference for what the syntax is.