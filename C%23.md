- [C#](https://learn.microsoft.com/en-us/dotnet/csharp/)
- Pros/Cons
  collapsed:: true
	- Pros
		- There are version of [PHP](http://www.peachpie.io/) and [Python](https://github.com/Microsoft/Pyjion 108) running on top of .NET runtime.
		- code in interpreted languages gets faster in later versions of the runtime (.NET CLR or Java VM), without you doing anything. And there are a lot of useful optimizations JIT compilers can do that are simply impossible in languages with pointers
		  collapsed:: true
			- code in interpreted languages gets faster in later versions of the runtime</quote> As code compiled by a better version of the compiler will also get faster.
		- is pure OOP, forcing rules in your code that helps keep your code more readable, 'maintainable' and execution is more stable. Productivity rate surpasses C++ by at least 10%, the best C++ programmer could be an even better C# programmer.
		- Applications that require the benefits of the .NET framework in the language it was designed for.
		- It has native garbage-collection, unlike C++ which has
		- Easier and thus faster to code in
			- The syntax of C# is certainly less demanding (and error prone) than C/C++ and has, for the initiated programmer, a shallower learning curve.
			- Rapid client application development.
		- More quality of life features
		  collapsed:: true
			- C# prevents you from doing certain things that C/C++ allows you to, but some of these things were things that you would never want to do anyways and were probably some mistake that was going to lead to some really weird behavior and you not knowing why, like assigning in a conditional field, or having `5;` as an expression. That line of code isn’t “doing” anything, so C# won’t let that run because it was probably a mistake.
		- ((65a0724a-10ff-44ea-aa19-9d7f50f9cca8))
		- Generics
	- Cons
		- Developer Studio runs on Windows
		- Desktop applications created with Visual Studio don't work equally as well on Linux.
	- Upstream/Downstream Pros/Cons
		- ((659d38ce-a277-4a58-8530-b3527f40432a)) : ((661b9aa8-8199-440a-958a-1de5eb489a25))
	- Comparisons
		- With ((646349e5-6faa-4638-a681-e2218087d789))
- Documentation
	- Cheatsheet
	  collapsed:: true
		- To ingrain
		  id:: 650bfd83-b79c-4eb6-aeb3-2578fd73df32
			- ((650c05e4-ec3c-4711-857d-7e22f4e53d97)) like in [[JavaScript]]
			-
			- ((643c49e4-393a-4dc9-ae4d-1cb5f1a05481))
			- Type conversion
				- ((643bdb01-3ba2-4ece-aaa8-da84dcab4a64))
		- Categories
			- Syntax
			  id:: 6439ddbe-c1d0-4643-adf2-68cca691b9bb
				- Assorted
					- `dotnet run` = compile and execute program
					- `using` = equivalent to `import` in [[JavaScript]]
				- [C# cheat sheet](https://programming-idioms.org/cheatsheet/Csharp)
				  collapsed:: true
					- Functions
						- [Create a function](https://programming-idioms.org/idiom/4/create-a-function) - returns the square of an integer
							- ```c#
							  int Square(int x)
							  {
							      return x * x;
							  }
							  ```
							- ```c#
							  int Square(int x) => (int)Math.Pow(x, 2);
							  ```
					- [Iterate over list values](https://programming-idioms.org/idiom/6/iterate-over-list-values)
						- ```c#
						  foreach (var x in items)
						  {
						      DoSomething(x);
						  }
						  ```
				- [Learn C# in Y Minutes](https://learnxinyminutes.com/docs/csharp/)
				  collapsed:: true
					- Strings are immutable: you can't do `fooString[1] = 'X';`
					- Arrays
						- // The array size must be decided upon declaration
						- The format for declaring an array is
						  `<datatype>[] <var name> = new <datatype>[<array size>];`
						- Example: 
						  ```c#
						  int[] intArray = new int[10];
						  ```
						- Another way to declare & initialize an array
							- `int[] y = { 9000, 1000, 1337 };`
				- ((643a7179-82c1-4452-a66f-53c389bfac13))
				  collapsed:: true
					- `Console.WriteLine("Hello World!");` = Print "Hello World!"
					- `string aFriend = "Bill";` = Declare a string
					- String interpolation
						- Concatenation
						  ```c#
						  Console.WriteLine("Hello " + aFriend);
						  ```
						- Interpolation
						  ```c#
						  string firstFriend = "Maria";
						  string secondFriend = "Sage";
						  Console.WriteLine($"My friends are {firstFriend} and {secondFriend}");
						  ```
				- Related: ((642714a5-1d61-4067-a9fd-87d003c13a07))
			- Object-Oriented Programming
			  id:: 661cd020-2e0e-4485-b230-0fc196788cac
			  collapsed:: true
				- Related:
					- ((63fe5472-f72c-4a29-9067-7d7edc128d06))
					- ((65a037a9-8b1c-41be-b6f0-1ff1aa61a4ed))
	- Learning resources sorted by priority
	  id:: 64400aaf-af93-4739-a73b-97b213f053d6
		- [Learn C# | Codecademy](https://www.codecademy.com/learn/learn-c-sharp)
		  id:: 6582dba8-09ee-4742-808a-316fe660bca3
		  collapsed:: true
			- Meta
				- [FAQ: Hello World - What is C#? - C# FAQ - Codecademy Forums](https://discuss.codecademy.com/t/408358)
				- [FAQ: Hello World - What is C#? - C# FAQ - Codecademy Forums](https://discuss.codecademy.com/t/faq-hello-world-what-is-c/408358)
			- # Syllabus
				- # Hello World
				  collapsed:: true
				  [Cheatsheet](https://www.codecademy.com/learn/learn-c-sharp/modules/csharp-hello-world/cheatsheet) / ![codecademy c# cheatsheet.pdf](../assets/codecademy_c#_cheatsheet_1704998904655_0.pdf)
					- ## Hello World
						- Overview of C#
							- ((6529189e-d194-44fe-8d48-13348d318139)) can be used to build websites, ((629ccb25-3e20-493c-8668-a254e47e8b40)) to make games. C# is often used to make mobile apps, augmented reality and virtual reality, backend services and desktop applications
							- ((659d38ce-a277-4a58-8530-b3527f40432a)) apps can be written in C#
						- Basic template
							- ```c#
							  using System;
							  
							  namespace HelloWorld
							  {
							    class Program
							    {
							      static void Main()
							      {
							        Console.WriteLine("Hello World!");    
							       }
							    }
							  }
							  ```
						- `Console.WriteLine("Hello World!");`
						  id:: 65a0388d-ddc2-444d-88bf-36737f571ca7
						  Print text to the console
							- Related: ((642714a5-1d61-4067-a9fd-87d003c13a07)) : ((661ae022-4f35-4905-821b-946824c60399))
						- `Console.ReadLine()`
						  Captures text a user types next in the console
							- Example
								- ```c#
								  Console.WriteLine("How old are you?");
								  string input = Console.ReadLine();
								  Console.WriteLine($"You are {input} years old!");
								  ```
								- ```c#
								  Console.WriteLine("Press Enter to begin...");
								  Console.ReadLine();
								  Console.WriteLine("Let's get started!");
								  ```
						- `dotnet run`
						  Execute a C# program
						- ((661a4b2a-f191-4e53-87fe-3fa01c099613))
						- Code ((661a4437-f7d7-41c6-96cb-3942ea456ba4))
					- ## Go Off-Platform with C#
						- `mono --version` = check Mono version
						- Install [MonoDevelop](https://www.monodevelop.com/download/#fndtn-download-lin) if it's not present
							- `sudo apt-get install monodevelop`
				- # ((661a4437-8543-448f-9f90-744e8909acdc)) and ((661a4437-eddf-41d9-bea4-620702a24cd1))
				  collapsed:: true
				  [Cheatsheet](https://www.codecademy.com/learn/learn-c-sharp/modules/learn-csharp-module-ii/cheatsheet)
					- ## ((661a4437-8543-448f-9f90-744e8909acdc)) and ((661a4437-eddf-41d9-bea4-620702a24cd1))
					  collapsed:: true
						- ### Introduction to Data Types and Variables in C#
							- C# is *strongly-typed*, so it requires us to specify the data types that we’re using
							- It is also *statically-typed*, which means it will check that we used the correct types before the program even runs.
							- Both language features are important because they help write scalable code with fewer bugs.
							- It is ((63fe5472-f72c-4a29-9067-7d7edc128d06))
						- ### C# ((661a4437-8543-448f-9f90-744e8909acdc))
							- [Built-in data types](https://www.codecademy.com/resources/docs/c-sharp/data-types) cheatsheet
							  id:: 65a050bc-9dbd-4237-b538-f00ea88fa036
								- ![image.png](../assets/image_1705004403546_0.png){:height 632, :width 876}
							- Each data type has different:
								- How it can be stored
								- What operations we can perform with it
								- Different ((661a4437-293b-4dd4-8109-f9ad9e491fc6)) it can be used with
							- Strongly-typed means the programmer must *specify the data type of every value and expression*.
							- While it means writing more code, using types has long term benefits like built-in documentation and increased readability.
						- ### Creating ((661a4437-eddf-41d9-bea4-620702a24cd1)) with Types
						- ### Handling Errors
							- If you forget the specify the type for a variable named `randomData`:
								- `The name 'randomData' does not exist in the current context [CS0103:] `
							- If you use the wrong type definition e.g. `int` when it's supposed to be a `double`:
								- `Cannot implicitly convert type 'double' to 'int'. An explicit conversion exists (are you missing a cast?)`
							- ((6320936d-0261-4020-95d8-3cb6163e9d66)) should be used for naming variables
							- There are [reserved keywords](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/) that we can't use as a variable name e.g. `string`, `lock`
						- ### Converting ((661a4437-8543-448f-9f90-744e8909acdc))
							- **implicit conversion:** happens automatically if no data will be lost in the conversion. That’s why it’s possible to convert an `int` (which can hold less data) to a `double` (which can hold more), but not the other way around.
								- This doesn't work:
								  ```c#
								  double myDouble = 3.2;
								  
								  // Round myDouble to the nearest whole number
								  int myInt = myDouble;
								  ```
							- **explicit conversion:** requires a cast operator to convert a data type into another one. So if we do want to convert a double to an int, we could use the operator `(int)`.
								- This does work:
								  ```c#
								  double myDouble = 3.2;
								  
								  // Round myDouble to the nearest whole number
								  int myInt = (int)myDouble;
								  ```
							- Additionally there are built-in methods for converting data types
								- For most data types, there is a `Convert.ToX()` method, like `Convert.ToString()` and `Convert.ToDouble()`.
								- For a full list of `Convert` class built-in methods, check out the [Microsoft Documentation](https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2).
								- Look at [this article on converting strings to int](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/how-to-convert-a-string-to-a-number). It lists a few of the methods in the Convert class, including: `Convert.ToInt32()`. This method takes a string and outputs an integer.
								- Example
									- Converting `string` to `int`:
									  ```c#
									  Console.Write("Enter your favorite number!: ");
									  
									  // This doesn't work
									  int faveNumber = (int)Console.ReadLine();
									  
									  // This does work
									  int faveNumber = Convert.ToInt32(Console.ReadLine());
									  ```
					- ## Working with Numbers
					  collapsed:: true
						- ### Introduction to Working with Numbers
							- In this lesson, we’ll look at a few of the most commonly used numerical ((661a4437-8543-448f-9f90-744e8909acdc)) in C#. By the end of this lesson, you will be able to manipulate numerical data and write programs that perform calculations using arithmetic ((661a4437-b99e-4eee-b817-8934c7a5b486)) and built-in ((661a4437-293b-4dd4-8109-f9ad9e491fc6)).
						- ### Numerical Data Types
						  collapsed:: true
							- When choosing a numerical data type think about:
								- Do I need a whole number or do I need something that will represent a fraction, or a decimal?
								- If I want to use a decimal, how precise do I need to be? Depending on your application, whether it’s a hobby project or building a B2B financial services software, you’ll need a different data type.
								- Is performance a factor? Most times, choosing a data type that takes up less memory will result in faster applications.
							- `int`
								- Whole integer e.g. `4`, `100`
								- Useful for counting things
								- Example
									- ```c#
									  int variableName = 7;
									  ```
							- `double` and `decimal`
								- These values are useful for anything that requires more precision than a whole number, like measuring the precise location of an object in 3D space.
								- A `double` is usually the best choice of the three because it is more precise than a `float`, but faster to process than a `decimal`. However, make sure to use a decimal for financial applications, since it is the most precise.
								- To define a variable with the type `double`, you would write it as follows:
									- ```c#
									  double variableName = 39.76876;
									  ```
								- To define a variable with the type `decimal`, you would write it as follows:
									- ```c#
									  decimal variableName = 489872.76m;
									  ```
									- Don’t forget the `m` character after the number! This character tells C# that we’re defining a decimal and not a double.
						- ### ((661a4c49-43de-4e09-84da-a6032501f710))
						  collapsed:: true
							- If you use two of the same data type, the output will always be that data type(?)
								- If you combine an `int` with an `int`, it'll return an `int` even if the answer could have decimal points
									- ```c#
									  Console.WriteLine(5 / 3);
									  // prints 1
									  ```
							- If you combine two different data types the answer will be in the larger data size type(?)
								- If you combine an `int` with a `double`, the answer will be a `double`
									- ```c#
									  Console.WriteLine(5 / 3.0);
									  // prints 1.66667
									  ```
							- C# follows [the order of operations](https://en.wikipedia.org/wiki/Order_of_operations)
								- C# follows a set of rules to determine which operations to perform first.
									- ```c#
									  int answer = 1 + 2 * 3;
									  Console.Write(answer);
									  - // prints 7, not 9
									  ```
								- It’s good practice to use parentheses to explicitly tell C# how to calculate these expressions.
								- Notice in the following example, even if the addition symbol appears like it should come first, the multiplication operation will happen first.
									- ```c#
									  int answer = 8 + (9 * 3);
									  Console.Write(answer);
									  - // prints 35
									  ```
						- ### Operator Shortcuts
							- ((661a4c62-bdad-4e27-9b1f-0b3abaa32714))
							- ((661a4d14-50c3-4332-bf6f-25992ce1d4cd))
						- ### Modulo
							- ((661a4c49-5fc2-4c7c-87ba-ee59c4bab764))
						- ### Built-in Methods
							- ((661a4437-bd17-4036-9849-db5b0c0d9f77))
							- Combining two methods:
								- ```c#
								  int numberOne = 12932;
								  // find the square root of numberOne and round the answer down so it doesn’t have a decimal
								  double numberOneSqrt = Math.Floor(Math.Sqrt(numberOne));
								  ```
						- ### Using Documentation
						- ### Review
						- [Learning Resources]
							- ((643a7f7d-e036-4029-9342-498f14235cdb))
					- ## Working with Text
					  collapsed:: true
						- ### ((661a4437-6b1e-415e-a5c4-4f1f32571d9c)) Concatenation
						  id:: 661adf2b-590a-4e33-8417-bca20d700800
							- Examples
								- ```c#
								  string yourFaveMusician = "David Bowie";
								  string myFaveMusician = "Solange";
								  
								  Console.WriteLine("Your favorite musician is " + yourFaveMusician + " and mine is " + myFaveMusician + ".");
								  ```
								- It can implicitly convert `int` into `string`s
									- ```c#
									  int num = 1;
									  string population = "all";
									  
									  Console.WriteLine(num + " ring to rule them " + population);
									  // 1 ring to rule them all
									  ```
						- ### ((661a4b2a-f191-4e53-87fe-3fa01c099613))
						- ### Get Info About ((661a4437-6b1e-415e-a5c4-4f1f32571d9c))
							- ((661a4437-6b1e-415e-a5c4-4f1f32571d9c)) : ((661ae9a6-dd5b-4411-90ec-48f6c5aa545f))
						- ### Get Parts of ((661a4437-6b1e-415e-a5c4-4f1f32571d9c))
							- ((6463496c-e95c-46b3-9a6e-2d76203ed4fd))
							- Bracket Notation
							  id:: 661af024-b194-422b-b1e5-0a1e48cb403f
								- Bracket notation is a style of syntax that uses brackets `[]` and an integer value to identify a particular value in a collection. In this case, we can use it to find a specific character in a string.
								- ```c#
								  string plantName = "Cactaceae, Cactus";
								  int charPosition = plantName.IndexOf("u"); // returns 15
								  char u = plantName[charPosition]; // returns u
								  ```
								- Similar to the example above, we first use `.IndexOf()` to grab the character position, which in this case is 15. We then take the string value and append it with a set of brackets `[]` and place the `charPosition` value inside the brackets.
						- ### Manipulate ((661a4437-6b1e-415e-a5c4-4f1f32571d9c))
					- ## Mad Libs
					- ## Money Maker
				- # Logic and ((661a4437-e612-405b-b4fc-589f868546e0))
				  collapsed:: true
				  [Cheatsheet](https://www.codecademy.com/learn/learn-c-sharp/modules/learn-csharp-logic-conditionals/cheatsheet)
					- ## Understanding Logic in C#
					  collapsed:: true
						- ### Boolean ((661a4437-8543-448f-9f90-744e8909acdc))
							- Syntax
								- ```c#
								  bool variableName = true;
								  ```
						- ### ((661a4c49-5af5-4cc4-b1b0-2339ab8fa2b1))
						- ### Truth Table
						  id:: 661af6a9-f2c6-47ea-ac52-675a0be104e6
							- ![image.png](../assets/image_1713044036056_0.png)
						- ### ((661a4c49-eb41-4638-8d3e-455ea8464230))
					- ## ((661a4437-e612-405b-b4fc-589f868546e0)) Statements
					- ## Logic and Conditionals Quiz
					- ## Password Checker
					- ## Choose Your Own Adventure
				- # ((661a4437-293b-4dd4-8109-f9ad9e491fc6))
				  collapsed:: true
					- ## Method Calls and Input
					  collapsed:: true
						- Every time an application is started, the `Main()` method is called.
							- ```c#
							  using System;
							  
							  namespace MethodCallsAndInput
							  {
							    class Program
							    {
							      static void Main(string[] args)
							      {
							      }
							    }
							  }
							  ```
						- ### Define Parameters
							- ```c#
							  // One parameter
							  static void YourMethodName(string identity)
							  {
							    Console.WriteLine(identity);
							  }
							  // Two parameters
							  static void YourMethodName(string identity, int age)
							  {
							    Console.WriteLine($"{identity} is {age} years old.");
							  }
							  // Calling the function
							  YourMethodName("Yoda", 900);
							  ```
						- ### Optional Parameters
						  id:: 661c63bd-4825-4f50-bd85-a0644c546a2b
							- Add `=` and a default value (e.g. `"."`)
								- ```c#
								  static void Main(string[] args)
								  {
								    YourMethodName("I'm hungry", "!"); // prints "I'm hungry!"
								    YourMethodName("I'm hungry");  // prints "I'm hungry."
								  }
								  
								  static void YourMethodName(string message, string punctuation = ".")
								  {
								    Console.WriteLine(message + punctuation);
								  }
								  ```
						- ### Named Arguments
							- Say your method has lots of optional parameters, but you only want to specify one when you call it. Or you just want to be able to differentiate between similar arguments.
							- Examples
								- ```c#
								  // your method has five optional parameters
								  static void YourMethodName(int a = 0, int b = 0, int c = 0, int d = 0, int e = 0) {...}
								  // Refer to the parameter by it's name instead
								  YourMethodName(d: 4);
								  // With named arguments, you can list them in any order:
								  YourMethodName(d: 4, b: 1, a: 2);
								  // You can also mix named arguments with positional arguments, but positional arguments MUST come before named arguments:
								  YourMethodName(2, 1, d: 4) // a is 2, b is 1, d is 4
								  ```
						- ### Method Overloading
						  id:: 661c63bd-6ce1-4b85-b23e-d4e24434ea00
							- E.g. ((6463496c-441e-4d76-9967-68e280a31604)) has 8 different versions. This is called method overloading, and each version is called an overload.
							- Overloads are different in:
								- Different parameter types
								- Different number of parameters
							- his is useful if you want the same method to have different behavior based on its inputs.
							- In *method overloading*, multiple [methods](https://www.codecademy.com/resources/docs/c-sharp/methods) can have the same name, as long as they have different method *signatures*.
							- ### Examples
								- Example built-in method with multiple overloads: `Math.Round(Double, Int32)` and `Math.Round(Double)`.
								- ```c#
								  static void Main(string[] args)
								  {
								    NamePets("Melon", "Peach");
								    NamePets("Melon", "Peach", "Biscuit");
								    NamePets();
								  }
								  static void NamePets(string pet1, string pet2)
								  {
								    Console.WriteLine($"Your pets {pet1} and {pet2} will be joining your voyage across space!");
								  }
								  static void NamePets(string pet1, string pet2, string pet3)
								  {
								    Console.WriteLine($"Your pets {pet1}, {pet2} and {pet3} will be joining your voyage across space!");
								  }
								  static void NamePets()
								  {
								    Console.WriteLine("Aw, you have no spacefaring pets :(");
								  }
								  // Your pets Melon and Peach will be joining your voyage across space!
								  // Your pets Melon, Peach and Biscuit will be joining your voyage across space!
								  // Aw, you have no spacefaring pets :(
								  ```
						- A method *signature* is a method’s name and parameter types in order.
					- ## Method Output
					  collapsed:: true
						- That first line of the method is called a *method declaration*
							- Generally, the method declaration is a combination of details including:  the access modifiers, return type, method name, and parameter types. This lesson will not cover access modifiers, like `static`, so that we can focus on the return type, like `string`.
						- ### Return
							- In the method declaration you change `void` to the `type` of a variable and the `VariableName`
							- Examples
								- ```c#
								  static string DecoratePlanet(string PlanetName)
								  {
								    return $"*.*.* Welcome to {PlanetName} *.*.*";
								  }
								  ```
								- ```c#
								  static string Yell(string phrase) 
								  {
								    return phrase.ToUpper();
								  }
								  
								  public static void Main()
								  {
								    string output = Yell("who's there?");
								    Console.WriteLine(output); // Prints WHO'S THERE?
								  }
								  ```
						- ### Return Errors
							- Common errors
								- This error means you must state a return type before the method name (e.g. `void`, `string`):
									- ```
									  error CS1520: Method must have a return type
									  ```
								- This error means that your method doesn’t return a value, when it should:
									- ```
									  error CS0161: [MethodName]: not all code paths return a value
									  ```
								- In some cases, this error means that your method returns a `string` when it should be an `int` (this one can be caused by a lot of things outside of methods):
									- ```
									  error CS0029: Cannot implicitly convert type 'string' to 'int'
									  ```
						- ### Out
							- A method can only *return* one value, but sometimes you need to output two pieces of information. Calling a method that uses an `out` parameter is one way to return multiple values.
							- Basically you add an `out` argument and assign to a variable you've created to store the result
							- **Examples**
								- ```c#
								  static void Main(string[] args)
								  {
								    string ageAsString = "102";
								    bool outcome;
								    outcome = Int32.TryParse(ageAsString, out int ageAsInt);
								    Console.WriteLine(outcome); // True
								    Console.WriteLine(ageAsInt); // 102
								  }
								  ```
								- For example, the `Int32.TryParse()` method tries to parse its input as an integer. If it can properly parse the input, the method returns `true` and sets its `out` variable to the new value.  If it cannot properly parse the input, the method returns `false` and sets the `out` variable to 0.
								  collapsed:: true
									- This is what the method’s signature looks like:
										- ```c#
										  public static bool TryParse (string s, out int result);
										  ```
									- The method returns a `boolean` and accepts a `string` and a variable that has been declared of type `int` as input.
									- Here’s how `Int32.TryParse()` and the `out` parameter are used:
										- ```c#
										  int number;
										  bool success = Int32.TryParse("10602", out number); 
										  // number is 10602 and success is true
										  int number2;
										  bool success2 = Int32.TryParse(" !!! ", out number2);
										  // number2 is 0 and success2 is false
										  ```
									- The second parameter is labeled `out`, which means that it must be assigned a value within the method.
									- For a shortcut, you can declare the `int` variable within the method call:
										- ```c#
										  bool success = Int32.TryParse("10602", out int number);
										  ```
						- ### Using Out
							- Prefix a parameter with `out` to use this. Also use `out` when calling the method too
							- **Examples**
								- ```c#
								  static string Yell(string phrase, out bool wasYellCalled)
								  {
								    wasYellCalled = true;
								    return phrase.ToUpper();
								  }
								  // Calling
								  Yell("hello", out bool YetiCall);
								  ```
								- ```c#
								  static void Main(string[] args)
								  {
								    string statement = "GARRRR";
								    Whisper(statement, out bool marker);
								  }
								  static string Whisper(string test1, out bool test2)
								  {
								    test2 = true;
								    return test1.ToLower();
								  }
								  ```
						- ### Out Errors
							- Common errors:
								- This error means that the `out` parameter needs to be assigned a value within the method:
									- ```
									  error CS0177: The out parameter 'success' must be assigned to before control leaves the current method
									  ```
								- This error means you called a method that expects an ‘out’ parameter but you didn’t use the `out` keyword when calling it:
									- ```
									  error CS1620: Argument 2 must be passed with the 'out' keyword
									  ```
					- ## Architect Arithmetic
					- ## Exquisite Corpse
					- ## Alternate Expressions
					  collapsed:: true
						- ((661bb3c7-5ad8-4244-b3fe-96209e36c02e)) and ((661bb3e8-8d38-4b7a-b337-d170a060dcfa)) are more concise ways of defining methods
						- ### Expression-bodied Definitions
						  id:: 661bb3c7-5ad8-4244-b3fe-96209e36c02e
							- i,e, they contain just one expression
							- **Examples**
								- ```c#
								  // Normal way
								  bool IsEven(int num)
								  {
								    return num % 2 == 0;
								  }
								  
								  // Expression-bodied Definitions version
								  bool isEven(int num) => num % 2 == 0;
								  ```
								- ```c#
								  void Shout(string x) => Console.WriteLine(x.ToUpper());
								  ```
							- Related: [[JavaScript]] : ((636d5df2-5117-4f9e-8113-83bbb5eff6c1))
						- ### Methods as Arguments
						  id:: 661bb3e3-3441-4b26-a257-571dd3848718
							- We can use methods like variables in arguments when calling another method
							- **Examples**
								- ```c#
								  // IsEven is a variable representing the method IsEven()
								  bool hasEvenNumber = Array.Exists(numbers, IsEven);
								  ```
								- ((661bd669-105a-4d67-89c5-96be827aad87)) takes an array and a method as arguments
									- `Array.Find()` calls the method on each element of the array and returns the first element for which the method returns `true`.
									- An array `adjectives` and method `IsLong()` are defined for you. Call `Array.Find()` with these two arguments to find the first element in `adjectives` that is “long”.
									- ```c#
									  public static bool IsLong(string word) => word.Length > 8;
									  
									  static void Main(string[] args)
									  {
									    // Array to be used as first argument
									    string[] adjectives = {"rocky", "mountainous", "cosmic", "extraterrestrial"};
									    // Call Array.Find() and pass in the array and method as arguments
									    string firstLongAdjective = Array.Find(adjectives, IsLong);
									    Console.WriteLine($"The first long word is: {firstLongAdjective}.");
									  }
									  ```
						- ### Lambda Expressions
						  id:: 661bb3e8-8d38-4b7a-b337-d170a060dcfa
							- great for situations when you need to pass a ((661bb3e3-3441-4b26-a257-571dd3848718))
							- *anonymous method:* it has no name
							- **Syntax**
								- ```c#
								  // One expression
								  (input-parameters) => expression
								  
								  // More than one expression
								  (input-parameters) => { statement; } // can be multi-line
								  ```
							- **Examples**
								- ```c#
								  int[] numbers = {1, 3, 5, 6, 7, 8};
								  
								  // Normal methods as arguments
								  public static bool IsEven(int num)
								  {
								    return num % 2 == 0;
								  }
								  bool hasEvenNumber = Array.Exists(numbers, IsEven);
								  
								  // Lambda expression
								  bool hasEvenNumber = Array.Exists(numbers, (int num) => num % 2 == 0 );
								  ```
								- ```c#
								  bool makesContact = Array.Exists(spaceRocks, (string s) => s == "meteorite");
								  ```
								- ```c#
								  bool hasBigDozen = Array.Exists(numbers, (int num) => {
								    bool isDozenMultiple = num % 12 == 0;
								    bool greaterThan20 = num > 20;
								    return isDozenMultiple && greaterThan20;
								  });
								  ```
						- ### Shorter Lambda Expressions
							- We can remove the parameter type if it can be inferred
							- We can remove the parentheses if there is one parameter
							- **Example**
								- ```c#
								  // Initial
								  bool hasEvenNumbers = Array.Exists(numbers, (int num) => num % 2 == 0 );
								  
								  // After
								  bool hasEvenNumbers = Array.Exists(numbers, num => num % 2 == 0 );
								  ```
									- Can `int` type from `num`
										- It’s great to be explicit like this to avoid errors, but some developers wouldn’t include `int`. To them, it’s obvious! Here’s their reasoning:
											- The modulo operator (`%`) is only used with numbers, so `num` must be a number
											- The result of the operation `num % 2` is compared to the integer `0`. We can only compare similar types, so num must also be an integer!
									- Can remove `(``)` since there's just one parameter
				- # ((661a4437-86cf-49d0-b482-e5613fa5ea99)) and ((661a4437-e7f1-4e63-8409-f8b7e61c7a4b))
				  collapsed:: true
					- ## Arrays
					  collapsed:: true
						- ### Array Length
							- ```c#
							  int[] plantHeights = { 3, 4, 6 };
							  
							  // arrayLength will be 3
							  int arrayLength = plantHeights.Length 
							  ```
						- ### Accessing Array Items
							- ((661af024-b194-422b-b1e5-0a1e48cb403f)) also applicable for accessing array items
							- Note: `[-1]` to access the last item doesn't seem to work unlike other languages
						- ### Built-In Methods
							- ((661a5775-b300-4924-bf9e-287ed7cb3405))
								- e.g. ((661bd669-105a-4d67-89c5-96be827aad87)). ((661bf369-6575-4555-861f-f2b02c78fccc))
						- ### Documentation Hunt
					- ## Loops
					- ## Caesar Cipher
					- ## True or False?
				- # ((661c63bd-dfef-42bc-896f-114bb592d4e3)) and Objects
				  id:: 65a037a9-8b1c-41be-b6f0-1ff1aa61a4ed
					- ## Basic Classes and Objects
					  collapsed:: true
						- ### Making Classes
							- Steps
								- Define a class
								- Add members, like properties and methods, to a class
								- Customize access to those members using `public` and `private`
								- Create objects from a class
							- When you use in-built data types like `string` to make a new variable you're making an instance of that class
							- Dot notation can be used to edit `fields` of a class instance
								- ```c#
								  Forest f = new Forest();
								  f.name = "Amazon";
								  Console.WriteLine(f.name); // Prints "Amazon"
								  
								  Forest f2 = new Forest();
								  f2.name = "Congo";
								  Console.WriteLine(f2.name); // Prints "Congo"
								  ```
						- ### Constructors
						  collapsed:: true
							- Special type of method that can update the values on a newly created class instance (i.e. whenever it's instantiated using `new`)
							- Traits
								- No `return type` listed
								- Method name is the name of it's enclosing class
								- If you don't define a constructor, a parameterless constructor is automatically created
								- ((661c63bd-dfef-42bc-896f-114bb592d4e3)) themselves can't have parameters, so you use the constructor to add parameters instead
							- Examples
								- ```c#
								  class Forest 
								  {
								    public Forest()
								    {
								    }
								  }
								  ```
								- A constructor which sets values for fields:
								  ```c#
								  class Forest
								  {
								    public int Area;
								   
								    public Forest(int area)
								    {
								      Area = area;
								    }
								  }
								  ```
								- You can have parameters on a constructor, which allows you to set their properties upon object instantiation:
									- ```c#
									  class Forest
									  {
									    public Forest (string name, string biome)
									    {
									      Name = name;
									      Biome = biome;
									      Age = 0;
									    }
									  
									    public string Name
									    { get; set; }
									  
									    public string Biome
									    { get; set; }
									  }
									  ```
						- ### `this`
						  collapsed:: true
							- Useful for
								- Being explicit that you're referring to the current instance of a class
								- Preventing a conflict if you happen to name a constructor parameter and a class property the same thing
									- ```c#
									  class Class1
									  {
									    public Class1(string Name)
									    {
									      this.Name = Name;
									    }
									    public string Name { get; set; }
									  }
									  
									  ```
								- Easier to read, plus it can help avoid mistakes
							- ```c#
							  class Forest
							  {
							    public int Area
							    { /* property omitted */ }
							   
							    public Forest(int area)
							    {
							      // Previously was `Area = area`
							      this.Area = area;
							    }
							  }
							  ```
								- `this.Area = area` means “when this constructor is used to make a new instance, use the argument `area` to set the value of this new instance’s `Area` field”.
							- [c# - When NOT TO USE 'this' keyword? - Stack Overflow](https://stackoverflow.com/questions/2841807/when-not-to-use-this-keyword)
							-
						- ### Overloading Constructors
						  collapsed:: true
							- Just like normal ((661c63bd-6ce1-4b85-b23e-d4e24434ea00)), this method can overloaded too
							- Minimising duplicated code
								- ((661ee254-d4ba-417b-8a52-1c0f6862a65a)) has both constructors containing `this.Area = area`
								- Later on, if we need to adjust the constructor, we’ll need to find every copy of the code and make the exact same change. That means more work and chances for errors.
								- Either:
									- Use default arguments (AKA ((661c63bd-4825-4f50-bd85-a0644c546a2b)) )
										- This is useful if you are using C# 4.0 or later (which is fairly common) and the only difference between constructors is default values.
										- ```c#
										  // = "Unknown"
										  public Forest(int area, string country = "Unknown")
										  {
										    this.Area = area;
										    this.Country = country;
										  }
										  ```
									- Use `: this()`
										- which refers to another constructor in the same class. This is useful for old C# programs (before 4.0) and when your second constructor has additional functionality. This example has an additional functionality of announcing the default value.
										- ```c#
										  public Forest(int area, string country)
										  { 
										    this.Area = area;
										    this.Country = country;
										  }
										  public Forest(int area) : this(area, "Unknown")
										  { 
										    Console.WriteLine("Country property not specified. Value defaulted to 'Unknown'.");
										  }
										  ```
										- Remember that `this.Area` refers to the current instance of a class. When we use `this()` like a method, it refers to another constructor in the current class. In this example, the second constructor calls `this()` — which refers to the first `Forest()` constructor — AND it prints information to the console.
										- Examples
											- ```c#
											  class Program {
											    public static void Main (string[] args) {
											      Player p = new Player();
											    }
											  }
											  
											  class Player
											  {
											    public Player(string name)
											    {
											      Console.WriteLine($"Player named: {name}");
											    }
											  
											    public Player() : this("n/a")
											    {}
											  }
											  // returns "Player named n/a"
											  ```
							- ### Examples
								- Basic example
								  id:: 661ee254-d4ba-417b-8a52-1c0f6862a65a
									- ```c#
									  public Forest(int area, string country)
									  { 
									    this.Area = area;
									    this.Country = country;
									   }
									  
									  public Forest(int area)
									  { 
									    this.Area = area;
									    this.Country = "Unknown";
									  }
									  
									  // Calling
									  Forest f = new Forest(800, "Hungary");
									  Forest f2 = new Forest(400);
									  ```
					- ## Static Members
					  id:: 65a071cd-e9ce-4128-9bfd-64b6a8bc4473
						- ### Introduction to Static
							- What if we needed to do something related to the type itself, not instances of that type? For example, where do we store the count of all `Forest` objects, or an explanation of forests in general?
							-
						- ### Static Fields and Properties
						- ### Static Methods
						- ### Static Constructors
						- ### ((661a564c-fa79-476f-9988-643fbc77ebf3))
						- ### Common Static Errors
						- ### Main()
					- ## The Object of Your Affection
					- Related: [[C#]] : ((661cd020-2e0e-4485-b230-0fc196788cac))
				- # Interfaces and Inheritance
					- ## Interfaces
					- ## Inheritance
					- ## Interfaces and Inheritance Quiz
					- ## App Interfaces
					- ## Supernatural Inheritance
				- # References
					- ## Reference Fundamentals
					- ## The Object Class
					- ## String, The Exception
					- ## References, Object, and String Quiz
					- ## Rover Control Center
				- # Lists and LINQ
					- ## Lists
					- ## LINQ
					  id:: 65a0724a-10ff-44ea-aa19-9d7f50f9cca8
					- ## Lists and LINQ Quiz
					- ## Programming Languages
		- [C# Docs | Codecademy](https://www.codecademy.com/resources/docs/c-sharp)
		  id:: 661a440b-7630-4354-a077-0953fd778ccb
		  collapsed:: true
			- [Arrays](https://www.codecademy.com/resources/docs/c-sharp/arrays)
			  id:: 661a4437-86cf-49d0-b482-e5613fa5ea99
			  collapsed:: true
				- An **array** is a data structure used in [C#](https://www.codecademy.com/resources/docs/c-sharp) to store a sequential collection of elements. Its size is immutable (cannot be changed after creation). The elements of an array are all of the same type, but it is possible to define a C# array that can hold elements of any type by specifying the type of the array as an object. In C#, all types directly or indirectly inherit from `Object`.
				- ## Syntax
					- There are several ways to create an array in C#:
					- ```c#
					  // Create a variable of type "type[]" without initializing it:
					  type[] arrayName;
					  - // Create the array variable and initialize it with an array of N items:
					  type[] arrayName = new type[N];
					  - // Create the array variable and intalize it by specifying the contents:
					  type[] arrayName = new type[] { value1, value2, value3, ... valueN };
					  - // Alternative way of creating the array and specifying the contents:
					  type[] arrayName = { value1, value2, value3, ... valueN };
					  ```
					- > **Note:** Arrays in C# have a set size, meaning the number of elements they hold cannot be changed once the array has been created.
				- ## Examples
					- Initialising an empty array
					  ```c#
					  // These arrays store ints, strings, and doubles, respectively
					  int[] x; 
					  string[] s; 
					  double[] d; 
					  // plantHeights will be equal to [0, 0, 0]
					  int[] plantHeights = new int[3]; 
					  ```
					- Initialising a full array
					  ```c#
					  // Either
					  int[] plantHeights = { 3, 4, 6 };
					  int[] plantHeights = new int[] { 3, 4, 6 };
					  ```
					- If you decide to define an array and then initialise it later (rather in one line like below) you **must** use the `new` keyword
						- ```c#
						  // Initial declaration
						  int[] plantHeights;
						  
						  // This works
						  plantHeights = new int[] { 3, 4, 6 };   
						  
						  // This will cause an error
						  // plantHeights = { 3, 4, 6 }; 
						  ```
					- Each element in an array is assigned a specific index starting at zero. To access or modify an element in the array, you refer to it by its index and operate on it accordingly.
						- ```c#
						  using System;
						  
						  public class Example
						  {
						    public static void Main(string[] args)
						    {
						      char[] vowels = {'a', 'e', 'i', 'o', 'u'};
						      //      indexes:  0    1    2    3    4
						  
						      Console.WriteLine(vowels[0]); // Output: a
						  
						      vowels[0] = 'r';
						  
						      Console.WriteLine(vowels[0]); // Output: r
						    }
						  }
						  ```
						- In the example above, an array of `char`s was initialized with all the vowels. The first element in the array at index 0 was printed. Then, the element at index 0 was modified by assigning it a new value of `'r'`. Then, the value at index 0 was printed again.
				- ## Array Methods
				  id:: 661a5775-b300-4924-bf9e-287ed7cb3405
					- Meta
						- Unlike string methods, the data structure seems to be provided as an argument here and not as the method prefix, which is always `Array`(?)
					- Arrays in C# are objects, not just contiguous blocks of memory as in C and C++. `Array` is the base type of all arrays, and any array can use the properties and methods of the `Array` object, a few of which are listed below:
					- [.Clear()](https://www.codecademy.com/resources/docs/c-sharp/arrays/clear)
					  : Clears the contents of an array, returning each element to its default value.
					- [.Copy()](https://www.codecademy.com/resources/docs/c-sharp/arrays/copy)
					  : Copies elements in an array within a certain range.
					- [.CopyTo()](https://www.codecademy.com/resources/docs/c-sharp/arrays/copyto)
					  : Copies the elements of an array to another array.
					- [.Length](https://www.codecademy.com/resources/docs/c-sharp/arrays/length)
					  : Returns the total number of elements in the array.
					- [.Resize()](https://www.codecademy.com/resources/docs/c-sharp/arrays/resize)
					  : Updates the size of an existing array.
					- [.Reverse()](https://www.codecademy.com/resources/docs/c-sharp/arrays/reverse)
					  : Reverses the sequence of a subset of the elements in a one-dimensional array.
					- [.Sort()](https://www.codecademy.com/resources/docs/c-sharp/arrays/sort)
					  collapsed:: true
					  Arranges the elements of an array in ascending or alphabetical order.
						- The **`.Sort()`** array method arranges the elements of an array in ascending or alphabetical order.
						- ## Syntax
							- ```c#
							  Array.Sort(myArray);
							  ```
							- `.Sort()` is a static method of the `Array` object. It takes one parameter, `myArray`, a one-dimensional zero-based array.
						- ## Example
							- The following example initializes the `letters` array with strings, then uses the `.Sort()` method to arrange the strings alphabetically. Finally, a `foreach` loop passes each element of the sorted array to the `Console.Write()` method to be printed:
							- ```c#
							  using System;
							  
							  public class Example
							  {
							    public static void Main(string[] args)
							    {
							      string[] letters = {"M", "Y", "E", "T", "P"};
							  
							      Array.Sort(letters);
							  
							      foreach (string letter in letters)
							      {
							        System.Console.Write(letter + " ");
							      }
							    }
							  }
							  ```
							- This example results in the following output:
							  `E M P T Y`
						- ## Codebyte Example
							- The following example is runnable and returns the numbers in the `numbers` array in ascending order:
							- ```c#
							  using System;
							  
							  public class Example
							  {
							    public static void Main(string[] args)
							    {
							      int[] numbers = {5895, 4810, 5364};
							  
							      Array.Sort(numbers);
							  
							      foreach (int number in numbers)
							      {
							        System.Console.Write(number + " ");
							      }
							    }
							  }
							  ```
					- Related: ((661bd63f-b51d-4fc9-97dc-caa71756b064)) : ((661bd645-c913-4608-9e3e-ecc7fcc391ac))
			- [Classes](https://www.codecademy.com/resources/docs/c-sharp/classes)
			  id:: 661c63bd-dfef-42bc-896f-114bb592d4e3
			  collapsed:: true
				- In C#, a **class** serves as a blueprint or template for creating objects. It plays a fundamental role in defining the structure, behavior, and attributes of these objects. A class can be thought of as a custom or user-defined data type that encapsulates both data (attributes) and the actions (methods) that are applied to that data.
				- ## Syntax for Declaring Classes
					- To declare a class in C#, use the `class` keyword, followed by the class name. Class names should follow C# naming conventions (typically using ((b2c095a3-5b8c-49e3-a10d-877a42e8cb78)) ). The class definition is enclosed within curly braces `{}`.
					- ```c#
					  public class MyClass {
					      // Fields, properties, and methods go here
					  }
					  ```
					- Ordering of class members
						- Example used in ((65a071cd-e9ce-4128-9bfd-64b6a8bc4473)):
							- Fields
							  logseq.order-list-type:: number
							- Constructors
							  logseq.order-list-type:: number
							- Properties
							  logseq.order-list-type:: number
							- Methods
							  logseq.order-list-type:: number
				- ## Making a Class Instance
				  AKA Instantiation / making an object
					- ```c#
					  MyClass test1 = new MyClass();
					  ```
				- ## Properties and Methods
					- `Properties`
					  id:: 661a564c-1c8a-480b-934d-89e397a69c6b
					  collapsed:: true
					  Properties are used to define the attributes or data members of a class. They are defined within the class and provide access to the class’s internal state. Another type of ((661cd3ff-3d1f-4951-ae7f-a3d3dace497c)).
						- This allows us to define the acceptable value for a particular field (e.g. no negative numbers for an `int` field)
						- It controls the access (getting and setting) to that field
						- It's made up of two methods:
							- `get()`
							  AKA getter | Called when the property is accessed
								- Variants
									- **Get-only** properties
									  collapsed:: true
										- For when you want programs to be able to get the value of a property, but not set it
										- Either:
											- don’t include a `set()` method
												- ```c#
												  public string Area
												  {
												    get { return area; }
												  }
												  ```
											- make the `set()` method private
											  (preferred approach because it allows for other methods in the class to set `Area`)
												- ```c#
												  public int Area
												  {
												    get { return area; }
												    private set { area = value; }  
												  }
												  ```
							- `set()`
							  AKA setter | Called when the property is assigned a value
								- Uses the keyword `value`, which represents the value we assign to the property
						- ## Syntax
							- ```c#
							  public int variable;
							  public int Variable
							  {
							  	get { return variable; }
							  	set { variable = value; }
							  }
							  ```
						- ## Examples
							- Automatic property - basic `Area` property without validation:
								- ```c#
								  public int Area
								  { get; set; }
								  ```
								- Non-automatic property - Basic `Area` property without validation:
								  collapsed:: true
								  i.e. longer syntax
									- ```c#
									  public int area;
									  public int Area
									  {
									  	get { return area; }
									  	set { area = value; }
									  }
									  ```
								- The `Area` property is associated with the `area` field.
									- It’s common to name a property with the title-cased version of its field’s name, e.g. `age` and `Age`, `name` and `Name`.
									- #+BEGIN_IMPORTANT
									  If you're using an `automatic property` then you don't need to create the lowercase ((661cd415-531d-4bf2-a4d9-707772648dca))
									  #+END_IMPORTANT
							- Basic `Area` property with validation (field only allows certain `value`s):
								- ```c#
								  public int area;
								  public int Area
								  {
								    get { return area; }
								    set 
								    { 
								      if (value < 0) { area = 0; }
								      else { area = value; }
								    }
								  }
								  ```
							- Calling the methods
							  i.e. call the ((b2c095a3-5b8c-49e3-a10d-877a42e8cb78)) property
								- ```c#
								  Forest f = new Forest();
								  f.Area = -1; // set() is called
								  Console.WriteLine(f.Area); // get() is called; prints -1
								  ```
					- `Methods`
					  id:: 661c63bd-1623-4524-a95f-a74de7bc5442
					  collapsed:: true
					  Methods are functions defined within the class that perform actions or operations. They can modify the class’s state or provide functionality. Another type of ((661cd3ff-3d1f-4951-ae7f-a3d3dace497c)).
						- ### Examples
							- ```c#
							  class Forest {
							    public int Area
							    { /* property body omitted */  }
							    public int IncreaseArea(int growth)
							    {
							      Area = Area + growth;
							      return Area;
							    }
							  }
							  // Calling the method
							  Forest f = new Forest();
							  int result = f.IncreaseArea(2);
							  Console.WriteLine(result); // Prints 2
							  ```
				- ## Access Modifiers
					- C# provides access modifiers to control the visibility and accessibility of class members. Common access modifiers include:
						- `public`
						  id:: 661a564c-5be3-4e99-8d5f-2372b14ec0ef
						  collapsed:: true
						  Members are accessible from any code.
							- Example
								- You can directly access the field, instead of following the property's validation
								  id:: 661eac5a-84c8-4f75-9b57-4851826310ad
									- ```c#
									  class AgeClass
									  {
									    public int age;
									    public int Age
									    {
									      get { return age; }
									      set { if (age < 0) { return 0; }
									           else { age = value; }
									          }
									    };
									  }
									  
									  f.Age = 32; // using property
									  f.age = -1; // using field
									  ```
						- `private`
						  id:: 661c63bd-aefc-4c2a-a361-1c878c84bed9
						  collapsed:: true
						  Members are only accessible within the class.
							- You can't do this: ((661eac5a-84c8-4f75-9b57-4851826310ad))
						- `protected`: Members are accessible within the class and derived classes.
						- `internal`: Members are accessible within the same assembly (a group of related classes in the same project).
						- `protected internal`: Members are accessible within the same assembly and derived classes.
						- `private protected`: Members are accessible only from derived classes within the current assembly. This access modifier has been available since C# 7.2 and later.
					- **Defaults:**
						- Classes are ((661a564c-5be3-4e99-8d5f-2372b14ec0ef))
						- Class members are ((661c63bd-aefc-4c2a-a361-1c878c84bed9))
					- It’s good practice to keep fields ((661c63bd-aefc-4c2a-a361-1c878c84bed9)) and make properties ((661a564c-5be3-4e99-8d5f-2372b14ec0ef))
					- "The convention taught in this section is that the protected, private fields are named lower case and the public property accessors are named the same but uppercase. Area should be a property."
				- ## Example
					- Here is a simple example featuring a class with properties and methods. By employing various access modifiers in C#, this example illustrates the use of public methods, such as `GetBalance`, to access private properties like the `current balance`. Meanwhile, it showcases that private methods like `PerformAudit()` are inaccessible from external code.
					  collapsed:: true
						- ```c#
						  using System;
						  
						  public class Program {
						      public static void Main() {
						          // Create a BankAccount instance with an initial balance of $1000.
						          BankAccount account = new BankAccount(1000);
						  
						          // Use the GetBalance method to get the current balance.
						          double currentBalance = account.GetBalance();
						          Console.WriteLine("Current Balance: $" + currentBalance);
						  
						          // Attempt to call the private method PerformAudit (won't compile).
						          // This will result in a compilation error because private methods cannot be accessed from outside the class.
						          // account.PerformAudit();
						      }
						  }
						  
						  public class BankAccount {
						      // Keeping track of current balance.
						      private double balance;
						  
						      // Constructor
						      public BankAccount(double initialAmount) {
						          balance = initialAmount;
						      }
						  
						      // Accessor method for balance.
						      public double GetBalance() {
						          return balance;
						      }
						  
						      // Private method to perform a transaction audit.
						      private void PerformAudit() {
						          // In a real application, this method would perform auditing.
						          // For this example, we'll just print a message.
						          Console.WriteLine("Audit complete.");
						      }
						  }
						  ```
				- ## Static Classes
				  id:: 661a564c-fa79-476f-9988-643fbc77ebf3
					- Static classes are defined using the `static` keyword and exclusively contain static members, such as methods, properties, and fields.
					- Unlike regular classes, static classes cannot be instantiated with the `new` keyword. Instead, their members are accessed using the class name itself. These classes are commonly used for utility functions or to group related functionality.
					- Related: ((65a071cd-e9ce-4128-9bfd-64b6a8bc4473))
				- ## Partial classes
					- Partial classes in C# enable class definitions to be split across multiple files. Each part of the class is defined in a separate file and combined at compile time to create a single class. This is valuable for scenarios where a class becomes too large or complex, or when multiple developers need to work on different aspects of the class simultaneously.
					- ![image.png](../assets/image_1713002332777_0.png)
					- In the image above, the `Calculator` class is depicted as a partial class structure, allowing independent development of class components. In the code below, the application’s entry point, the `Main` method, creates an instance of the `Calculator` class and utilizes its methods for addition and subtraction operations.
				- ## Glossary
					- Class members
					  id:: 661cd3ff-3d1f-4951-ae7f-a3d3dace497c
					  All types of data inside of a class.
					- **Fields**
					  id:: 661cd415-531d-4bf2-a4d9-707772648dca
					  collapsed:: true
					  A type of ((661cd3ff-3d1f-4951-ae7f-a3d3dace497c)), refers to non-methods e.g. `string` variables(?)
						- Best practice to name fields using all lowercase
						- ```c#
						  class Forest {
						    public string name;
						    public int trees;
						  }
						  ```
			- [Comments](https://www.codecademy.com/resources/docs/c-sharp/comments)
			  id:: 661a4437-f7d7-41c6-96cb-3942ea456ba4
			  collapsed:: true
				- A **comment** is a piece of text within a program that is not executed. It can be used to provide additional information to aid in understanding the code.
				- ## Single-line Comments
					- Two consecutive forward slashes (`//`) as
					- ```c#
					  // Comment goes here
					  executing code // Comment goes here
					  ```
				- ## Multi-line Comments
					- Multi-line comments begin with `/*` and end with `*/`. The compiler ignores any text in between.
					- ```c#
					  /*
					  This is all commented out.
					  None of it is going to run!
					  */
					  ```
				- ## Example
					- The following examples show various comment styles:
					- ```c#
					  // This line will denote a comment in C-sharp.
					  Console.WriteLine("Hello World!"); // This is a comment.
					  /*
					  This is a multi-line
					  comment.
					  */
					  ```
				- ## XML Comments
					- [XML](https://www.codecademy.com/resources/docs/general/xml) comments are structured comments that produce [API](https://www.codecademy.com/resources/docs/general/api) documentation. The C# compiler produces an XML file that contains structured data representing the comments. Other tools can process that XML output to create human-readable documentation in the form of web pages or PDF files, for example.
					- ### Syntax
						- The following is a single-line XML comment, which uses three forward slashes (`///`):
							- ```c#
							  /// XML Comment goes here
							  ```
						- Multi-line XML comments are similar to regular multi-line comments, except that an extra asterisk `*` is used in the opening:
							- ```c#
							  /**
							  XML Comments go here
							  */
							  ```
					- ### Example
						- XML tags embedded in XML comments are used to signal a specific functionality of the XML comment to the compiler. The `<summary>` tag in the following example describes a type or a member, in this case, the public class `MyClass`:
						- ```c#
						  /// <summary>
						  ///  This class performs an important function.
						  /// </summary>
						  public class MyClass {}
						  ```
			- [Conditionals](https://www.codecademy.com/resources/docs/c-sharp/conditionals)
			  id:: 661a4437-e612-405b-b4fc-589f868546e0
			  collapsed:: true
			  AKA ((650c0968-92a5-4d55-8e46-b80a22344a79))
				- In C#, **conditionals** compare inputs and return a boolean value indicating whether it evaluates to `true` or `false`.
				- Conditional statements include the `if`, `else` and `else if` statements. A shorthand for the `if`/`else` statement is the conditional or ternary operator.
				- ## If Statement
				  id:: 661a549e-b2a3-4af6-9591-b58c72e0c1f7
					- An `if` statement evaluates a condition that, when true, will run a code block that follows.
					- In the example below, three variables are declared and assigned values. Then, an `if` statement checks for a condition; if it evaluates to true, then the variable of boolean type will change:
						- ```c#
						  var input1 = 10;
						  var input2 = 10;
						  var output = false;
						  
						  if (input1 == input2) {
						    output = true; // Sets the output from false to true.
						  }
						  ```
					- If the code above returned `true`, the code block below will print a statement to the console:
						- ```c#
						  if (output == true) {
						    Console.WriteLine("I returned true");
						  }
						  ```
					- > **Note** `==` means equal and `!=` means not equal.
					- ### Else Statements
						- An `else` statement is combined with the `if` statement. In the case that the condition following the `if` statement returns `false`, the code block following the `else` statement will run.
						- In the example below, three variables are assigned values:
							- ```c#
							  var input1 = 10;
							  var input2 = 10;
							  var output = false;
							  
							  // If the input variables are not equal, the output will be set to true.
							  if (input1 != input2) {
							    output = true;
							  } else {
							    output = false;
							  }
							  
							  if (output == true) {
							    // If the output is true, the following string will be printed.
							    Console.WriteLine("I returned true");
							  } else {
							    // Otherwise, the string within this else block will be printed.
							    Console.WriteLine("I returned false");
							  }
							  ```
						- Since the output is `false`, this will output:
							- ```
							  I returned false
							  ```
					- ### Else If Statements
						- An `else if` statement comes after an `if` statement and is used if an extra comparison is needed before an `else` statement.
						- ```c#
						  // Four variables are declared here.
						  var input1 = 10;
						  var input2 = 10;
						  var input3 = 5;
						  var output = false;
						  
						  // If input1 is equal to input3 then set the variable of output to true.
						  if (input1 == input3) {
						  output = true;
						  // If input1 is equal to input2, then set the variable of output to true as well.
						  } else if (input1 == input2) {
						  output = true;
						  // If the two conditions above are false, the else code block will run.
						  } else {
						  output = false;
						  }
						  
						  if (output == true) {
						  Console.WriteLine("I returned true");
						  } else if (output == false) {
						  Console.WriteLine("I returned false");
						  } else {
						  Console.WriteLine("Error");
						  }
						  ```
						- Above, the `else if` condition was true so the output was reassigned a value of `true`. This would run the code block in the first `if` block which will output:
							- ```
							  I returned true
							  ```
				- ## Ternary Operator `?:`
				  AKA Conditional Operator
					- This checks a boolean output and returns one of two results depending on whether the condition is true or false. The ternary operator can be read in pseudocode as follows:
						- ```c#
						  Is this condition true ? Run this if yes : Run this if no;
						  ```
					- In the example below, the condition that is checked is if `input1` is equal to 10. If that condition is true, it returns the first string. Otherwise, it returns the second string:
						- ```c#
						  string getInput1(int input1) => input1 === 10 ? "I returned true" : "I returned false";
						  
						  Console.WriteLine(getInput1(10)); // Output: "I returned true"
						  Console.WriteLine(getInput1(5)); // Output: "I returned false"
						  ```
				- Related: ((661b0696-0081-43dc-9376-810ba6227f6c))
			- [Data Types](https://www.codecademy.com/resources/docs/c-sharp/data-types)
			  id:: 661a4437-8543-448f-9f90-744e8909acdc
			  collapsed:: true
				- C-sharp supports many data types that represent the size and kind of values stored in memory. The two main data types in C# are value and reference types.
				- ## Value Types
					- Value types are data types that are built-in to C#. The available types and their memory sizes are as follows:
					- | Data Type | Description | Memory Size |
					  | --- | --- | --- |
					  | `bool` | Boolean | 1 byte |
					  | `byte` | Byte | 1 byte |
					  | `sbyte` | Short Byte | 1 byte |
					  | `char` | Character | 2 bytes |
					  | `decimal` | Decimal | 16 bytes |
					  | `double` | Double | 8 bytes |
					  | `float` | Float | 4 bytes |
					  | `int` | Integer | 4 bytes |
					  | `uint` | Unsigned Integer | 4 bytes |
					  | `nint` | Native Integer | 4 or 8 bytes |
					  | `unint` | Unsigned Native Integer | 4 or 8 bytes |
					  | `long` | Long | 8 bytes |
					  | `ulong` | Unsigned Long | 8 bytes |
					  | `short` | Short | 2 bytes |
					  | `ushort` | Unsigned Short | 2 bytes |
					- | Type | Description | Size (bytes) | .NET type | Range |
					  | `DateTime` | Moments in time | 8 | System.DateTime | 0:0:00 on 01/01/0001 to 23:59L59 on 12/31/9999 |
					  | `string` | Sequence of characters | 2 per char | System.String | N/A |
						- ((65a050bc-9dbd-4237-b538-f00ea88fa036))
					- The following code demonstrates how to instantiate a variable of each type shown above:
						- ```c#
						  bool isOpen = true;
						  byte age = 45;
						  sbyte temperature = 58;
						  char grade = 'a';
						  decimal numberOfAtoms = 1493867940.23m;
						  double weightOfHippos = 243906.12;
						  float heightOfGiraffe = 908.32f;
						  int seaLevel = -24;
						  uint year = 2023u;
						  nint pagesInBook = 412;
						  unint milesToNewYork = 2597;
						  long circumferenceOfEarth = 25000l;
						  ulong depthOfOcean = 28000ul;
						  short tableHeight = 4;
						  ushort treeBranches = 33;
						  ```
				- ## Reference Types
					- Reference types are objects that exist in external memory space. The reference types in C# are as follows:
						- `object`
						- `string`
						- `dynamic`
			- [Enums](https://www.codecademy.com/resources/docs/c-sharp/enums)
			  collapsed:: true
				- An **enum**, or enumeration type, is a set of named labels that each represent a number.
				- ## Syntax
					- By default, each entry in an enum is assigned a zero-indexed value.
						- ```c#
						  enum NinjaTurtle {
						    Leonardo, // 0
						    Michelangelo, // 1
						    Donatello, // 2
						    Raphael // 3
						  }
						  
						  Console.WriteLine((int)NinjaTurtle.Raphael == 3); // Prints "True"
						  ```
					- However, specific number values can also be assigned.
						- ```c#
						  enum BreadCount {
						    Dozen = 12,
						    BakersDozen = 13,
						    Gross = 144,
						    GreatGross = 1728
						  }
						  ```
				- ## Example
					- The following example uses an enum to identify whether a given place is a city, country, or planet.
						- ```c#
						  using System.Collections.Generic;
						  
						  public enum PlaceType {
						    City,
						    Country,
						    Planet,
						  }
						  
						  public class Place {
						    public string name { get; set; }
						    public PlaceType type { get; set; }
						  
						    public Place(string n, PlaceType t) {
						      name = n;
						      type = t;
						    }
						  }
						  
						  public class Example {
						    public static void Main() {
						      List<Place> places = new List<Place>();
						      places.Add(new Place("Tokyo", PlaceType.City));
						      places.Add(new Place("Canada", PlaceType.Country));
						      places.Add(new Place("Jupiter", PlaceType.Planet));
						    }
						  }
						  ```
					- Codebyte Example
						- The following example uses an enum to classify different types of log messages.
						- ```c#
						  using System;
						  using System.Collections.Generic;
						  
						  public enum LogLevel {
						    Info,
						    Warn,
						    Error,
						  }
						  
						  public class Logger {
						    public HashSet<LogLevel> ShowLevels { get; set; }
						  
						    public Logger() {
						      ShowLevels = new HashSet<LogLevel>();
						    }
						  
						    public void Log(LogLevel level, string message) {
						      if (ShowLevels.Contains(level)) {
						        Console.WriteLine(message);
						      }
						    }
						  }
						  
						  public class Example
						  {
						    public static void Main()
						    {
						      Logger logger = new Logger();
						      logger.ShowLevels.Add(LogLevel.Error);
						  
						      // "b" is logged to the console but "a" is not,
						      // since only Error has been added to ShowLevels.
						      logger.Log(LogLevel.Info, "a");
						      logger.Log(LogLevel.Error, "b");
						    }
						  }
						  ```
			- [Inheritance](https://www.codecademy.com/resources/docs/c-sharp/inheritance)
			  collapsed:: true
				- **Inheritance** in object-oriented programming (OOP) is the concept of creating new classes based on existing classes. In C#, there are parent classes and child classes.
				- Child classes, similar to real-life relationships, can inherit properties, methods, and behaviors from their parent class by default and can also introduce their own unique characteristics.
				- In summary, a child class in C# inherits the attributes and functionalities of its parent class, while also having the flexibility to define its specific characteristics. A child class can modify or override the characteristics of its parent class, providing a new implementation for methods already defined in the parent class. This process is known as polymorphism, another fundamental concept in OOP.
				- The `:` symbol is used in C# within the declaration of the child class to specify the parent or origin class.
				- ## Syntax
					- ```c#
					  public class Phone
					  {
					      public string Brand { get; set; }
					      public string Model { get; set; }
					  
					      public void Call(string phoneNumber)
					      {
					          Console.WriteLine($"Calling {phoneNumber}...");
					      }
					  }
					  public class SmartPhone : Phone
					    {
					      public void BrowseInternet()
					      {
					            Console.WriteLine("Browsing the internet...");
					      }
					  
					  
					      public void SendMessage(string phoneNumber, string message)
					      {
					          Console.WriteLine($"Sending message to {phoneNumber}: {message}");
					      }
					    }
					  
					  public class LandLinePhone : Phone
					  {
					      // LandLine phones don't have internet browsing functionality or message functionality
					  
					  }
					  ```
					- In this example there are two child classes, `SmartPhone` and `LandLinePhone`. Both inherit from the base class or parent class `Phone`. As a result, they have access to the common properties, `Brand` and `Model`, and the call method, `Call()`, defined in the `Phone` class.
					- The `SmartPhone` class has two additional methods, `BrowseInternet()` and `SendMessage()`, which are specific to smartphones. These methods enable smartphones to browse the internet and send messages. Those functionalities are not present in the parent `Phone` class.
					- On the other hand, the `LandLinePhone` class does not have any additional methods because landline phones are typically used only for calling, and this functionality is already inherited from the parent class.
				- ## Implementation
					- The following example implements the classes created earlier in the main method.
					- ```c#
					  public class Program
					  {
					      public static void Main()
					      {
					          SmartPhone cellPhone = new SmartPhone
					          {
					              Brand = "Apple",
					              Model = "Iphone 14"
					          };
					  
					          LandLinePhone housePhone  = new LandLinePhone
					          {
					               Brand = "Panasonic",
					               Model = "KX-TG3411SX"
					          };
					  
					          cellPhone.Call("4259638547");  // Output: "Calling 4259638547..."
					          cellPhone.SendMessage("2589634712", "Hi! I'm a new contributor of codecademy"); // Output: "Sending message to 2589634712: Hi! I'm a new contributor of codecademy"
					          cellPhone.BrowseInternet();   // Output: "Browsing the internet..."
					  
					          housePhone.Call("4384938752");  // Output: "Calling 4384938752..."
					      }
					  }
					  ```
				- ## Types of Inheritance
					- ### Single Inheritance
						- Single inheritance is when a child class inherits the characteristics of only one parent class.
						- ```c#
						  public class Vehicle {
						    // Vehicle class properties and methods
						  }
						  
						  public class Car : Vehicle {
						    // Vehicle class properties and methods accessible here due to inheritance
						    // Car class properties and methods
						  }
						  ```
					- ### Multilevel Inheritance
						- Multilevel inheritance is when a child class inherits from a parent class which in turn inherits from another parent class. This forms a chain of inheritance. A common example in real life is the grand-parent, parent and grand-children relationship.
						- ```c#
						  public class Vehicle {
						    // Vehicle class properties and methods
						  }
						  
						  public class Car : Vehicle {
						    // Vehicle class properties and methods accessible here due to inheritance
						    // Car class properties and methods
						  }
						  public class SportsCar : Car {
						    // Vehicle class properties and methods accessible here due to inheritance
						    // Car class properties and methods accessible here due to inheritance
						    // SportsCar class properties and methods
						  }
						  ```
					- ### Hierarchical Inheritance
						- Hierarchical inheritance is when a single parent class has multiple children.
						- ```c#
						  public class Animal {
						    // Parent class properties and methods
						  }
						  
						  public class Dog : Animal{
						    // Animal class properties and methods accessible here due to inheritance
						    // Dog class properties and methods
						  }
						  
						  public class Cat : Animal{
						    // Animal class properties and methods accessible here due to inheritance
						    // Cat class properties and methods
						  }
						  public class Lion : Animal{
						    // Animal class properties and methods accessible here due to inheritance
						    // Lion class properties and methods
						  }
						  public class Mouse : Animal{
						    // Animal class properties and methods accessible here due to inheritance
						    // Mouse class properties and methods
						  }
						  ```
				- ## Access Modifiers
					- In C#, access modifiers are used as keywords to determine the accessibility level (visibility) of properties, methods, or fields within a C# program.
					- | Keyword | Description |
					  | --- | --- |
					  | `public` | Available anywhere in the program. |
					  | `protected` | Available only to the current class or child classes that inherit from that class. |
					  | `internal` | Available only to the classes in the current project where it is defined. |
					  | `protected internal` | Available to the current class, child classes that inherit from that class, or classes in the current project where it is defined. |
					  | `private` | Only available within the class where it is declared. |
					  | `private protected` | Only available to the classes in the current project where it is defined and also to the children of all classes that inherit from the parent class within the same project. |
			- [Interfaces](https://www.codecademy.com/resources/docs/c-sharp/interfaces)
			  collapsed:: true
				- An **interface** in C# is a contract that defines a set of methods, properties, events, and indexers that a class or struct must implement. Interfaces cannot be instantiated directly, but they can be implemented by classes and structs. They are one of several tools for implementing object-oriented design in C#.
				- ## Syntax
					- An interface in C# is created using the `interface` keyword. The syntax for defining an interface in C# is:
					- ```c#
					  interface MyInterface
					  {
					    void MyMethod();
					    string MyProperty { get; set; }
					    event EventHandler MyEvent;
					  }
					  ```
					- To implement an interface in C#, you use the `:` symbol, followed by the name of the interface. The syntax for implementing an interface is as follows:
					- ```c#
					  class MyClass : MyInterface
					  {
					    public void MyMethod()
					    {
					        // implementation of MyMethod()
					    }
					  
					    public string MyProperty
					    {
					        get { return "MyValue"; }
					        set { }
					    }
					  
					    public event EventHandler MyEvent;
					  }
					  ```
				- ## Example
					- The following example shows implementation of an interface:
					- ```c#
					  using System;
					  - // Create an interface called IAnimal
					  interface IAnimal
					  {
					    // Define a method called Speak()
					    void Speak();
					  }
					  - // Create a class called Dog that implements the IAnimal interface
					  class Dog : IAnimal
					  {
					    public void Speak()
					    {
					        Console.WriteLine("Woof!");
					    }
					  }
					  - // Create a class called Cat that implements the IAnimal interface
					  class Cat : IAnimal
					  {
					    public void Speak()
					    {
					        Console.WriteLine("Meow!");
					    }
					  }
					  - // Create a main method to test the program
					  public class Program
					  {
					    public static void Main(string[] args)
					    {
					        // Create a Dog object
					        Dog dog = new Dog();
					  - // Call the Speak() method on the Dog object
					        dog.Speak();
					  - // Create a Cat object
					        Cat cat = new Cat();
					  - // Call the Speak() method on the Cat object
					        cat.Speak();
					    }
					  }
					  ```
					- The output for the above code is:
					- ```
					  Woof!
					  Meow!
					  ```
				- ## Use of Interfaces
					- Interfaces can be used in C# to achieve a number of different goals, including:
						- `Abstraction`: Interfaces can be used to abstract away the implementation details of a class or struct. This can make code more modular and easier to understand.
						- `Multiple inheritance`: C# does not support multiple inheritance of classes, but it does support multiple inheritance of interfaces. This allows a class to inherit the functionality of multiple different interfaces.
						- `Plug-and-play`: Interfaces can be used to create a “plug-and-play” architecture. This means that different classes or structs can be easily swapped in and out, as long as they implement the same interfaces.
			- [Loops](https://www.codecademy.com/resources/docs/c-sharp/loops)
			  id:: 661a4437-e7f1-4e63-8409-f8b7e61c7a4b
			  collapsed:: true
				- A **loop** is a logical structure used to repeatedly execute a block of code. This repetition can either iterate an exact number of times (definite) or continuously until a condition is met (indefinite).
				- ## For Loop
					- In C# the `for` loop uses definite repetition to run a block of code a specified number of times and consists of three statements separated by semicolons.
						- Statement 1 executes only once, before the code block runs for the first time, and is commonly used to set the initial value of a variable.
						- Statement 2 is a conditional statement that must return `true` for the code block to execute.
						- Statement 3 runs after each repetition of the loop and is typically used to alter the value of the variable set in Statement 1.
					- ```c#
					  for (int i = 5; i > 0; i--)
					  {
					    // Repeated code here
					  }
					  ```
					- > **Note:** Be careful to avoid creating an infinite loop, which occurs if the stop condition never returns `false`.
				- ## While Loop
					- The `while` loop in C# executes an unspecified number of times until the given condition returns `false`. The condition is tested before each iteration of the loop. If the condition is `false` when it is tested the first time, the code block is never run.
					- ```c#
					  int i = 0;
					  while (i > -5)
					  {
					    // Repeated code here
					    i--;
					  }
					  ```
					- > **Note:** The variable tested in the condition should be updated within the code block to avoid an infinite loop.
				- ## Do...While Loop
					- This form of loop uses the `do` keyword, followed by the code block, followed by the `while` keyword and condition. Unlike the `while` loop it checks the condition after the code block is executed. This means the loop will always iterate at least once, but the condition must be `true` for it to continue.
					- ```c#
					  int i = 1;
					  do
					  {
					    // Repeated code here
					    i++;
					  } while (i <= 3);
					  ```
					- > **Note:** The loop in the last example will still run once even though the condition returns `false`.
				- ## For Each Loop
					- The `foreach` loop in C# executes a block of code for each element in a given array or collection. The block is run with each element of the array in turn until the array has been exhausted.
					- It is declared with the `foreach` keyword, followed by, in parentheses, a variable type, a variable name, the keyword `in` and the collection to iterate over.
						- ```c#
						  // Array to loop over
						  int[] numbersArray = {0, 1, 2, 3};
						  - foreach (int number in numbersArray)
						  {
						  System.Console.WriteLine(number);
						  }
						  ```
					- This example outputs the following:
						- ```
						  0
						  1
						  2
						  3
						  ```
			- [Math Functions](https://www.codecademy.com/resources/docs/c-sharp/math-functions)
			  id:: 661a4437-bd17-4036-9849-db5b0c0d9f77
			  collapsed:: true
				- **Mathematical functions** can be performed using the `System.Math` class. `System.Math` is a static class that is included within .NET as part of the `System` namespace. [.NET](https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet) is a free, cross-platform, open source developer platform created by Microsoft.
				- ## Syntax
					- The `Math` class can be accessed by including the `System` namespace within a `.cs` file by adding the following line:
					- ```c#
					  // Include the System namespace
					  using System;
					  ```
					- The `Math` class is static and is accessed without needing to create an instance.
				- ## Example
					- The following example uses the `Math.Pow()` method to return the result of `4` raised to the power of `2`:
					- ```c#
					  // Include the System namespace
					  using System;
					  
					  public class Example
					  {
					    public static void Main(string[] args)
					    {
					      // Raise 4 to power of 2
					      double x = Math.Pow(4,2);
					  
					      System.Console.WriteLine("x = {0}", x);
					      // Output: x = 16
					    }
					  }
					  ```
					- In cases where access to `System.Math` is required but access to the entire `System` namespace is not, an alternative syntax can be used instead. The following example uses an alternative syntax and returns the floor of `3/2` using the `System.Math.Floor()` method:
					- ```c#
					  public class Example
					  {
					    public static void Main(string[] args)
					    {
					      // Round down the result of 3/2
					      double x = System.Math.Floor((double)3/2);
					  
					      System.Console.WriteLine("x = {0}", x);
					      // Output: x = 1
					    }
					  }
					  ```
				- ## Math Functions
					- Below are a selected list of `System.Math` methods:
					- [.Abs()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/abs)
					  id:: 661a4f9f-5b61-421c-8373-44715dee2042
					  Returns the absolute value of a given number.
						- Example: `Math.Abs(-5)` returns 5
					- [.Acos()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/acos)
					  : Returns the inverse cosine of the argument.
					- [.Asin()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/asin)
					  Returns an angle in radians whose sine is a specified number.
					- [.Atan()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/atan)
					  Returns the inverse tangent of the argument.
					- [.Atan2()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/atan2)
					  Returns the angle, in radians, between the positive x-axis and the vector to point (x, y).
					- [.Ceiling()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/ceiling)
					  id:: 661a4f9f-b5d1-4432-aabe-bbd84c968626
					  collapsed:: true
					  Returns the smallest integer which is greater than or equal to a given number.
						- **`Math.Ceiling()`** is a class method that always rounds up to the next full integer. It is used to return the smallest integer greater than or equal to the specified number.
						- ## Syntax
							- ```c#
							  Math.Ceiling(val);
							  ```
							- The method takes only one parameter, `val`, the number to be rounded (as a `decimal` or `double` type).
						- ## Example
							- The following example uses `Math.Ceiling()` to return the next full integer.
							- ```c#
							  // Include the System namespace
							  using System;
							  public class Demo {
							     public static void Main(){
							        decimal val1 = 6.64M;
							        decimal val2 = -9.02M;
							        Console.WriteLine("Solution = " + Math.Ceiling(val1));
							        Console.WriteLine("Solution = " + Math.Ceiling(val2));
							     }
							  }
							  ```
							- The example will result in the following output:
							  ```
							  Solution = 7
							  Solution = -9
							  ```
						- ## Codebyte Example
							- The following example is runnable and uses the `Math.Ceiling()` method to return the smallest whole number that is greater than or equal to the given `double` type `number`:
								- ```c#
								  using System;
								  
								  public class Example {
								    public static void Main() {
								      double number = 3.14159;
								      double ceiling = Math.Ceiling(number);
								  
								      Console.WriteLine("The ceiling value of " + number + " is " + ceiling);
								    }
								  }
								  
								  ```
					- [.Cos()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/cos)
					  Returns the cosine of a given angle.
					- [.Cosh()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/cosh)
					  Returns the hyperbolic cosine of a given angle.
					- [.Exp()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/exp)
					  : Returns the result of raising e to the power of a specific number.
					- [.Floor()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/floor)
					  id:: 661a4f9f-7418-4418-87e9-822887e36605
					  Returns the largest whole integer which is less than or equal to the given number.
						- Example: `Math.Floor(8.65)` returns 8
					- [.Max()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/max)
					  collapsed:: true
					  Returns the greater of two specified numbers.
						- The **`Math.Max()`** method returns the greater of two specified numbers.
						- ## Syntax
							- ```c#
							  Math.Max(num1, num2)
							  ```
							- `Math.Max()` returns the greater value from `num1` and `num2`.
						- ## Example
							- The following example compares two integers `i1` and `i2` and writes the greater integer to the console.
								- ```c#
								  using System;
								  
								  public class Example {
								    public static void Main (string[] args) {
								      int i1 = -234, i2 = 345;
								  
								      Console.WriteLine("Math.Max (int) = " + Math.Max(i1,i2));
								    }
								  }
								  ```
							- This example results in the following output:
							  `Math.Max (int) = 345`
						- ## Codebyte Example
							- The following example is runnable and uses the `Math.Max()` method to return the greater number from the given two `integer` type numbers, `number1` and `number2`:
								- ```c#
								  using System;
								  
								  public class Example {
								    public static void Main() {
								      int number1 = 12756, number2 = 12104;
								      int max = Math.Max(number1, number2);
								  
								      Console.WriteLine("The max value of " + number1 + " and " + number2 + " is " + max);
								    }
								  }
								  ```
					- [.Min()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/min)
					  collapsed:: true
					  Returns the smaller of two specified numbers.
						- The **`Math.Min()`** method returns the lesser of two specified numbers.
						- ## Syntax
							- ```c#
							  Math.Min(num1, num2)
							  ```
							- `Math.Min()` returns the lesser value from `num1` and `num2`.
						- Example:
							- `Math.Min(39, 12)` returns 12
							- `Math.Min(10, -20)` returns `NaN`
								- can only take a positive number as a value, but the second value is negative. This can be circumvented using ((661a4f9f-5b61-421c-8373-44715dee2042))
						- ## Example
							- The following example compares two integers `i1` and `i2` and writes the lesser integer to the console.
								- ```c#
								  using System;
								  
								  public class Example {
								    public static void Main (string[] args) {
								      int i1 = -134, i2 = 268;
								  
								      Console.WriteLine("Math.Min (int) = " + Math.Min(i1,i2));
								    }
								  }
								  ```
							- This example results in the following output:
							  `Math.Min (int) = -134`
						- ## Codebyte Example
							- Try changing the values of xint1 and xint2 to see the results.
								- ```c#
								  string str = "{0}: The lesser of {1,3} and {2,3} is {3}.";
								  
								  int xInt1 = 267, xInt2 = -39;
								  
								  Console.WriteLine("Display the lesser of two values:\n");
								  Console.WriteLine(str,"--> ", xInt1, xInt2, Math.Min(xInt1, xInt2));
								  ```
					- [.Pow()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/pow)
					  collapsed:: true
					  Returns the result of a given number raised to the power of a second number.
						- The **`Math.Pow()`** method returns a number raised to the power of a second number.
						- ## Syntax
							- ```c#
							  Math.Pow(num1, num2)
							  ```
							- `Math.Pow()` takes two values of type `double`. It will return a `double` that is the result of the value `num1` raised to the power of value `num2`.
						- ## Example
							- The following example demonstrates the `Math.Pow()` method and writes the result to the console.
							- ```c#
							  using System;
							  
							  public class Example {
							    public static void Main (string[] args) {
							      double d1 = 8, d2 = 3;
							  
							      Console.WriteLine("8^3 = " + Math.Pow(d1,d2));
							    }
							  }
							  ```
							- This example results in the following output:
							  `8^3 = 512`
						- ## Codebyte Example
							- The following example is runnable and uses the `Math.Pow()` method to return a `double` type value of `2` raised to the power of `10`:
								- ```c#
								  using System;
								  
								  public class Example {
								    public static void Main() {
								      double number = 2, power = 10;
								      double value = Math.Pow(number, power);
								  
								      Console.WriteLine("The value of " + number + " raised to the power of " + power + " is " + value);
								    }
								  }
								  ```
					- [.Round()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/round)
					  collapsed:: true
					  Returns a value rounded to the nearest integer. | Similar: ((661a4f9f-b5d1-4432-aabe-bbd84c968626)) to round up or ((661a4f9f-7418-4418-87e9-822887e36605)) to round down
						- The **`Math.Round()`** class method returns a value rounded to the nearest integer.
						- ## Syntax
							- ```c#
							  Math.Round(value1, value2, value3);
							  ```
							- The `Math.Round()` method takes up to three parameters:
								- `value1` is the only required parameter and is either a decimal or double.
								- `value2` would be an integer ranging from -2,147,483,648 to 2,147,483,647 (int32), or it could be a specific mode that is called from the `MidpointRounding` `enum`.
								- `value3` would be the mode if `value2` was of type int32. The modes include: `ToEven`, `AwayFromZero`, `ToZero`, and `TowardZero`.
						- ## Example
							- The following example passes one argument as a parameter:
								- ```c#
								  using System;
								  
								  public class Example {
								    public static void Main(string[] args) {
								      decimal val1 = 10.2m;
								      val1 = Math.Round(val1);
								  
								      Console.WriteLine("Rounded value is " + val1);
								    }
								  }
								  ```
							- The example will result in the following output:
						- ## Codebyte Example
							- The following example passes three arguments into the method:
							  `Rounded value is 10`
					- [.Sin()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/sin)
					  Returns the sine of a given angle.
						-
					- [.Sinh()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/sinh)
					  Returns the hyperbolic sine of a given angle.
						-
					- [.Sqrt()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/sqrt)
					  Returns the square root of the given number.
						- Example: `Math.Sqrt(16)` returns 4.
					- [.Tan()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/tan)
					  Returns the tangent of a given angle.
						-
					- [.Tanh()](https://www.codecademy.com/resources/docs/c-sharp/math-functions/tanh)
					  Computes the hyperbolic tangent of a given angle in radians.
						-
			- [Methods](https://www.codecademy.com/resources/docs/c-sharp/methods)
			  id:: 661a4437-293b-4dd4-8109-f9ad9e491fc6
			  collapsed:: true
				- **Methods** are blocks of code that can be reused elsewhere in a C# application. Each application has at least one `Main()` method that acts as the starting point. Methods are used to avoid the repetition of code and make it maintainable and readable. Usually, a method has one or multiple dedicated purposes.
				- A function inside a class is called a method. As C# is an [object-oriented](https://www.codecademy.com/resources/docs/general/programming-paradigms/object-oriented-programming) programming language, all functions are declared inside classes, making them methods. Thus, methods and functions are synonymous.
				- ## Syntax
					- ```c#
					  // Declare a public method without return type and no parameters:
					  public void PrintString()
					  {
					  Console.WriteLine("Hello, World!");
					  }
					  
					  // Declare a private method which returns an object and takes no parameters:
					  private int ReturnNumber()
					  {
					  return 7;
					  }
					  
					  // Declare a public method which returns an object and takes an input parameter:
					  public int CalculateWithParameter(int x)
					  {
					  return ReturnNumber() - x;
					  }
					  ```
					  
					  Methods begin with a signature made of the following parts:
						- An access level of `public` or `private` (`private` is the default)
							- or `static` ?
						- Optional modifiers (e.g., `abstract` and `sealed`)
						- The method return value (`string`, `int`, `object`, etc.) or `void`
						- The method name (starting with a capital letter; usually a verb) in ((b2c095a3-5b8c-49e3-a10d-877a42e8cb78))
						- Zero, one, or more (optional) parameters
				- ## Codebyte Example
					- In the following example, two methods are separate defined: `Main()` and `GetSquare()`. When the program is run, the `Main()` is executed first which, in turn, executes the `GetSquare()` method with an `int` parameter passed to it. The returned value is saved to a ((661a4437-eddf-41d9-bea4-620702a24cd1)) and printed to the console:
					- ```c#
					  using System;
					  
					  public class Example
					  {
					    public static void Main(string[] args)
					    {
					      var squared = new Example().GetSquare(5);
					      Console.WriteLine(squared.ToString());
					    }
					  
					    private int GetSquare(int i)
					    {
					       return i * i;
					    }
					  }
					  ```
				- Related: ((661a4437-bd17-4036-9849-db5b0c0d9f77))
			- [Operators](https://www.codecademy.com/resources/docs/c-sharp/operators)
			  id:: 661a4437-b99e-4eee-b817-8934c7a5b486
			  collapsed:: true
				- **Operators** are used to perform various operations on variables and values.
				- ## Syntax
					- The following code snippet uses the assignment operator, `=`, to set `myVariable` to the value of `num1` and `num2` with an arithmetic operator operating on them. For example, if `operator` represented `*`, `myVariable` would be assigned a value of `num1 * num2`.
						- ```c#
						  myVariable = num1 operator num2;
						  ```
					- Operators can be organized into the following groups:
						- Arithmetic operators for performing traditional math evaluations.
						- Assignment operators for assigning values to variables.
						- Comparison operators for comparing two values.
						- Logical operators for combining `Boolean` values.
						- ((661a4cd2-7870-436a-aa84-2232cd3b80c8)) for manipulating the bits of a number.
				- ## Arithmetic Operators
				  id:: 661a4c49-43de-4e09-84da-a6032501f710
					- C# has the following arithmetic operators:
						- Addition, `+`
						  Returns the sum of two numbers.
						- Subtraction, `-`
						  Returns the difference between two numbers.
						- Multiplication, `*`
						  Returns the product of two numbers.
						- Division, `/`
						  Returns the quotient of two numbers.
						- Modulus `%`
						  id:: 661a4c49-5fc2-4c7c-87ba-ee59c4bab764
						  Returns the remainder of one number divided by another.
							- ```
							  4 % 3 = 1
							  4 % 2 = 0
							  ```
					- The ones above operate on two values. C# also has two unary operators:
					  id:: 661a4d14-50c3-4332-bf6f-25992ce1d4cd
						- Increment, `++`, which increments its single operand by one.
						- Decrement, `--`, which decrements its single operand by one.
					- Unlike the other arithmetic operators, the increment and decrement operators change the value of their operand as well as return a value. They also return different results depending on if they precede or follow the operand. Preceding the operand returns the value of the operand before the operation. Following the operand returns the value of the operand after the operation.
					- ```c#
					  int x = 5;
					  int y = x++; // x now equals 6, y equals 5
					  int z = --x; // x now equals 5, z equals 5
					  ```
				- ## Logical Operators
				  id:: 661a4c49-eb41-4638-8d3e-455ea8464230
					- C# has the following logical operators:
						- AND `&&`
						  id:: 661a4c49-9bce-4461-a744-0333ca1666bb
						  Returns `true` if both operands are `true`.
						- OR `||`
						  id:: 661a4c49-8c79-4040-ac61-9b5f457e5c54
						  Returns `true` if either operand is `true`.
						- NOT `!`
						  Returns `true` if its single operand is `false`.
						- XOR`^` 
						  Returns `true` if only one of its operands are `true`
					- > **Note:** `&`,`|`, and `^` are logical operators when the operands are `bool` types. When the operands are numbers they perform bitwise operations. See ((661a4c49-6d77-42a7-a341-91edce8c9bba)) below.
					- The above operators always evaluate both operands. There are also these conditional “short circuiting” operators:
						- ((661a4c49-9bce-4461-a744-0333ca1666bb)) returns `true` if both operands are `true`. If the first operand is `false`, the second operand is not evaluated.
						- ((661a4c49-8c79-4040-ac61-9b5f457e5c54)) returns `true` if either operand is `true`. If the first operand is `true` the second operand is not evaluated.
					- Related: ((661af6a9-f2c6-47ea-ac52-675a0be104e6))
				- ## Assignment Operators
				  id:: 661a4c62-bdad-4e27-9b1f-0b3abaa32714
					- C# includes the following assignment operators:
						- `=` operator
						  Assigns the value on the right to the variable on the left.
						- `+=` operator
						  Updates a variable by incrementing its value and reassigning it.
						- `-=` operator 
						  Updates a variable by decrementing its value and reassigning it.
						- The `*=` operator updates a variable by multiplying its value and reassigning it.
						- The `/=` operator updates a variable by dividing its value and reassigning it.
						- The `%=` operator updates a variable by calculating its modulus against another value and reassigning it.
					- The assignment operators of the form `op=`, where `op` is a binary arithmetic operator, is a shorthand. The expression `x = x op y;` can be shortened to `x op= y;`. This compound assignment also works with the logical operators `&`, `|` and `^`.
						- The `??=` operator assigns the value on the right to the variable on the left if the variable on the left is `null`.
				- ## Comparison Operators
				  id:: 661a4c49-5af5-4cc4-b1b0-2339ab8fa2b1
					- C# has the following comparison operators:
						- Equal `==`
						  For returning `true` if two values are equal.
						- Not equal `!=`
						  AKA Inequality | For returning `true` if two values are not equal.
						- Less than `<`
						  For returning `true` if the left value is less than the right value.
						- Less than or equal to `<=`
						  For returning `true` if the left value is less than or equal to the right value.
						- Greater than `>`
						  For returning `true` if the left value is greater than the right value.
						- Greater than or equal to `>=`
						  For returning `true` if the left value is greater than or equal to the right value.
					- > **Note:** for these comparison operators, if any operand is not a number (`Double.NaN` or `Single.NaN`) the result of the operation is `false`.
				- ## Bitwise Operators
				  id:: 661a4c49-6d77-42a7-a341-91edce8c9bba
					- C# has the following operators that perform operations on the individual bits of a number.
						- Bitwise complement, `~`, inverts each bit in a number.
						- Left-shift, `<<`, shifts its left operand left by the number of bits specified in its right operand. New right positions are zero-filled.
						- Right-shift, `>>`, shifts its left operand right by the number of bits specified in its right operand. For signed integers, left positions are filled with the value of the high-order bit. For unsigned integers, left positions are filled with zero.
						- Unsigned right-shift, `>>>`, same as `>>` except left positions are always zero-filled.
						- Logical AND, `&`, performs a bitwise logical AND of its operands.
						- Logical OR, `|`, performs a bitwise logical OR on its operands.
						- Logical XOR, `^`, performs a bitwise logical XOR on its operands.
					- Related: ((661a4cd2-7870-436a-aa84-2232cd3b80c8))
			- [Strings](https://www.codecademy.com/resources/docs/c-sharp/strings)
			  id:: 661a4437-6b1e-415e-a5c4-4f1f32571d9c
			  collapsed:: true
				- A **`string`** is an instance of the `System.String` object in C# and represents an immutable sequence of `Char` objects. Unlike other languages, there’s no null-terminating character at the end of a C# string, so a C# string can contain embedded null characters. The `string` keyword in C# is an alias for `System.String` and can be used even without `using System;`.
				  
				  > **Note:** Strings are immutable, which means they do not change once created. Methods and operators that appear to change a string in a variable really assign a new string to the variable and release the old string for garbage collection. This is important to realize when using references, since a reference pointing to a string that’s subsequently “modified” will continue to point to the original unmodified string.
				- ## Declaring and Initializing
					- There are many different ways to declare and initialize a string in C#. The following example lists a number of them:
					- ```c#
					  // Declare without initializing.
					  string myString1;
					  
					  // Declare using System.String.
					  System.String myString2;
					  
					  // Initialize with a string literal.
					  string myString3 = "Hello World!";
					  
					  // Local variables can use implicit typing.
					  var localString = "Still a strongly-typed string.";
					  
					  // The string constructor can create a string from a char*, char[] or sbyte*.
					  char[] source = {'1','2','3','A','B','C'};
					  string myString4 = new string(source);
					  ```
					- The `new` operator is only used to create a string when initializing with an array of `char`.
					- > **Note:** It is best practice to initialize an empty string with the `System.String.Empty` constant value or the `""` string literal rather than with `null` to avoid an unwanted `NullReferenceException`.
				- ## String Literals
					- C# has three different types of string literals.
					- ### Quoted String Literals
					  id:: 661a4a99-a9ab-4de0-875d-407caf91cc8c
						- Quoted string literals are contained within a pair of double quote characters (`"`) on a single line. They require escape characters to include special characters and line breaks.
						- ```c#
						  string myString1 = "I'm a quoted string literal.";
						  
						  string myString2 = "I have an embedded\r\nline break.";
						  /* The resulting string:
						  I have an embedded
						  line break.
						  */
						  ```
						- Escape Character Sequences:
							- | Escape Sequence | Character Name |
							  | --- | --- |
							  | `\'` | Single quote |
							  | `\"` | Double quote |
							  | `\\` | Backslash |
							  | `\0` | Null |
							  | `\n` | New line |
							  | `\r` | Carriage return |
							  | `\t` | Horizontal tab |
							  | `\uNNNN` | UTF-16 Unicode character (range `\u0000` - `\uFFFF`) |
							  | `\U00NNNNNN` | UTF-32 Unicode character (range `\U00000000` - `\U0010FFFF`) |
							- Examples
								- ```c#
								  string withSlash = "Ifemelu said, \"Hello!\"";
								  string newLine = "Ifemelu walked \n to the park.";
								  ```
							- [Escape Sequences | Microsoft Learn](https://docs.microsoft.com/en-us/cpp/c-language/escape-sequences?view=vs-2017)
							-
					- ### Verbatim String Literals
						- Verbatim string literals are a convenience used for multi-line strings, strings that contain backslashes, or embedded double quotes. Verbatim string literals begin with `@"` rather than just `"` as with a quoted literal string.
						  
						  > **Note:** Use two double quotes (`""`) to include a double quote in a verbatim string literal.
						- ```c#
						  string msPath = @"C:\Users\JSmith\Documents\Readme.txt";
						  /* The resulting string:
						  C:\Users\JSmith\Documents\Readme.txt
						  */
						  
						  string myString1 = @"I have an embedded
						  line break";
						  /* The resulting string:
						  I have an embedded
						  line break.
						  */
						  
						  string myString2 = @"This string says, ""Hello World!"".";
						  /* The resulting string:
						  This string says, "Hello World!".
						  */
						  ```
					- ### Raw String Literals
						- Raw string literals were introduced with C# 11. It preserves whitespace, allows the use of embedded line breaks, and can include any character that would otherwise require an escape sequence. It allows the raw string literal to appear in code exactly how it will be stored and/or displayed.
						- Raw string literals obey the following rules:
							- They begin and end with at least three quote characters (`"""`). More than three can be used in instances where there are three consecutive quote characters in the string itself.
							- A single line string requires the opening and closing character sequences on the same line.
							- Multi-line strings require the opening and closing character sequences to each be on their own line.
							- In multi-line strings, whitespace to the right of the opening character sequence is omitted.
							- In multi-line strings, whitespace to the left of the closing character sequence is removed from every line of the string.
						- ```c#
						  string myString1 = """Using "Hello World!" as an example.""";
						  /* The resulting string:
						  Using "Hello World!" as an example.
						  */
						  
						  string myString2 = """
						  Using
						    "Hello
						      World."
						       as a
						         Example.
						  """;
						  /* The resulting string:
						  Using
						    "Hello
						      World."
						       as a
						         Example.
						  */
						  
						  string myString3 = """"
						  Raw string literal example:
						  string temp = """text.""";
						  """";
						  /* The resulting string:
						  Raw string literal example:
						  string temp = """text.""";
						  */
						  ```
				- ## String Interpolation
				  id:: 661a4b2a-f191-4e53-87fe-3fa01c099613
					- Interpolated strings contain expressions delimited by curly braces (`{...}`) that are evaluated when the string literal is evaluated and used in place of the whole expression. It can improve the readability and maintainability of code.
					- An interpolated quoted string literal is identified by a preceding `$` character.
						- ```c#
						  string yourFaveMusician = "David Bowie";
						  string myFaveMusician = "Solange";
						  
						  Console.WriteLine($"Your favorite musician is {yourFaveMusician} and mine is {myFaveMusician}.");
						  ```
						- ```c#
						  string name = "John";
						  string greet = @"""Hello World!""";
						  string myString = $"{name} says, {greet}";
						  /* The resulting string:
						  John says, "Hello World!"
						  */
						  ```
					- Interpolation can be used with verbatim string literals, preceding them with `@$` or `$@`.
						- ```c#
						  string name = "John";
						  string greet = @"""Hello World!""";
						  string myString = @$"{name}
						    says,
						      {greet}";
						  /* The resulting string:
						  John
						    says,
						      "Hello World!"
						  */
						  ```
					- Interpolation can also be used with raw string literals. They are preceded by one or more `$` characters. The number of `$` used indicates the number of curly braces used to enclose interpolated expressions, sequences of curly braces less than that number will be included in the output.
						- ```c#
						  string name = "John";
						  string greet = @"""Hello World!""";
						  string myString = $""""
						  {name}
						    says,
						      {greet}
						  """";
						  /* The resulting string:
						  John
						    says,
						      "Hello World!"
						  */
						  ```
					- Related:
						- ((64f0ad1c-0b89-4c2b-b2c6-295f9c2fa70e))
						- Little used alternative since string interpolation introduced: ((661ae869-e18d-410e-b6d0-9247d7f2e20a))
				- ## Codebyte Example
					- The following is a runnable example showing string interpolation and verbatim string literals.
					- > **Note:** When editing this codebyte, be aware that the version of C# being used does not permit raw string literals.
					- ```c#
					  using System;
					  
					  public class Program
					  {
					    public static void Main()
					    {
					      string name = "John";
					      string greet = @"""Hello World!""";
					      string myString = @$"{name}
					    says,
					      {greet}";
					  
					      Console.WriteLine(myString);
					    }
					  }
					  
					  ```
				- ## Methods
				  id:: 661ae9a6-dd5b-4411-90ec-48f6c5aa545f
					- [.Compare()](https://www.codecademy.com/resources/docs/c-sharp/strings/compare)
					  collapsed:: true
					  Compares the alphabetical order of two strings and returns an integer that represents their relative ranking.
					- [.Contains()](https://www.codecademy.com/resources/docs/c-sharp/strings/contains)
					  collapsed:: true
					  Determines whether a character or subset of characters is present within a given string | Alternatively can use ((661ae9b4-ca33-493c-b058-e870b5ec6c14)) to check this
						- The **`.Contains()`** method determines whether a `string` includes a particular character or substring. It returns `true` if the character is included, otherwise the method returns `false`. There are additional parameters that can modify the comparison rules.
						- ## Syntax
							- ```c#
							  // Determines whether the String includes a given character
							  String.Contains(char);
							  
							  // Determines whether the String includes a given string
							  String.Contains(string);
							  
							  // Determines whether the String includes a given character considering the type of comparison
							  String.Contains(char, comparisonType)
							  
							  // Determines whether the String includes a given string considering the type of comparison
							  String.Contains(string, comparisonType)
							  ```
							- `.Contains()` takes the following arguments:
								- `char` is a single character.
								- `string` is a sequence of characters.
								- `comparisonType` is an enumeration value that allows to add specific rules to compare strings such as culture, case, and sort. Passing as an additional argument:
								- `CurrentCulture` determines whether strings match culture-sensitive criteria.
								- `CurrentCultureIgnoreCase` same as above and ignores the case.
								- `InvariantCulture` determines whether strings match culture-sensitive criteria and the invariant culture.
								- `InvariantCultureIgnoreCase` same as above and ignores the case.
								- `Ordinal` determines whether strings match using binary sort rules.
								- `OrdinalIgnoreCase` same as above and ignores the case.
						- ## Example
							- The following example shows how we can use `.Contains()` method
								- ```c#
								  using System;
								  
								  public class Example
								  {
								      public static void Main()
								      {
								          string stringToSeek = "The distance is nothing when one has a motive.";
								          string substring = "motive";
								          char character = 'l';
								  
								          bool result;
								  
								          // String.Contains(string)
								          result = stringToSeek.Contains(substring);
								          Console.WriteLine(result);
								  
								          // String.Contains(char)
								          result = stringToSeek.Contains(character);
								          Console.WriteLine(result);
								      }
								  }
								  ```
								- Here is the following output:
								- ```
								  True
								  False
								  ```
							- ## Codebyte Example
								- The example below determines whether the word `helpful` is included in the particular string.
								- ```c#
								  using System;
								  
								  public class CodeByte
								  {
								      public static void Main()
								      {
								          string exampleString = "Codecademy is very helpful";
								          string stringToFind = "helpful";
								  
								          if (exampleString.Contains(stringToFind))
								          {
								            Console.WriteLine("The example string contains the word \"{0}\"", stringToFind);
								          }
								      }
								  }
								  ```
					- [.EndsWith()](https://www.codecademy.com/resources/docs/c-sharp/strings/endswith)
					  Determines if the end of the string instance matches the specified string and returns a boolean.
					- [.Equals()](https://www.codecademy.com/resources/docs/c-sharp/strings/equals)
					  Determines whether two string objects have the same value or not.
					- [.IndexOf()](https://www.codecademy.com/resources/docs/c-sharp/strings/indexof)
					  id:: 661ae9b4-ca33-493c-b058-e870b5ec6c14
					  collapsed:: true
					  Returns the index of a specified character or substring in a string.
						- The **`.IndexOf()`** method is a string method that returns the index of the first occurrence of a specified character or substring in a given string. If the character or substring is not found, it returns `-1`.
						- ## Syntax
							- ```c#
							  IndexOf(char value);
							  IndexOf(string value);
							  IndexOf(char value, int startIndex);
							  IndexOf(string value, int startIndex);
							  IndexOf(string value, int startIndex, int count);
							  ```
								- `value` : The substring or character to search for.
								- `startIndex` (optional): The index from where the search should start.
								- `count` (optional): Maximum number of characters to search.
						- ## Examples
							- ```c#
							  string word = "radio";
							  word.IndexOf("a"); // returns 1
							  ```
							- The following example uses the `IndexOf()` method to find the index of the first occurrence of the character “d” in the string “Codecademy docs”.
								- ```c#
								  string str = "Codecademy docs";
								  int index = str.IndexOf('d');
								  
								  Console.WriteLine("Index: " + index);
								  // 2
								  ```
							- The following codebyte is runnable and shows the usage of the `.IndexOf()` method on a string.
								- ```c#
								  using System;
								  
								  public class IndexOfExample
								  {
								      public static void Main()
								      {
								          string sentence = "The cat in the hat wears a red and white striped hat";
								  
								          Console.WriteLine(sentence);
								  
								          int index1 = sentence.IndexOf('h');
								          Console.WriteLine($"Index of 'h': {index1}");
								  
								          int index2 = sentence.IndexOf("cat");
								          Console.WriteLine($"Index of 'cat': {index2}");
								  
								          int index3 = sentence.IndexOf('a', 10);
								          Console.WriteLine($"Index of 'a' starting from index 10: {index3}");
								  
								          int index4 = sentence.IndexOf("dog");
								          Console.WriteLine($"Index of 'dog': {index4}");
								      }
								  }
								  ```
					- [.LastIndexOf()](https://www.codecademy.com/resources/docs/c-sharp/strings/lastindexof)
					  Finds the last occurrence of a specified character or substring within a string.
					- `.Length`
					  collapsed:: true
					  Returns the number of characters in a string.
						- ## Example
							- ```c#
							  string userTweet = Console.ReadLine();
							  userTweet.Length; // returns the length of the tweet
							  ```
					- [.Replace()](https://www.codecademy.com/resources/docs/c-sharp/strings/replace)
					  Returns a new string where every instance of a certain character or substring in the original string is swapped with a different specified character or substring.
					- [.StartsWith()](https://www.codecademy.com/resources/docs/c-sharp/strings/startswith)
					  Determines if the start of the string instance matches the specified string and returns a boolean.
					- [.ToLower()](https://www.codecademy.com/resources/docs/c-sharp/strings/tolower)
					  collapsed:: true
					  Converts all the characters in a given string to lowercase.
						- The **`.ToLower()`** method is a string method in C# that returns a new string in which all the characters are converted to lowercase.
						- The method does not modify the original string, but rather returns a new one. This method is helpful in normalizing user input or comparing strings in a case-insensitive manner.
						- ## Syntax
							- ```c#
							  myString.ToLower();
							  ```
							- `myString` is the string being converted to lowercase.
						- ## Examples
							- In the following example, the `.ToLower()` method is called on a string `originalString`, and is printed to the console:
								- ```c#
								  using System;
								  
								  string originalString = "HELLO WORLD";
								  
								  Console.WriteLine(originalString.ToLower()); // Output: "hello world"
								  ```
							- In following runnable example, a new string `originalString` is created that contains some text. Then, the `.ToLower()` method is called on this string and the result is stored in a new string variable `lowerCaseString`. Finally, both the original and the lowercase strings are printed to the console.
								- ```c#
								  using System;
								  
								  class Program {
								    static void Main(string[] args) {
								      string originalString = "THIS IS A TEST STRING";
								      string lowerCaseString = originalString.ToLower();
								  
								      Console.WriteLine("Lowercase string: " + originalString.ToLower(););
								      Console.WriteLine("Original string: " + originalString);
								    }
								  }
								  
								  ```
					- [.ToUpper()](https://www.codecademy.com/resources/docs/c-sharp/strings/toupper)
					  collapsed:: true
					  Returns a new string with all uppercase characters.
						- In C#, the **`.ToUpper()`** method returns a new string with all the characters converted to uppercase. Numbers and symbols are not changed.
						- This method does not modify the original string, but instead, it creates a new string that contains the uppercase version of the original string.
						- ## Syntax
							- ```c#
							  somestring.ToUpper()
							  ```
							- This method will not change the input string.
						- ## Example
							- In the following example, `originalString` is the string being converted to uppercase, and `uppercaseString` is the new string that contains the uppercased characters. The original string remains unchanged:
								- ```c#
								  using System;
								  
								  class Program
								  {
								    static void Main(string[] args)
								    {
								      originalString = "Hello World"
								      string uppercaseString = originalString.ToUpper();
								  
								      Console.WriteLine(originalString);
								      Console.WriteLine(uppercaseString);
								    }
								  }
								  ```
								- This will output:
								  ```
								  Hello World
								  HELLO WORLD
								  ```
							- The example below converts a given string to uppercase and stores this value in a new string variable named `uppercaseString`
								- ```c#
								  using System;
								  
								  class Program
								  {
								      static void Main(string[] args)
								      {
								          originalString = "Hello World"
								          string uppercaseString = originalString.ToUpper();
								  
								          Console.WriteLine(originalString);
								          Console.WriteLine(uppercaseString);
								      }
								  }
								  ```
					- Related: ((6463496c-ee2f-4e6d-9d0f-de44fabf8ce3)) : ((6463496c-4dc7-41b4-a00c-b8c3ba16066b))
			- [Switch](https://www.codecademy.com/resources/docs/c-sharp/switch)
			  id:: 661c63bd-923c-4304-87ee-ad6a895fc2d4
			  collapsed:: true
				- **Switch** statements execute a code block from a list of `case` conditions for which the `expression` validates as `true`. Switch statements are similar to if/else statements.
				- ## Syntax
					- ```c#
					  switch (expression)
					  {
					  case alpha:
					    // Code block
					    break;
					  case beta:
					    // Code block
					    break;
					  default:
					    // Code block
					    break;
					  }
					  ```
					  
					  A `switch` statement includes one or more `case` conditions. The `case` conditions are evaluated in top-to-bottom order. If none of the `case` conditions evaluate to `true`, the `default` condition is executed. If no `default` is defined, the switch statement is bypassed.
					- Common Switch syntax definitions:
						- `switch`: Definition of the `switch` statement.
						- `expression`: The logic each `case` will be evaluated against.
						- `case`: A value the `expression` is matched against. If the `case` matches the result of the `expression`, the code block within the `case` will be executed.
						- `break` (recommended): Terminates the switch statement. Recommended at the end of each `case` and `default` to terminate the switch once the case has been fulfilled. A switch statement tests all cases unless a `break`, `throw`, or `return` statement is used to direct control out of the switch. If no `break` statement exists in a case, C# will throw a compile time error.
						- `default` (optional): The behavior executed if no `case` condition matches the `expression`.
				- ## Codebyte Example
					- The following example creates a string variable named `favoriteTurtle` with the value of `"Donatello"`. A switch statement is defined that evaluates the value of `favoriteTurtle`. If a case matches the value of `favoriteTurtle`, a corresponding message is printed to the console. If none of the cases in the switch statement match the value of `favoriteTurtle`, a default message is printed to the console.
					- ```c#
					  using System;
					  
					  public class Example
					  {
					    public static void Main(string[] args)
					    {
					    string favoriteTurtle = "Donatello";
					  
					    switch (favoriteTurtle)
					    {
					      case "Leonardo":
					        Console.WriteLine("Leads!");
					        break;
					      case "Donatello":
					        Console.WriteLine("Does machines!");
					        break;
					      case "Raphael":
					        Console.WriteLine("Cool, but rude!");
					        break;
					      case "Michelangelo":
					        Console.WriteLine("Party dude!");
					        break;
					      default:
					        Console.WriteLine($"{favoriteTurtle} sounds cool, but I'll bet they're not a ninja!");
					        break;
					    }
					   }
					  }
					  
					  // Output: "Does machines!"
					  ```
				- Related: ((661a4437-e612-405b-b4fc-589f868546e0))
			- [Variables](https://www.codecademy.com/resources/docs/c-sharp/variables)
			  id:: 661a4437-eddf-41d9-bea4-620702a24cd1
			  collapsed:: true
				- A **variable** is a storage location in the computer’s memory that is used to save, retrieve, and manipulate data.
				- ## Syntax
					- Minimally, a variable is declared by specifying a data type and a name:
						- ```c#
						  type name;
						  ```
						- In this case, the variable will be initialized with the default value for its type: zero for numeric types, and `null` for reference types.
					- A variable can also be initialized with a value when it is declared:
						- ```c#
						  type name = value;
						  ```
						- In this case, the variable `name` will be set to the value `value`.
					- > **Note:** `value` must be of type `type` or be able to be implicitly converted to `type`.
				- ## Example
					- We can declare variables on either two lines or one line:
						- Two lines:
						  ```c#
						  // Declare an integer
						  int myAge;
						  myAge = 32;
						  ```
						- One line:
						  ```c#
						  // Declare a string
						  string countryName = "Netherlands";
						  ```
					- ```c#
					  using System;
					  
					  public class Example
					  {
					    public static void Main(string[] args)
					    {
					      int x = 1;
					      int y = x + 5;
					      long z = y;
					  
					      Console.WriteLine("The int {0} can be implicitly converted to the long {1}.", y, z);
					  
					      // Output: "The int 6 can be implicitly converted to the long 6."
					    }
					  }
					  ```
		- [C# 10 Path | Pluralsight](https://app.pluralsight.com/paths/skills/c-10)
		  collapsed:: true
			- *Entry-level*
				- [C# 10: The Big Picture](https://app.pluralsight.com/courses/c30adffd-191f-482b-952b-14a0345ead92/table-of-contents)
				  collapsed:: true
					- ## Discovering C#
					  id:: 65478807-1a4d-40c4-bfb7-b9f1c5c59af9
					  collapsed:: true
						- Features
							- Approachable (syntactically to ((646349e5-6faa-4638-a681-e2218087d789)) and ((63e40d8d-784b-4c11-925c-5847395b972f)) developers)
							  collapsed:: true
								- Semi-colons `;` rather than new lines as statement terminators
								- Using curly braces `{ `/`}` to group blocks of code comprised of more than one statement that should be considered in the same scope
								- Object-oriented constructs such as namespaces, classes, methods and properties
								- `0`-based indexing when working with arrays
							- Strongly (Statically) Type
							  collapsed:: true
								- With compile-time type inference
								- Can dynamically infer type by using `var` instead of specifying a type
								  collapsed:: true
									- Can check it's working correctly by mouseover on `var` in ((63209272-1088-4824-a762-4ac7ded04b0a))
							- Resilient and Safe
								- With native performance
								- Safety e.g. creates an exception to help debug, rather than segfault and crash
							- Object-oriented and Functional Features
							  collapsed:: true
								- Example for object-oriented
								  collapsed:: true
									- ```c#
									  class program
									  {
									    static void Main()
									    {
									      var numbers = new int[] { 1, 2, 3, 4, 5 };
									    }
									  }
									  ```
								-
							- Open-source, cross-platform and general purpose
							  collapsed:: true
								- Available as FOSS since 2014
								- General purpose - desktop, mobile, web
					- ## Exploring Managed Execution in C#
					  collapsed:: true
						- ### Code Execution Models
						  id:: 654f8d76-d0c6-41b5-8714-90b265e041d1
						  collapsed:: true
							- Compiled / Native
								- Strong/static typing
								- Compile-time type safety
								  id:: 654fbaf3-e075-4345-8a08-c6c90cb8b9e7
								- Manual memory management
								  id:: 654fbaf7-8735-435e-a8fa-cfa54abd94ab
								- Fast(est) performance profile
								- Examples - ((640c8362-cdc6-44a3-b991-a338f1d05b5a))
								- Cons
									- Lack of resilience to change (see ((65478807-1a4d-40c4-bfb7-b9f1c5c59af9)) )
									- Lacks portability - need to use a different compiler for each target architecture
									- ((654fbaf7-8735-435e-a8fa-cfa54abd94ab)) - bug-prone
									- ((654fbaf3-e075-4345-8a08-c6c90cb8b9e7)) - can't detect errors until you actually try to compile
							- Managed / Execution Engine
								- Strong typing
								- Runtime type safety
								- Garbage collection
								- Native code performance
								- Examples - [[C#]], ((63e40d8d-784b-4c11-925c-5847395b972f))
							- Interpreted / Dynamic (REPL)
								- Loose/dynamic typing
								- Permissive runtime type conversion
								- Automatic memory management
								- Slow performance profile
								- Examples - ((629ccb26-9513-49ea-946c-5b33f145c698))
						- ### The CLR
						  id:: 654f8e3b-a59d-4bbe-8a74-81bed1592e08
						  collapsed:: true
						  AKA The Common Language Runtime
							- For .NET applications including C# ones the Execution Engine is known as the CLR (Common Language Runtime)
							- IL (Intermediary Language) is the common language all .NET compilers emit
							- Variations of CLR include:
								- .NET 6 - cross-platform, usually referred to as .NET
								- .NET Core / Mono
								- .NET Framework - legacy, Windows-only
							- Provides runtime-critical services such as JIT compilation and garbage collection that are essential for proper execution of all .NET applications
						- ### Just-In-Time (JIT) Compilation Revealed
						  collapsed:: true
							- This is how [[C#]] is able to get native code performance but with runtime type safety
							- ![Screenshot_20231111_191003.png](../assets/Screenshot_20231111_191003_1699729914062_0.png)
						- ### The BCLs
						  collapsed:: true
						  AKA The .NET Base Class Libraries
							- Base Class Libraries (BCLs) are the standard set of libraries included as part of a .NET installation
							- Unlike ((654f8e3b-a59d-4bbe-8a74-81bed1592e08)) this includes commonly-used but not required code
							- Includes text manipulation, file I/O, collection classes such as lists, queues and hash tables
						- By learning C# you learn the broader .NET platform
						  collapsed:: true
							- Includes other languages such as
								- F#
								- Visual Basic
							- All languages get converted into IL (Intermediary Language) before being compiled into machine code
						- ### Putting the CL in CLR
					- ## The Constant Evolution of C#
						- ### Top Level Programs
						  collapsed:: true
						  Since version 9
							- To make a hello world program
							- Before
								- ```c#
								  class Program
								  {
								    static void Main()
								    {
								      System.Console.WriteLine("Hello, world!");
								    }
								  }
								  ```
									- Does not support the notion of global functions
									- Functions always exist as methods on a type
									- Type in this case the Program class
									- Static method named Main is required
							- After
								- ```c#
								  System.Console.WriteLine("Hello, world!");
								  ```
									- As long as there's one source file in your project that leverages top-level statements
								- With command line `args`
								  ```c#
								  using System; 
								  
								  Console.WriteLine("Hello, world!");
								  
								  for (var n = 0; n > args.Length; n++)
								  {
								    Console.WriteLine($"args[{n}] = {args[n]}");
								  }
								  return 0;
								  ```
									- Since version 6 also string interpolation
						- ### Properties
						  collapsed:: true
							- Auto Properties mean we don't need to explicitly define private backing fields to hold the values we want to store
							- Init Properties (version 9)
						- ### Expression-bodied Members
						  Since version 6
							- Can be used to define the body of a type's members
						- ### Disposable Types
							- IDisposable
						- ### Relational Patterns
							- includes `switch` statements, `and`, `=>` fat arrow, `_` discard operator
					- [Learning Resources]
					  id:: 654f8d93-5a47-43db-a875-f8ac464fc412
						- [Microsoft Learn: Build skills that open doors in your career](https://docs.microsoft.com)
						- [.NET documentation | Microsoft Learn](https://docs.microsoft.com/en-gb/dotnet)
						- [C# docs - get started, tutorials, reference. | Microsoft Learn](https://docs.microsoft.com/en-gb/dotnet/csharp)
						- [GitHub - dotnet/core: Home repository for .NET Core](https://github.com/dotnet/core)
						- [GitHub - dotnet/csharplang: The official repo for the design of the C# programming language](https://github.com/dotnet/csharplang)
						- [dotnet/csharplang · Discussions · GitHub](https://github.com/dotnet/csharplang/discussions)
						- [.NET developer community | Meet with like-minded developers](https://dotnet.microsoft.com/platform/community)
						-
						- Other Pluralsight courses
							- C#: Getting Started by Paolo Perrotta
							- Introduction the C# Type System by Gill Cleeren
							- C# Extension Methods by Elton Stoneman
							- C# Language-Integrated Query (LINQ) by Paul D. Sheriff
							- .NET Class Libraries: The Big Picture by Matthew Soucoup
				- [C# 10 Fundamentals](https://app.pluralsight.com/library/courses/c-sharp-10-fundamentals/table-of-contents)
				  id:: 6547878f-7afb-4e72-98fe-3e28faa8377a
				  collapsed:: true
				  INCOMPLETE
					-
				- Debugging C# 10
				- Object-oriented Programming in C# 10
					-
			- *Practitioner*
				- Error Handling in C# 10
				- etc
			- *Advanced*
			- *Expert*
		- ((64400a8a-5cda-48bb-850a-572516e63317))
	- Completed learning resources (references)
		- [C# documentation](https://learn.microsoft.com/en-us/dotnet/csharp/)
		  collapsed:: true
			- 1) [Get started](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/)
			  id:: 643aaea3-1255-47c9-abe2-948d39fa1470
			  collapsed:: true
				- Notes
					- ## [Introduction](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/)
						- C# is a modern, object-oriented, and type-safe programming language
						- Language has roots in C, so will be familiar to C, C++, Java, and JavaScript programmers
						- Features
						  collapsed:: true
							- [**Garbage collection**](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/) automatically reclaims memory occupied by unreachable unused objects.
							- [**Nullable types**](https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references) guard against variables that don't refer to allocated objects.
							- [**Exception handling**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/) provides a structured and extensible approach to error detection and recovery.
							- [**Lambda expressions**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions) support functional programming techniques
							- [**Language Integrated Query (LINQ)**](https://learn.microsoft.com/en-us/dotnet/csharp/linq/) syntax creates a common pattern for working with data from any source.
							- Language support for [**asynchronous operations**](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/) provides syntax for building distributed systems
							- ((6463496d-d42a-4e5d-bfd3-c25979a00742))
							- All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.
							- All types share a set of common operations. Values of any type can be stored, transported, and operated upon in a consistent manner. Furthermore, C# supports both user-defined [reference types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types) and [value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types).
							- C# allows dynamic allocation of objects and in-line storage of lightweight structures.
							- C# supports generic methods and types, which provide increased type safety and performance.
							- C# provides iterators, which enable implementers of collection classes to define custom behaviors for client code.
						- ### Types and variables
						  collapsed:: true
							- A *variable* is a label that refers to an instance of a specific type.
							- An **identifier** is a variable name. An identifier is a sequence of unicode characters without any whitespace. An identifier may be a C# reserved word, if it's prefixed by `@`. Using a reserved word as an identifier can be useful when interacting with other languages.
							- Types
								- Meta
									- Differences between ((643af26a-8c2a-4835-9ca1-5cf007849274)) and ((3244e01c-d292-42f3-8e8c-8f6e616c4424))
									  collapsed:: true
										- Variables of value types directly contain their data. Variables of reference types store references to their data, the latter being known as objects.
										- With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.
										- With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).
								- [Value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types)
								  id:: 643af26a-8c2a-4835-9ca1-5cf007849274
									- [Simple types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types#built-in-value-types)
									  collapsed:: true
										- [Signed integral](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)
										  `sbyte`, `short`, `int`, `long`
										- [Unsigned integral](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)
										  `byte`, `ushort`, `uint`, `ulong`
										- [Unicode characters](https://learn.microsoft.com/en-us/dotnet/standard/base-types/character-encoding-introduction)
										  `char`, which represents a UTF-16 code unit
										- [IEEE binary floating-point](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)
										  `float`, `double`
										- [High-precision decimal floating-point](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)
										  `decimal`
										- Boolean
										  `bool`, which represents Boolean values—values that are either `true` or `false`
									- [Enum types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum)
									  id:: 4e17bd2a-51db-4f5e-ab56-e7363948d37c
									  collapsed:: true
									  User-defined types of the form `enum E {...}`.
										- An `enum` type is a distinct type with named constants. Every `enum` type has an underlying type, which must be one of the eight integral types. The set of values of an `enum` type is the same as the set of values of the underlying type.
									- [Struct types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct)
									  id:: d817704d-73a8-4144-9ae0-c992c687bc8c
									  collapsed:: true
									  User-defined types of the form `struct S {...}`
										- A `struct` type is similar to a class type in that it represents a structure with data members and function members. However, unlike classes, structs are value types and don't typically require heap allocation. Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.
									- [Nullable value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types)
									  collapsed:: true
									  Extensions of all other value types with a `null` value
										- Nullable types don't require a separate definition. For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`. For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.
									- [Tuple value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples)
									  id:: a557ab46-64e8-43c0-89bc-2148fd5fe66a
									  User-defined types of the form `(T1, T2, ...)`
								- [Reference types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types)
								  id:: 3244e01c-d292-42f3-8e8c-8f6e616c4424
									- [Class types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class)
									  id:: 43141a03-cbe4-4075-b211-45cd12b58e96
									  collapsed:: true
									  User-defined types of the form `class C {...}`
										- Ultimate base class of all other types: `object`
										- [Unicode strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/character-encoding-introduction): `string`, which represents a sequence of UTF-16 code units
										- A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others). Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.
									- [Interface types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface)
									  id:: 99bedac8-fcfa-41da-83cc-55d8cb912394
									  collapsed:: true
									  User-defined types of the form `interface I {...}`
										- An `interface` type defines a contract as a named set of public members. A `class` or `struct` that implements an `interface` must provide implementations of the interface's members. An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.
									- [Array types](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/)
									  collapsed:: true
									  Single-dimensional, multi-dimensional, and jagged. For example: `int[]`, `int[,]`, and `int[][]`
										- C# supports single-dimensional and multi-dimensional arrays of any type. Unlike the types listed above, array types don't have to be declared before they can be used. Instead, array types are constructed by following a type name with square brackets. For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of `int`.
									- [Delegate types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types#the-delegate-type)
									  id:: 1680483c-7ddb-40cb-96be-65f90312d208
									  collapsed:: true
									  User-defined types of the form `delegate int D(...)`
										- A `delegate` type represents references to methods with a particular parameter list and return type. Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters. Delegates are analogous to function types provided by functional languages. They're also similar to the concept of function pointers found in some other languages. Unlike function pointers, delegates are object-oriented and type-safe.
							- C# programs use *type declarations* to create new types. A type declaration specifies the name and the members of the new type.
							- 6 categories of types are user-definable:
								- ((4e17bd2a-51db-4f5e-ab56-e7363948d37c))
								- ((d817704d-73a8-4144-9ae0-c992c687bc8c))
								- ((a557ab46-64e8-43c0-89bc-2148fd5fe66a))
								- ((43141a03-cbe4-4075-b211-45cd12b58e96))
								- ((99bedac8-fcfa-41da-83cc-55d8cb912394))
								- ((1680483c-7ddb-40cb-96be-65f90312d208))
							- You can also declare `record` types, either `record struct`, or `record class`. Record types have compiler-synthesized members. You use records primarily for storing values, with minimal associated behavior.
							- These types support generics, whereby they can be parameterized with other types:
								- ((d817704d-73a8-4144-9ae0-c992c687bc8c))
								- ((43141a03-cbe4-4075-b211-45cd12b58e96))
								- ((99bedac8-fcfa-41da-83cc-55d8cb912394))
								- ((1680483c-7ddb-40cb-96be-65f90312d208))
							- C# has a [**unified type system**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/).
							  id:: 6463496d-d42a-4e5d-bfd3-c25979a00742
								- C#'s type system is unified such that a value of any type can be treated as an `object`. Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.
								- Values of reference types are treated as objects simply by viewing the values as type `object`.
								- Values of value types are treated as objects by performing *boxing* and *unboxing operations*.
									- In the following example, an `int` value is converted to `object` and back again to `int`:
									  id:: 643bdb01-3ba2-4ece-aaa8-da84dcab4a64
									  ```c#
									  int i = 123;
									  object o = i;    // Boxing
									  int j = (int)o;  // Unboxing
									  ```
									- When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value. That box is an instance of a reference type, and the value is copied into that box.
									- Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type. If the check succeeds, the value in the box is copied to the value type.
							- Every variable has a type that determines what values can be stored in the variable, as shown below.
								- Non-nullable value type
									- A value of that exact type
								- Nullable value type
									- A `null` value or a value of that exact type
								- object
									- A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type
								- Class type
									- A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type
								- Interface type
									- A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type
								- Array type
									- A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type
								- Delegate type
									- A `null` reference or a reference to an instance of a compatible delegate type
							-
						- ### Program structure
						  collapsed:: true
							- The key organizational concepts in C# are [**programs**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/), [**namespaces**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/namespaces), [**types**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/), [**members**](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members), and [**assemblies**](https://learn.microsoft.com/en-us/dotnet/standard/assembly/).
								- Programs declare types, which contain members and can be organized into namespaces.
								- Types include classes, structs, interfaces, etc.
								- Members include fields, methods, properties, events, etc. When C# programs are compiled, they're physically packaged into assemblies.
								- Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement **applications** or **libraries**, respectively.
							- Example assembly
								- ```c#
								  namespace Acme.Collections;
								  
								  public class Stack<T>
								  {
								      Entry _top;
								  
								      public void Push(T data)
								      {
								          _top = new Entry(_top, data);
								      }
								  
								      public T Pop()
								      {
								          if (_top == null)
								          {
								              throw new InvalidOperationException();
								          }
								          T result = _top.Data;
								          _top = _top.Next;
								  
								          return result;
								      }
								  
								      class Entry
								      {
								          public Entry Next { get; set; }
								          public T Data { get; set; }
								  
								          public Entry(Entry next, T data)
								          {
								              Next = next;
								              Data = data;
								          }
								      }
								  }
								  ```
									- The fully qualified name of this class is `Acme.Collections.Stack`. The class contains several members: a field named `_top`, two methods named `Push` and `Pop`, and a nested class named `Entry`. The `Entry` class further contains three members: a property named `Next`, a property named `Data`, and a constructor. The `Stack` is a *generic* class. It has one type parameter, `T` that is replaced with a concrete type when it's used.
									- A *stack* is a "first in - last out" (FILO) collection. New elements are added to the top of the stack. When an element is removed, it's removed from the top of the stack. The previous example declares the `Stack` type that defines the storage and behavior for a stack. You can declare a variable that refers to an instance of the `Stack` type to use that functionality.
							- Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata. Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.
								- Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#. The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.
								- For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:
									- ```c#
									  class Example
									  {
									      public static void Main()
									      {
									          var s = new Acme.Collections.Stack<int>();
									          s.Push(1); // stack contains 1
									          s.Push(10); // stack contains 1, 10
									          s.Push(100); // stack contains 1, 10, 100
									          Console.WriteLine(s.Pop()); // stack contains 1, 10
									          Console.WriteLine(s.Pop()); // stack contains 1
									          Console.WriteLine(s.Pop()); // stack is empty
									      }
									  }
									  ```
								- To compile this program, you would need to reference the assembly containing the stack class defined in the earlier example.
								  
								  C# programs can be stored in several source files. When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other. Conceptually, it's as if all the source files were concatenated into one large file before being processed. Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant. C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.
								- Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant. C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.
					- ## [Types and Members](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/types)
					  id:: 6463496d-287c-40c3-917d-f039c1b8e70a
						- As an object-oriented language, C# supports the concepts of encapsulation, inheritance, and polymorphism.
						  collapsed:: true
							- A class may inherit directly from one parent class, and it may implement any number of interfaces.
							- Polymorphism? - Methods that override virtual methods in a parent class require the `override` keyword as a way to avoid accidental redefinition.
							- A struct is like a lightweight class; it's a stack-allocated type that can implement interfaces but doesn't support inheritance. C# provides `record class` and `record struct` types, which are types whose purpose is primarily storing data values.
						- ### Classes and objects
						  collapsed:: true
							- A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit. A class provides a definition for *instances* of the class, also known as *objects*. Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.
							- New classes are created using class declarations. A class declaration starts with a header. The header specifies:
							  collapsed:: true
								- The attributes and modifiers of the class
								- The name of the class
								- The base class (when inheriting from a [base class](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/types#base-classes))
								- The interfaces implemented by the class.
							- The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.
							- Class example
							  collapsed:: true
								- ```c#
								  public class Point
								  {
								      public int X { get; }
								      public int Y { get; }
								      
								      public Point(int x, int y) => (X, Y) = (x, y);
								  }
								  ```
							- Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.
							  collapsed:: true
								- The following statements create two `Point` objects and store references to those objects in two variables:
								  ```c#
								  var p1 = new Point(0, 0);
								  var p2 = new Point(10, 20);
								  ```
							- #### Type parameters
							  collapsed:: true
								- Generic classes define [**type parameters**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics). Type parameters are a list of type parameter names enclosed in angle brackets. Type parameters follow the class name. The type parameters can then be used in the body of the class declarations to define the members of the class.
								  collapsed:: true
									- In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:
									  ```c#
									  public class Pair<TFirst, TSecond>
									  {
									      public TFirst First { get; }
									      public TSecond Second { get; }
									      
									      public Pair(TFirst first, TSecond second) => 
									          (First, Second) = (first, second);
									  }
									  ```
								- A class type that is declared to take type parameters is called a *generic class type*. Struct, interface, and delegate types can also be generic. When the generic class is used, type arguments must be provided for each of the type parameters:
								  collapsed:: true
									- ```c#
									  var pair = new Pair<int, string>(1, "two");
									  int i = pair.First;     //TFirst int
									  string s = pair.Second; //TSecond string
									  ```
									- A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.
							- #### Base classes
							  collapsed:: true
								- A class declaration may specify a base class.
								  collapsed:: true
									- Follow the class name and type parameters with a colon and the name of the base class. Omitting a base class specification is the same as deriving from type `object`.
									- In the following example, the base class of `Point3D` is `Point`. From the first example, the base class of `Point` is `object`:
									  id:: 643c463e-dcb9-4b23-893c-87b16ff6525d
									  collapsed:: true
										- id:: 643c4652-5ae9-47e8-a873-5f0205fc0a48
										  ```c#
										  public class Point3D : Point
										  {
										      public int Z { get; set; }
										      
										      public Point3D(int x, int y, int z) : base(x, y)
										      {
										          Z = z;
										      }
										  }
										  ```
								- A class inherits the members of its base class. Inheritance means that a class implicitly contains almost all members of its base class. A class doesn't inherit the instance and static constructors, and the finalizer. A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.
								  collapsed:: true
									- [In the previous example](((643c463e-dcb9-4b23-893c-87b16ff6525d))), `Point3D` inherits the `X` and `Y` members from `Point`, and every `Point3D` instance contains three properties, `X`, `Y`, and `Z`.
								- An implicit conversion exists from a class type to any of its base class types. A variable of a class type can reference an instance of that class or an instance of any derived class.
								  collapsed:: true
									- For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:
									  ```c#
									  Point a = new(10, 20);
									  Point b = new Point3D(10, 20, 30);
									  ```
						- ### Structs
						  collapsed:: true
							- Classes define types that support inheritance and polymorphism. They enable you to create sophisticated behaviors based on hierarchies of derived classes. By contrast, [**struct**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct) types are simpler types whose primary purpose is to store data values. Structs can't declare a base type; they implicitly derive from [System.ValueType](https://learn.microsoft.com/en-us/dotnet/api/system.valuetype). You can't derive other `struct` types from a `struct` type. They're implicitly sealed.
							- Example
							  collapsed:: true
								- ```c#
								  public struct Point
								  {
								      public double X { get; }
								      public double Y { get; }
								      
								      public Point(double x, double y) => (X, Y) = (x, y);
								  }
								  ```
						- ### Interfaces
						  collapsed:: true
							- An [**interface**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/interfaces) defines a contract that can be implemented by classes and structs. You define an *interface* to declare capabilities that are shared among distinct types. For example, the [System.Collections.Generic.IEnumerable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1) interface defines a consistent way to traverse all the items in a collection, such as an array. An interface can contain methods, properties, events, and indexers. An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.
							- Interfaces may employ **multiple inheritance**. In the following example, the interface `IComboBox` inherits from both `ITextBox` and `IListBox`.
							  collapsed:: true
								- ```c#
								  interface IControl
								  {
								      void Paint();
								  }
								  
								  interface ITextBox : IControl
								  {
								      void SetText(string text);
								  }
								  
								  interface IListBox : IControl
								  {
								      void SetItems(string[] items);
								  }
								  
								  interface IComboBox : ITextBox, IListBox { }
								  ```
							- Classes and structs can implement (utilise/inherit?) multiple interfaces. In the following example, the class `EditBox` implements both `IControl` and `IDataBound`.
							  collapsed:: true
								- ```c#
								  interface IDataBound
								  {
								      void Bind(Binder b);
								  }
								  
								  public class EditBox : IControl, IDataBound
								  {
								      public void Paint() { }
								      public void Bind(Binder b) { }
								  }
								  ```
							- When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type. For example
							  collapsed:: true
								- ```c#
								  EditBox editBox = new();
								  IControl control = editBox;
								  IDataBound dataBound = editBox;
								  ```
						- ### Enums
						  collapsed:: true
							- Also exists in ((629ccb26-1eab-4686-a7b8-f9433a871440))
							- An [**Enum**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum) type defines a set of constant values. The following `enum` declares constants that define different root vegetables:
							  collapsed:: true
								- ```c#
								  public enum SomeRootVegetable
								  {
								      HorseRadish,
								      Radish,
								      Turnip
								  }
								  ```
							- You can also define an `enum` to be used in combination as flags. The following declaration declares a set of flags for the four seasons. Any combination of the seasons may be applied, including an `All` value that includes all seasons:
							  collapsed:: true
								- ```c#
								  [Flags]
								  public enum Seasons
								  {
								      None = 0,
								      Summer = 1,
								      Autumn = 2,
								      Winter = 4,
								      Spring = 8,
								      All = Summer | Autumn | Winter | Spring
								  }
								  ```
							- The following example shows declarations of both the preceding enums:
							  collapsed:: true
								- ```c#
								  var turnip = SomeRootVegetable.Turnip;
								  
								  var spring = Seasons.Spring;
								  var startingOnEquinox = Seasons.Spring | Seasons.Autumn;
								  var theYear = Seasons.All;
								  ```
						- ### Nullable types
						  collapsed:: true
							- Variables of any type may be declared as **non-nullable** or **nullable**. A nullable variable can hold an additional `null` value, indicating no value. Nullable Value types (structs or enums) are represented by [System.Nullable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1). Non-nullable and Nullable Reference types are both represented by the underlying reference type. The distinction is represented by metadata read by the compiler and some libraries. The compiler provides warnings when nullable references are dereferenced without first checking their value against `null`. The compiler also provides warnings when non-nullable references are assigned a value that may be `null`. The following example declares a **nullable int**, initializing it to `null`. Then, it sets the value to `5`. It demonstrates the same concept with a **nullable string**. For more information, see [nullable value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types) and [nullable reference types](https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references).
							- ```c#
							  int? optionalInt = default; 
							  optionalInt = 5;
							  string? optionalText = default;
							  optionalText = "Hello World.";
							  ```
						- ### Tuples
						  collapsed:: true
							- C# supports [**tuples**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples), which provides concise syntax to group multiple data elements in a lightweight data structure. You instantiate a tuple by declaring the types and names of the members between `(` and `)`, as shown in the following example:
							- ```c#
							  (double Sum, int Count) t2 = (4.5, 3);
							  Console.WriteLine($"Sum of {t2.Count} elements is {t2.Sum}.");
							  //Output:
							  //Sum of 3 elements is 4.5.
							  ```
							- Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.
					- ## [Program building blocks](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/program-building-blocks)
					  id:: 64400a8a-5cda-48bb-850a-572516e63317
						- The types described in ((6463496d-287c-40c3-917d-f039c1b8e70a)) are built using these building blocks:
							- Members, such as properties, fields, methods, and events.
							- Expressions
							- Statements
						- ### Members
						  id:: 64f07c93-2539-4af9-99cb-7363a2105046
						  collapsed:: true
							- Intro
								- The members of a `class` are either **static members** or **instance members**. Static members belong to classes, and instance members belong to objects (instances of classes).
								- The following list provides an overview of the kinds of members a class can contain.
									- **Constants**: Constant values associated with the class
									- ((64f07dad-3a65-4e23-9b8d-c9966a9ece88)) - A variable that is associated with a class or with an instance of a class.
									- ((64f07db4-a0a5-4056-8a1d-e5997114ad54)) - Actions that can be performed by the class
									- ((64f0a783-cd94-45cb-950d-6b7593e355d0)) - Actions associated with reading and writing named properties of the class
									- ((64f0a7b3-bbca-4fa9-a7e6-b98328da288b)) - Actions associated with indexing instances of the class like an array
									- ((64f0a7e4-d4f5-40dd-b66d-a09c1177254c)) - Notifications that can be generated by the class
									- ((64f0a823-bd55-46e1-a221-18af0839abd9)) - Conversions and expression operators supported by the class
									- ((64f0a73f-d187-4c7d-ad86-1798d8eb5f2e)) - Actions required to initialize instances of the class or the class itself
									- ((64f0a84d-edf1-4a5d-a586-2c5889e6aa2a)) - Actions done before instances of the class are permanently discarded
									- **Types**: Nested types declared by the class
							- Accessibility
							  collapsed:: true
								- Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.
								- There are six possible forms of accessibility. The access modifiers are summarized below.
									- `public`: Access isn't limited.
									- `private`: Access is limited to this class.
									- `protected`: Access is limited to this class or classes derived from this class.
									- `internal`: Access is limited to the current assembly (`.exe` or `.dll`).
									- `protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.
									- `private protected`: Access is limited to this class or classes derived from this type within the same assembly.
							- #### Fields
							  id:: 64f07dad-3a65-4e23-9b8d-c9966a9ece88
							  collapsed:: true
							  A variable that is associated with a class or with an instance of a class.
								- A field declared with the static modifier defines a static field. A static field identifies exactly one storage location. No matter how many instances of a class are created, there's only ever one copy of a static field.
								- A field declared without the static modifier defines an instance field. Every instance of a class contains a separate copy of all the instance fields of that class.
								- In the following example, each instance of the `Color` class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:
								  collapsed:: true
									- ```c#
									  public class Color
									  {
									      public static readonly Color Black = new(0, 0, 0);
									      public static readonly Color White = new(255, 255, 255);
									      public static readonly Color Red = new(255, 0, 0);
									      public static readonly Color Green = new(0, 255, 0);
									      public static readonly Color Blue = new(0, 0, 255);
									      
									      public byte R;
									      public byte G;
									      public byte B;
									  
									      public Color(byte r, byte g, byte b)
									      {
									          R = r;
									          G = g;
									          B = b;
									      }
									  }
									  ```
									- As shown in the previous example, *read-only fields* may be declared with a `readonly`modifier. Assignment to a read-only field can only occur as part of the field's declaration or in a constructor in the same class.
							- #### Methods
							  id:: 64f07db4-a0a5-4056-8a1d-e5997114ad54
							  collapsed:: true
							  Actions that can be performed by the class
								- A *method* is a member that implements a computation or action that can be performed by an object or class. *Static methods* are accessed through the class. *Instance methods* are accessed through instances of the class.
								- Methods may have a list of *parameters*, which represent values or variable references passed to the method. Methods have a *return type*, which specifies the type of the value computed and returned by the method. A method's return type is `void` if it doesn't return a value.
								- Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called. Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.
								- The *signature* of a method must be unique in the class in which the method is declared. The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters. The signature of a method doesn't include the return type.
								- https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/program-building-blocks#methods
								- When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:
								  ```c#
								  public override string ToString() => "This is an object";
								  ```
								- **Parameters**
								  collapsed:: true
									- Parameters are used to pass values or variable references to methods. The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked. There are four kinds of  parameters: value parameters, reference parameters, output parameters, and parameter arrays.
									- A *value parameter* is used for passing input arguments. A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter. Modifications to a value parameter don't affect the argument that was passed for the parameter.
									- Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.
									- A *reference parameter* is used for passing arguments by reference. The argument passed for a reference parameter must be a variable with a definite value. During execution of the method, the reference parameter represents the same storage location as the argument variable. A reference parameter is declared with the `ref` modifier. The following example shows the use of `ref` parameters:
										- ```c#
										  static void Swap(ref int x, ref int y)
										  {
										      int temp = x;
										      x = y;
										      y = temp;
										  }
										  
										  public static void SwapExample()
										  {
										      int i = 1, j = 2;
										      Swap(ref i, ref j);
										      Console.WriteLine($"{i} {j}");    // "2 1"
										  }
										  ```
									- An *output parameter* is used for passing arguments by reference. It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument. An output parameter is declared with the `out` modifier. The following example shows the use of `out` parameters.
										- ```c#
										  static void Divide(int x, int y, out int quotient, out int remainder)
										  {
										      quotient = x / y;
										      remainder = x % y;
										  }
										  
										  public static void OutUsage()
										  {
										      Divide(10, 3, out int quo, out int rem);
										      Console.WriteLine($"{quo} {rem}");	// "3 1"
										  }
										  ```
									- A *parameter array* permits a variable number of arguments to be passed to a method. A parameter array is declared with the `params` modifier. Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type. The `Write` and `WriteLine` methods of the [System.Console](https://learn.microsoft.com/en-us/dotnet/api/system.console) class are good examples of parameter array usage. They're declared as follows:
										- ```c#
										  public class Console
										  {
										      public static void Write(string fmt, params object[] args) { }
										      public static void WriteLine(string fmt, params object[] args) { }
										      // ...
										  }
										  ```
									- Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type. However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array. In the latter case, an array instance is automatically created and initialized with the given arguments.
										- This example:
										  ```c#
										  int x, y, z;
										  x = 3;
										  y = 4;
										  z = 5;
										  Console.WriteLine("x={0} y={1} z={2}", x, y, z);
										  ```
										- is equivalent to writing the following:
											- ```c#
											  int x = 3, y = 4, z = 5;
											  
											  string s = "x={0} y={1} z={2}";
											  object[] args = new object[3];
											  args[0] = x;
											  args[1] = y;
											  args[2] = z;
											  Console.WriteLine(s, args);
											  ```
									-
								- **Method body and local variables**
								  collapsed:: true
									- A method's body specifies the statements to execute when the method is invoked.
									- A method body can declare variables that are specific to the invocation of the method. Such variables are called *local variables*. A local variable declaration specifies a type name, a variable name, and possibly an initial value. The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.
									- ```c#
									  class Squares
									  {
									      public static void WriteSquares()
									      {
									          int i = 0;
									          int j;
									          while (i < 10)
									          {
									              j = i * i;
									              Console.WriteLine($"{i} x {i} = {j}");
									              i++;
									          }
									      }
									  }
									  ```
									- C# requires a local variable to be *definitely assigned* before its value can be obtained. For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.
									- A method can use `return` statements to return control to its caller. In a method returning `void`, `return` statements can't specify an expression. In a method returning non-void, `return` statements must include an expression that computes the return value.
								- **Static and instance methods**
								  collapsed:: true
									- A method declared with a `static` modifier is a *static method*. A static method doesn't operate on a specific instance and can only directly access static members.
									- A method declared without a `static` modifier is an *instance method*.An instance method operates on a specific instance and can access both static and instance members. The instance on which an instance method was invoked can be explicitly accessed as `this`. It's an error to refer to `this` in a static method.
									- The following `Entity` class has both static and instance members:
									  collapsed:: true
										- ```c#
										  class Entity
										  {
										      static int s_nextSerialNo;
										      int _serialNo;
										      
										      public Entity()
										      {
										          _serialNo = s_nextSerialNo++;
										      }
										      
										      public int GetSerialNo()
										      {
										          return _serialNo;
										      }
										      
										      public static int GetNextSerialNo()
										      {
										          return s_nextSerialNo;
										      }
										      
										      public static void SetNextSerialNo(int value)
										      {
										          s_nextSerialNo = value;
										      }
										  }
										  ```
									- Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here). The `Entity`constructor (which is like an instance method) initializes the new instance with the next available serial number. Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.
									- The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.
									- The following example shows the use of the `Entity` class:
										- ```c#
										  Entity.SetNextSerialNo(1000);
										  Entity e1 = new();
										  Entity e2 = new();
										  Console.WriteLine(e1.GetSerialNo());          // Outputs "1000"
										  Console.WriteLine(e2.GetSerialNo());          // Outputs "1001"
										  Console.WriteLine(Entity.GetNextSerialNo());  // Outputs "1002"
										  ```
									- The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.
								- **Virtual, override, and abstract methods**
								  collapsed:: true
									- You use virtual, override, and abstract methods to define the behavior for a hierarchy of class types. Because a class can derive from a base class, those derived classes may need to modify the behaviour implemented in the base class. A **virtual** method is one declared and implemented in a base class where any derived class may provide a more specific implementation. An **override** method is a method implemented in a derived class that modifies the behaviour of the base class' implementation. An **abstract** method is a method declared in a base class that *must* be overridden in all derived classes. In fact, abstract methods don't define an implementation in the base class.
									- Method calls to instance methods may resolve to either base class or derived class implementations. The type of a variable determines its *compile-time type*. The *compile-time type* is the type the compiler uses to determine its members. However, a variable may be assigned to an instance of any type derived from its *compile-time type*. The *run-time type* is the type of the actual instance a variable refers to.
									- When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke. In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.
									- A virtual method can be *overridden* in a derived class. When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature. A virtual method declaration introduces a new method. An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.
									- An *abstract method* is a virtual method with no implementation. An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class. An abstract method must be overridden in every non-abstract derived class.
									- The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations. (This example is similar to, but not related to the expression tree types).
									  collapsed:: true
										- ```c#
										  public abstract class Expression
										  {
										      public abstract double Evaluate(Dictionary<string, object> vars);
										  }
										  
										  public class Constant : Expression
										  {
										      double _value;
										      
										      public Constant(double value)
										      {
										          _value = value;
										      }
										      
										      public override double Evaluate(Dictionary<string, object> vars)
										      {
										          return _value;
										      }
										  }
										  
										  public class VariableReference : Expression
										  {
										      string _name;
										      
										      public VariableReference(string name)
										      {
										          _name = name;
										      }
										      
										      public override double Evaluate(Dictionary<string, object> vars)
										      {
										          object value = vars[_name] ?? throw new Exception($"Unknown variable: {_name}");
										          return Convert.ToDouble(value);
										      }
										  }
										  
										  public class Operation : Expression
										  {
										      Expression _left;
										      char _op;
										      Expression _right;
										      
										      public Operation(Expression left, char op, Expression right)
										      {
										          _left = left;
										          _op = op;
										          _right = right;
										      }
										      
										      public override double Evaluate(Dictionary<string, object> vars)
										      {
										          double x = _left.Evaluate(vars);
										          double y = _right.Evaluate(vars);
										          switch (_op)
										          {
										              case '+': return x + y;
										              case '-': return x - y;
										              case '*': return x * y;
										              case '/': return x / y;
										              
										              default: throw new Exception("Unknown operator");
										          }
										      }
										  }
										  ```
									- The previous four classes can be used to model arithmetic expressions. For example, using instances of these classes, the expression `x + 3` can be represented as follows.
										- ```c#
										  Expression e = new Operation(
										      new VariableReference("x"),
										      '+',
										      new Constant(3));
										  ```
									- The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value. The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries). Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.
									- A `Constant`'s implementation of `Evaluate` simply returns the stored constant. A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value. An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.
									- The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.
									  collapsed:: true
										- ```c#
										  Expression e = new Operation(
										      new VariableReference("x"),
										      '*',
										      new Operation(
										          new VariableReference("y"),
										          '+',
										          new Constant(2)
										      )
										  );
										  Dictionary<string, object> vars = new();
										  vars["x"] = 3;
										  vars["y"] = 5;
										  Console.WriteLine(e.Evaluate(vars)); // "21"
										  vars["x"] = 1.5;
										  vars["y"] = 9;
										  Console.WriteLine(e.Evaluate(vars)); // "16.5"
										  ```
								- **Method overloading**
								  collapsed:: true
									- Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures. When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke. Overload resolution finds 
									  the one method that best matches the arguments. If no single best match can be found, an error is reported. The following example shows overload resolution in effect. The comment for each invocation in the `UsageExample` method shows which method is invoked.
										- ```c#
										  class OverloadingExample
										  {
										      static void F() => Console.WriteLine("F()");
										      static void F(object x) => Console.WriteLine("F(object)");
										      static void F(int x) => Console.WriteLine("F(int)");
										      static void F(double x) => Console.WriteLine("F(double)");
										      static void F<T>(T x) => Console.WriteLine($"F<T>(T), T is {typeof(T)}");            
										      static void F(double x, double y) => Console.WriteLine("F(double, double)");
										      
										      public static void UsageExample()
										      {
										          F();            // Invokes F()
										          F(1);           // Invokes F(int)
										          F(1.0);         // Invokes F(double)
										          F("abc");       // Invokes F<T>(T), T is System.String
										          F((double)1);   // Invokes F(double)
										          F((object)1);   // Invokes F(object)
										          F<int>(1);      // Invokes F<T>(T), T is System.Int32
										          F(1, 1);        // Invokes F(double, double)
										      }
										  }
										  ```
									- As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type 
									  arguments.
							- #### Other function members
								- Members that contain executable code are collectively known as the *function members* of a class. The preceding section describes methods, which are the 
								  primary types of function members. This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.
								- The following example shows a generic class called `MyList<T>`, which implements a growable list of objects. The class contains several examples of the most common kinds of function members.
								  collapsed:: true
									- ```c#
									  public class MyList<T>
									  {
									      const int DefaultCapacity = 4;
									  
									      T[] _items;
									      int _count;
									  
									      public MyList(int capacity = DefaultCapacity)
									      {
									          _items = new T[capacity];
									      }
									  
									      public int Count => _count;
									  
									      public int Capacity
									      {
									          get =>  _items.Length;
									          set
									          {
									              if (value < _count) value = _count;
									              if (value != _items.Length)
									              {
									                  T[] newItems = new T[value];
									                  Array.Copy(_items, 0, newItems, 0, _count);
									                  _items = newItems;
									              }
									          }
									      }
									  
									      public T this[int index]
									      {
									          get => _items[index];
									          set
									          {
									              if (!object.Equals(_items[index], value)) {
									                  _items[index] = value;
									                  OnChanged();
									              }
									          }
									      }
									  
									      public void Add(T item)
									      {
									          if (_count == Capacity) Capacity = _count * 2;
									          _items[_count] = item;
									          _count++;
									          OnChanged();
									      }
									      protected virtual void OnChanged() =>
									          Changed?.Invoke(this, EventArgs.Empty);
									  
									      public override bool Equals(object other) =>
									          Equals(this, other as MyList<T>);
									  
									      static bool Equals(MyList<T> a, MyList<T> b)
									      {
									          if (Object.ReferenceEquals(a, null)) return Object.ReferenceEquals(b, null);
									          if (Object.ReferenceEquals(b, null) || a._count != b._count)
									              return false;
									          for (int i = 0; i < a._count; i++)
									          {
									              if (!object.Equals(a._items[i], b._items[i]))
									              {
									                  return false;
									              }
									          }
									          return true;
									      }
									  
									      public event EventHandler Changed;
									  
									      public static bool operator ==(MyList<T> a, MyList<T> b) =>
									          Equals(a, b);
									  
									      public static bool operator !=(MyList<T> a, MyList<T> b) =>
									          !Equals(a, b);
									  }
									  ```
								- **Constructors**
								  id:: 64f0a73f-d187-4c7d-ad86-1798d8eb5f2e
								  collapsed:: true
								  Actions required to initialize instances of the class or the class itself
									- C# supports both instance and static constructors. An *instance constructor* is a member that implements the actions required to initialize an instance of a class. A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.
									- A constructor is declared like a method with no return type and the same name as the containing class. If a constructor declaration includes a `static` modifier, it declares a static constructor. Otherwise, it declares an instance constructor.
									- Instance constructors can be overloaded and can have optional parameters. For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter. Instance constructors are invoked using the `new` operator. The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.
									  collapsed:: true
										- ```c#
										  MyList<string> list1 = new();
										  MyList<string> list2 = new(10);
										  ```
									- Unlike other members, instance constructors aren't inherited. A class has no instance constructors other than those constructors actually declared in the class. If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.
								- **Properties**
								  id:: 64f0a783-cd94-45cb-950d-6b7593e355d0
								  collapsed:: true
								  Actions associated with reading and writing named properties of the class
									- *Properties* are a natural extension of fields. Both are named members with associated types, and the syntax for accessing fields and properties is the same. However, unlike fields, properties don't denote storage locations. Instead, properties have *accessors* that specify the statements executed when their values are read or written. A *get accessor* reads the value. A *set accessor* writes the value.
									- A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon. A property that has both a get accessor and a set accessor is a *read-write property*. A property that has only a get accessor is a *read-only property*. A property that has only a set accessor is a *write-only property*.
									- A get accessor corresponds to a parameterless method with a return value of the property type. A set accessor corresponds to a method with a single parameter named value and no return type. The get accessor computes the value of the property. The set accessor provides a new value for the property. When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked. In other cases where the property is referenced, the get accessor is invoked.
									- The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively. The following code is an example of use of these properties:
									  collapsed:: true
										- ```c#
										  MyList<string> names = new();
										  names.Capacity = 100;   // Invokes set accessor
										  int i = names.Count;    // Invokes get accessor
										  int j = names.Capacity; // Invokes get accessor
										  ```
									- Similar to fields and methods, C# supports both instance properties and static properties. Static properties are declared with the static modifier, and instance properties are declared without it.
									- The accessor(s) of a property can be virtual. When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.
								- **Indexers**
								  id:: 64f0a7b3-bbca-4fa9-a7e6-b98328da288b
								  collapsed:: true
								  Actions associated with indexing instances of the class like an array
									- An *indexer* is a member that enables objects to be indexed in the same way as an array. An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`. The parameters are available in the accessor(s) of the indexer. Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.
									- The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter. The indexer makes it possible to index `MyList<T>` instances with `int` values. For example:
									  collapsed:: true
										- ```c#
										  MyList<string> names = new();
										  names.Add("Liz");
										  names.Add("Martha");
										  names.Add("Beth");
										  for (int i = 0; i < names.Count; i++)
										  {
										      string s = names[i];
										      names[i] = s.ToUpper();
										  }
										  ```
									- Indexers can be overloaded. A class can declare multiple indexers as long as the number or types of their parameters differ.
								- **Events**
								  id:: 64f0a7e4-d4f5-40dd-b66d-a09c1177254c
								  collapsed:: true
								  Notifications that can be generated by the class
									- An *event* is a member that enables a class or object to provide notifications. An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.
									- Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors). The field stores a reference to a delegate that represents the event handlers that have been added to the event. If no event handlers are present, the field is `null`.
									- The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list or a list item has been changed using the indexer set accessor. The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null`
									  (meaning that no handlers are present). The notion of raising an event is precisely equivalent to invoking the delegate represented by the event. There are no special language constructs for raising events.
									- Clients react to events through *event handlers*. Event handlers are attached using the `+=` operator and removed using the `-=` operator. The following example attaches an event handler to the `Changed` event of a `MyList<string>`.
									  collapsed:: true
										- ```c#
										  class EventExample
										  {
										      static int s_changeCount;
										      
										      static void ListChanged(object sender, EventArgs e)
										      {
										          s_changeCount++;
										      }
										      
										      public static void Usage()
										      {
										          var names = new MyList<string>();
										          names.Changed += new EventHandler(ListChanged);
										          names.Add("Liz");
										          names.Add("Martha");
										          names.Add("Beth");
										          Console.WriteLine(s_changeCount); // "3"
										      }
										  }
										  ```
									- For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.
								- **Operators**
								  id:: 64f0a823-bd55-46e1-a221-18af0839abd9
								  collapsed:: true
								  Conversions and expression operators supported by the class
									- An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class. Three kinds of operators can be defined: unary operators, binary operators, and conversion operators. All operators must be declared as `public` and `static`.
									- The `MyList<T>` class declares two operators, `operator ==` and `operator !=`. These overridden operators give new meaning to expressions that apply those operators to `MyList` instances. Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods. The following example uses the `==` operator to compare two `MyList<int>` instances.
									  collapsed:: true
										- ```c#
										  MyList<int> a = new();
										  a.Add(1);
										  a.Add(2);
										  MyList<int> b = new();
										  b.Add(1);
										  b.Add(2);
										  Console.WriteLine(a == b);  // Outputs "True"
										  b.Add(3);
										  Console.WriteLine(a == b);  // Outputs "False"
										  ```
									- The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order. Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.
								- **Finalizers**
								  id:: 64f0a84d-edf1-4a5d-a586-2c5889e6aa2a
								  collapsed:: true
								  Actions done before instances of the class are permanently discarded
									- A *finalizer* is a member that implements the actions required to finalize an instance of a class. Typically, a finalizer is needed to release unmanaged resources. Finalizers can't have parameters, they  can't have accessibility modifiers, and they can't be invoked explicitly. The finalizer for an instance is invoked automatically during garbage collection. For more information, see the article on [finalizers](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers).
									- The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers. Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread. For these and other reasons, classes should implement finalizers only when no other solutions are feasible.
									- The `using` statement provides a better approach to object destruction.
						- ### Expressions
						  collapsed:: true
							- *Expressions* are constructed from *operands* and *operators*. The operators of an expression indicate which operations to apply to the operands. Examples of operators include `+`, `-`, `*`, `/`, and `new`. Examples of operands include literals, fields, local variables, and expressions.
							- When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated. For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.
							- When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:
								- Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right. For example, `x + y + z` is evaluated as `(x + y) + z`.
								- The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left. For example, `x = y = z` is evaluated as `x = (y = z)`.
							- Precedence and associativity can be controlled using parentheses. For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.
							- Most operators can be [*overloaded*](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading). Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.
							- C# provides operators to perform [arithmetic](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/arithmetic-operators), [logical](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/boolean-logical-operators), [bitwise and shift](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators) operations and [equality](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators) and [order](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/comparison-operators) comparisons.
							- For the complete list of C# operators ordered by precedence level, see [C# operators](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/).
						- ### Statements
						  collapsed:: true
							- The actions of a program are expressed using *statements*. C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.
								- A *block* permits multiple statements to be written in contexts where a single statement is allowed. A block consists of a list of statements written between the delimiters `{` and `}`.
								- *Declaration statements* are used to declare local variables and constants.
								- *Expression statements* are used to evaluate expressions. Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.
								- *Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression. This group contains the `if` and `switch` statements.
								- *Iteration statements* are used to execute repeatedly an embedded statement. This group contains the `while`, `do`, `for`, and `foreach` statements.
								- *Jump statements* are used to transfer control. This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.
								- The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.
								- The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.
								- The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.
								- The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.
							- The following lists the kinds of statements that can be used:
								- Local variable declaration.
								- Local constant declaration.
								- Expression statement.
								- `if` statement.
								- `switch` statement.
								- `while` statement.
								- `do` statement.
								- `for` statement.
								- `foreach` statement.
								- `break` statement.
								- `continue` statement.
								- `goto` statement.
								- `return` statement.
								- `yield` statement.
								- `throw` statements and `try` statements.
								- `checked` and `unchecked` statements.
								- `lock` statement.
								- `using` statement.
					- ## [Major language areas](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/features)
						- ### Arrays, collections and LINQ
						  collapsed:: true
							- C# and .NET provide many different collection types. Arrays have syntax defined by the language. Generic collection types are listed in the [System.Collections.Generic](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic) namespace. Specialized collections include [System.Span<T>](https://learn.microsoft.com/en-us/dotnet/api/system.span-1) for accessing continuous memory on the stack frame, and [System.Memory<T>](https://learn.microsoft.com/en-us/dotnet/api/system.memory-1) for accessing continuous memory on the managed heap. All collections, including arrays, [Span<T>](https://learn.microsoft.com/en-us/dotnet/api/system.span-1), and [Memory<T>](https://learn.microsoft.com/en-us/dotnet/api/system.memory-1) share a unifying principle for iteration. You use the [System.Collections.Generic.IEnumerable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1) interface. This unifying principle means that any of the collection types can be used with LINQ queries or other algorithms. You write methods using [IEnumerable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1) and those algorithms work with any collection.
							- #### Arrays
							  collapsed:: true
								- An [**array**](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/) is a data structure that contains a number of variables that are accessed through computed indices. The variables contained in an array, also called the **elements** of the array, are all of the same type. This type is called the **element type** of the array.
								- Array types are reference types, and the declaration of an array variable simply sets aside space for a reference to an array instance. Actual array instances are created dynamically at run time using the `new` operator. The `new` operation specifies the **length** of the new array instance, which is then fixed for the lifetime of the instance. The indices of the elements of an array range from `0` to `Length - 1`. The `new`operator automatically initializes the elements of an array to their default value, which, for example, is zero for all numeric types and `null` for all reference types.
								- The following example creates an array of `int` elements, initializes the array, and prints the contents of the array.
								  collapsed:: true
									- ```c#
									  int[] a = new int[10];
									  for (int i = 0; i < a.Length; i++)
									  {
									      a[i] = i * i;
									  }
									  for (int i = 0; i < a.Length; i++)
									  {
									      Console.WriteLine($"a[{i}] = {a[i]}");
									  }
									  ```
								- This example creates and operates on a **single-dimensional array**. C# also supports **multi-dimensional arrays**. The number of dimensions of an array type, also known as the **rank** of the array type, is one plus the number of commas between the square brackets of the array type. The following example allocates a 
								  collapsed:: true
								  single-dimensional, a two-dimensional, and a three-dimensional array, respectively.
									- ```c#
									  int[] a1 = new int[10];
									  int[,] a2 = new int[10, 5];
									  int[,,] a3 = new int[10, 5, 2];
									  ```
								- The `a1` array contains 10 elements, the `a2` array contains 50 (10 × 5) elements, and the `a3` array contains 100 (10 × 5 × 2) elements. The element type of an array can be any type, including an array type. An array with elements of an array type is sometimes called a **jagged array** because the lengths of the element arrays don't all have to be the same. The following example allocates an array of arrays of `int`:
								  collapsed:: true
									- ```c#
									  int[][] a = new int[3][];
									  a[0] = new int[10];
									  a[1] = new int[5];
									  a[2] = new int[20];
									  ```
								- The first line creates an array with three elements, each of type `int[]` and each with an initial value of `null`. The next lines then initialize the three elements with references to individual array instances of varying lengths.
								- The `new` operator permits the initial values of the array elements to be specified using an **array initializer**, which is a list of expressions written between the delimiters `{` and `}`. The following example allocates and initializes an `int[]` with three elements.
								  collapsed:: true
									- ```c#
									  int[] a = new int[] { 1, 2, 3 };
									  ```
								- The length of the array is inferred from the number of expressions between `{` and `}`. Array initialization can be shortened further such that the array type doesn't have to be restated.
								  collapsed:: true
									- ```c#
									  int[] a = { 1, 2, 3 };
									  ```
								- Both of the previous examples are equivalent to the following code:
								  collapsed:: true
									- ```c#
									  int[] t = new int[3];
									  t[0] = 1;
									  t[1] = 2;
									  t[2] = 3;
									  int[] a = t;
									  ```
								- The `foreach` statement can be used to enumerate the elements of any collection. The following code enumerates the array from the preceding example:
								  collapsed:: true
									- ```c#
									  foreach (int item in a)
									  {
									      Console.WriteLine(item);
									  }
									  ```
								- The `foreach` statement uses the [IEnumerable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1) interface, so it can work with any collection.
						- ### String interpolation
						  id:: 64f0ad1c-0b89-4c2b-b2c6-295f9c2fa70e
						  collapsed:: true
							- C# [**string interpolation**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated) enables you to format strings by defining expressions whose results are placed in a format string. For example, the following example prints the temperature on a given day from a set of weather data:
								- ```c#
								  Console.WriteLine($"The low and high temperature on {weatherData.Date:MM-dd-yyyy}");
								  Console.WriteLine($"    was {weatherData.LowTemp} and {weatherData.HighTemp}.");
								  // Output (similar to):
								  // The low and high temperature on 08-11-2020
								  //     was 5 and 30.
								  ```
							- An interpolated string is declared using the `$` token. String interpolation evaluates the expressions between `{` and `}`, then converts the result to a `string`, and replaces the text between the brackets with the string result of the expression. The `:` in the first expression, `{weatherData.Date:MM-dd-yyyy}` specifies the *format string*. In the preceding example, it specifies that the date should be printed in "MM-dd-yyyy" format.
							- Related: ((642714a5-1d61-4067-a9fd-87d003c13a07)) : ((65b38f28-ea69-4c1f-a162-1f62f3aa1726))
						- ### Pattern matching
						  collapsed:: true
							- The C# language provides [**pattern matching**](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching) expressions to query the state of an object and execute code based on that state. You can inspect types and the values of properties and fields to determine which action to take. You can inspect the elements of a list or array as well. The `switch` expression is the primary expression for pattern matching.
						- ### Delegates and lambda expressions
						  collapsed:: true
							- A [**delegate type**](https://learn.microsoft.com/en-us/dotnet/csharp/delegates-overview) represents references to methods with a particular parameter list and 
							  return type. Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters. Delegates are similar to the concept of function pointers found in some other languages. Unlike function pointers, delegates are object-oriented and type-safe.
							- The following example declares and uses a delegate type named `Function`.
							  collapsed:: true
								- ```c#
								  delegate double Function(double x);
								  
								  class Multiplier
								  {
								      double _factor;
								  
								      public Multiplier(double factor) => _factor = factor;
								  
								      public double Multiply(double x) => x * _factor;
								  }
								  
								  class DelegateExample
								  {
								      static double[] Apply(double[] a, Function f)
								      {
								          var result = new double[a.Length];
								          for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
								          return result;
								      }
								  
								      public static void Main()
								      {
								          double[] a = { 0.0, 0.5, 1.0 };
								          double[] squares = Apply(a, (x) => x * x);
								          double[] sines = Apply(a, Math.Sin);
								          Multiplier m = new(2.0);
								          double[] doubles = Apply(a, m.Multiply);
								      }
								  }
								  ```
							- An instance of the `Function` delegate type can reference any method that takes a `double` argument and returns a `double` value. The `Apply` method applies a given `Function` to the elements of a `double[]`, returning a `double[]` with the results. In the `Main` method, `Apply` is used to apply three different functions to a `double[]`.
							- A delegate can reference either a lambda expression to create an anonymous function (such as `(x) => x * x` in the previous example), a static method (such as `Math.Sin` in the previous example) or an instance method (such as `m.Multiply`in the previous example). A delegate that references an instance method
							  also references a particular object, and when the instance method is invoked through the delegate, that object becomes `this` in the invocation.
							- Delegates can also be created using anonymous functions or lambda expressions, which are "inline methods" that are created when declared. Anonymous functions can see the local variables of the surrounding methods. The following example doesn't create a class:
							  collapsed:: true
								- ```c#
								  double[] doubles = Apply(a, (double x) => x * 2.0);
								  ```
							- A delegate doesn't know or care about the class of the method it references. The referenced method must have the same parameters and return type as the delegate.
						- ### async / await
						  collapsed:: true
							- C# supports asynchronous programs with two keywords: `async` and `await`. You add the `async` modifier to a method declaration to declare the method is asynchronous. The `await` operator tells the compiler to asynchronously await for a result to finish. Control is returned to the caller, and the method returns a 
							  collapsed:: true
							  structure that manages the state of the asynchronous work. The structure is typically a [System.Threading.Tasks.Task<TResult>](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1), but can be any type that supports the awaiter pattern. These features enable you to write code that reads as its synchronous counterpart, but executes asynchronously. For example, the following code downloads the home page for [Microsoft docs](https://learn.microsoft.com/en-us/):
								- ```c#
								  public async Task<int> RetrieveDocsHomePage()
								  {
								      var client = new HttpClient();
								      byte[] content = await client.GetByteArrayAsync("[Content Issue](https://learn.microsoft.com/");)
								  
								      Console.WriteLine($"{nameof(RetrieveDocsHomePage)}: Finished downloading.");
								      return content.Length;
								  }
								  ```
							- This small sample shows the major features for asynchronous programming:
							  collapsed:: true
								- The method declaration includes the `async` modifier.
								- The body of the method `await`s the return of the `GetByteArrayAsync` method.
								- The type specified in the `return` statement matches the type argument in the `Task<T>` declaration for the method. (A method that returns a `Task` would use `return` statements without any argument).
						- ### Attributes
						  collapsed:: true
							- Types, members, and other entities in a C# program support modifiers that control certain aspects of their behavior. For example, the accessibility of a method is controlled using the `public`, `protected`, `internal`, and `private`modifiers. C# generalizes this capability such that user-defined types of declarative information can be attached to program entities and retrieved at run-time. Programs specify this declarative information by defining and using [**attributes**](https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/reflection-and-attributes).
							- The following example declares a `HelpAttribute` attribute that can be placed on program entities to provide links to their associated documentation.
							  collapsed:: true
								- ```c#
								  public class HelpAttribute : Attribute
								  {
								      string _url;
								      string _topic;
								  
								      public HelpAttribute(string url) => _url = url;
								  
								      public string Url => _url;
								  
								      public string Topic
								      {
								          get => _topic;
								          set => _topic = value;
								      }
								  }
								  ```
							- All attribute classes derive from the [Attribute](https://learn.microsoft.com/en-us/dotnet/api/system.attribute) base class provided by the .NET library. Attributes can be applied by giving their name, along with any arguments, inside square brackets just before the associated declaration. If an attribute's name ends in `Attribute`, that part of the name can be omitted when the attribute is referenced. For example, the `HelpAttribute` can be used as follows.
							  collapsed:: true
								- ```c#
								  [Help("[Content Issue](https://learn.microsoft.com/dotnet/csharp/tour-of-csharp/features")])
								  public class Widget
								  {
								      [Help("[Content Issue](https://learn.microsoft.com/dotnet/csharp/tour-of-csharp/features",)
								      Topic = "Display")]
								      public void Display(string text) { }
								  }
								  ```
							- This example attaches a `HelpAttribute` to the `Widget` class. It adds another `HelpAttribute` to the `Display`method in the class. The public constructors of an attribute class control the information that must be provided when the attribute is attached to a program entity. Additional information can be provided by 
							  referencing public read-write properties of the attribute class (such as the reference to the `Topic` property previously).
							- The metadata defined by attributes can be read and manipulated at run time using reflection. When a particular attribute is requested using this technique, the constructor for the attribute class is invoked with the information provided in the program source. The resulting attribute instance is returned. If additional information was provided through properties, those properties are set to the given values before the attribute instance is returned.
							- The following code sample demonstrates how to get the `HelpAttribute` instances associated to the `Widget` class and its `Display` method:
							  collapsed:: true
								- ```c#
								  Type widgetType = typeof(Widget);
								  
								  object[] widgetClassAttributes = widgetType.GetCustomAttributes(typeof(HelpAttribute), false);
								  
								  if (widgetClassAttributes.Length > 0)
								  {
								      HelpAttribute attr = (HelpAttribute)widgetClassAttributes[0];
								      Console.WriteLine($"Widget class help URL : {attr.Url} - Related topic : {attr.Topic}");
								  }
								  
								  System.Reflection.MethodInfo displayMethod = widgetType.GetMethod(nameof(Widget.Display));
								  
								  object[] displayMethodAttributes = displayMethod.GetCustomAttributes(typeof(HelpAttribute), false);
								  
								  if (displayMethodAttributes.Length > 0)
								  {
								      HelpAttribute attr = (HelpAttribute)displayMethodAttributes[0];
								      Console.WriteLine($"Display method help URL : {attr.Url} - Related topic : {attr.Topic}");
								  }
								  ```
							-
				- [Tutorials](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/)
				  id:: 643a7b39-a636-4105-a23f-49fc662cdd4f
				  collapsed:: true
					- [Hello World](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/hello-world) - added notes to ((643a7f7d-e036-4029-9342-498f14235cdb))
					  collapsed:: true
						- Example
							- ```c#
							  using System;
							  
							  class Hello
							  {
							      static void Main()
							      {
							          // This line prints "Hello, World" 
							          Console.WriteLine("Hello, World");
							      }
							  }
							  ```
								- Namespaces and `using`
									- `using` directive that references the `System` namespace. Namespaces provide a hierarchical means of organizing C# programs and libraries. Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and many other namespaces, such as `IO` and `Collections`.
									- A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace. Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.
									- Alternatively without `using System`:
									  collapsed:: true
										- ```c#
										  class Hello
										  {
										      static void Main()
										      {
										          // This line prints "Hello, World" 
										          System.Console.WriteLine("Hello, World");
										      }
										  }
										  ```
								- `Main` is a method, declared with a `static` modifier
									- By convention, a static method named `Main` serves as the entry point of a C# program.
									- While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.
								- ((643aaea3-e008-4339-98a5-42d23d0eec80))
					- [Numbers in C#](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/numbers-in-csharp)
					- [Branches and loops](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/branches-and-loops)
					- [Data collections](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/list-collection)
					- [101 Linq Samples](https://github.com/dotnet/try-samples/tree/main/101-linq-samples)
						- This sample requires the [dotnet-try](https://github.com/dotnet/try/blob/main/README.md#setup) global tool. Once you install the tool, and clone the [try-samples](https://github.com/dotnet/try-samples) repo, you can learn Language Integrated Query (LINQ) through a set of 101 samples you can run interactively. You can explore different ways to query, explore, and transform data sequences.
			- 2) Fundamentals
			  id:: 6463496d-822c-447a-8c11-a21b44348fdd
			  collapsed:: true
				- Notes
					- ## [Program structure](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/)
					- ## [Type system](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/)
					- ## Object-oriented programming
					- ## Functional techniques
					- ## Exceptions and errors
					- ## Coding style
				- Tutorials
				  id:: 6463496d-b165-4d8b-8d84-654376a37512
					- [How to display command-line arguments](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/how-to-display-command-line-arguments)
					- [Introduction to classes](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/classes)
					- [Object-oriented C#](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop)
					- [Inheritance in C# and .NET](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance)
					- [Converting types](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/safely-cast-using-pattern-matching-is-and-as-operators)
					- [Build data-driven algorithms with pattern matching](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/pattern-matching)
					- [How to handle an exception using try-catch](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/how-to-handle-an-exception-using-try-catch)
					- [How to execute cleanup code using finally](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/how-to-execute-cleanup-code-using-finally)
			- 3) What's new in [[C#]]
			  id:: 6463496d-d38a-4a73-995d-a03a0b4c9ea8
			  collapsed:: true
				- Notes
					- C# 12
					- C# 11
					- C# 10
					- C# 9.0
					- Relationships to .NET library
				- Tutorials
				  id:: 6463496d-1426-4bfd-a939-1f3c12ae8501
					- [Explore static interface members](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members)
					- [Explore record types](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/records)
					- [Explore top-level statements](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements)
					- [Explore patterns in objects](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/patterns-objects)
					- [Write a custom string interpolation handler](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/interpolated-string-handler)
			- 4) Tutorials
			  collapsed:: true
				- Earlier tutorials
					- ((643aaea3-1255-47c9-abe2-948d39fa1470)) : ((643a7b39-a636-4105-a23f-49fc662cdd4f))
					  collapsed:: true
						- {{embed ((643a7b39-a636-4105-a23f-49fc662cdd4f))}}
					- ((6463496d-822c-447a-8c11-a21b44348fdd)) : ((6463496d-b165-4d8b-8d84-654376a37512))
					- ((6463496d-d38a-4a73-995d-a03a0b4c9ea8)) : ((6463496d-1426-4bfd-a939-1f3c12ae8501))
				- [Explore indexes and ranges](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes)
				- [Work with nullable reference types](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/nullable-reference-types)
				- [Explore string interpolation - interactive](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/exploration/interpolated-strings)
				- [Explore string interpolation - in your environment](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/exploration/interpolated-strings-local)
				- [Advanced scenarios for string Interpolation](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/string-interpolation)
				- [Console Application](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/console-teleprompter)
				- [REST Client](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/console-webapiclient)
				- [Work with LINQ](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/working-with-linq)
			- ..
			- [C# Programming Guide](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/)
			  id:: 643aaea3-1dfd-4793-a1f6-4ba2cf253944
			  collapsed:: true
				- Programming concepts
				- Statements, expressions and equality
				- Types
				- Classes, Structs and Records
					- Polymorphism
					- Members
						- [Access Modifiers](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)
						  id:: 643c4a4f-98cc-404b-beff-d58e8266009c
						  collapsed:: true
							- All types and type members have an accessibility level. The accessibility level controls whether they can be used from other code in your assembly or other assemblies. An [assembly](https://learn.microsoft.com/en-us/dotnet/standard/glossary#assembly) is a *.dll* or *.exe* created by compiling one or more *.cs* files in a single compilation. Use the following access modifiers to specify the accessibility of a type or member when you declare it:
								- [public](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public): The type or member can be accessed by any other code in the same assembly or another assembly that references it. The accessibility level of public members of a type is controlled by the accessibility level of the type itself.
								- [private](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private): The type or member can be accessed only by code in the same `class` or `struct`.
								- [protected](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected): The type or member can be accessed only by code in the same `class`, or in a `class` that is derived from that `class`.
								- [internal](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/internal): The type or member can be accessed by any code in the same assembly, but not from another assembly. In other words, `internal` types or members can be accessed from code that is part of the same compilation.
								- [protected internal](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal): The type or member can be accessed by any code in the assembly in which it's declared, or from within a derived `class` in another assembly.
								- [private protected](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private-protected): The type or member can be accessed by types derived from the `class` that are declared within its containing assembly.
							- Summary table
								- ![image.png](../assets/image_1681672897319_0.png)
							- See webpage for more info
							- Related: ((643c49e4-393a-4dc9-ae4d-1cb5f1a05481))
				- Interfaces
				- Delegates
				- Strings
					- [Programming with strings](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/strings)
						- ...
						- [Format strings](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/strings/#format-strings)
							- ...
							- Composite formatting
							  id:: 661ae869-e18d-410e-b6d0-9247d7f2e20a
							  AKA string formatting
								- The [String.Format](https://learn.microsoft.com/en-us/dotnet/api/system.string.format) utilizes placeholders in braces to create a format string. This example results in similar output to the string interpolation method used 
								  above.
								- ```C#
								  var pw = (firstName: "Phillis", lastName: "Wheatley", born: 1753, published: 1773);
								  Console.WriteLine("{0} {1} was an African American poet born in {2}.", pw.firstName, pw.lastName, pw.born);
								  Console.WriteLine("She was first published in {0} at the age of {1}.", pw.published, pw.published - pw.born);
								  Console.WriteLine("She'd be over {0} years old today.", Math.Round((2018d - pw.born) / 100d) * 100d);
								  - // Output:
								  // Phillis Wheatley was an African American poet born in 1753.
								  // She was first published in 1773 at the age of 20.
								  // She'd be over 300 years old today.
								  ```
							- For more information on formatting .NET types, see [Formatting Types in .NET](https://learn.microsoft.com/en-us/dotnet/standard/base-types/formatting-types).
				- Indexers
				- Events
				- Generics
			- [C# reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/)
			  collapsed:: true
			  Incomplete
				- Overview
				- Configure language version
				- Types
				- Keywords
					- Modifiers
						- Access Modifiers
						  id:: 643c49e4-393a-4dc9-ae4d-1cb5f1a05481
						  collapsed:: true
							- [Quick reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers)
							  id:: 643c49ed-6772-4f80-a99a-911b967b48b6
							  collapsed:: true
								- Access modifiers are keywords used to specify the declared accessibility of a member or a type. This section introduces the five access modifiers:
									- `public`
									- `protected`
									- `internal`
									- `private`
									- `file`
								- Declaring an access modifier isn't mandatory, but the default is `private`
								- The following seven accessibility levels can be specified using the access modifiers:
									- [`public`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public): Access isn't restricted.
										- e.g. if you have a `public class` in a particular namespace, now it'll be accessible to other classes in the same namespace without need to use a `using` statement or fully-qualify the class name with its namespace
									- [`protected`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected): Access is limited to the containing class or types derived from the containing class.
									- [`internal`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/internal): Access is limited to the current assembly.
									- [`protected internal`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal): Access is limited to the current assembly or types derived from the containing class.
									- [`private`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private): Access is limited to the containing type.
									- [`private protected`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private-protected): Access is limited to the containing class or types derived from the containing class within the current assembly.
									- [`file`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/file): The declared type is only visible in the current source file. File scoped types are generally used for source generators.
								- This section also introduces the following concepts:
									- [Accessibility Levels](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels): Using the four access modifiers to declare six levels of accessibility.
									- [Accessibility Domain](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-domain): Specifies where, in the program sections, a member can be referenced.
									- [Restrictions on Using Accessibility Levels](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/restrictions-on-using-accessibility-levels): A summary of the restrictions on using declared accessibility levels.
							- Related: ((643c4a4f-98cc-404b-beff-d58e8266009c))
				- Operators and expressions
				- Statements
					- [Declaration statements](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/declarations)
					  collapsed:: true
						- A declaration statement declares a new local variable, local constant, or [local reference variable](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/declarations#reference-variables). To declare a local variable, specify its type and provide its name. You can declare multiple variables of the same type in one statement,
							- Example
								- ```c#
								  string greeting;
								  int a, b, c;
								  List<double> xs;
								  ```
					- Exception-handling statemetns
					- Iteration statements
					- [Selection statements](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/selection-statements)
					  id:: 650c0968-92a5-4d55-8e46-b80a22344a79
					  `if` ,  `if-else` , and  `switch`
						- ...
						- `switch` statement
						  id:: 661b0696-0081-43dc-9376-810ba6227f6c
							- Example
								- ```c#
								  DisplayMeasurement(-4);  // Output: Measured value is -4; too low.
								  DisplayMeasurement(5);  // Output: Measured value is 5.
								  DisplayMeasurement(30);  // Output: Measured value is 30; too high.
								  DisplayMeasurement(double.NaN);  // Output: Failed measurement.
								  
								  void DisplayMeasurement(double measurement)
								  {
								      switch (measurement)
								      {
								          case < 0.0:
								              Console.WriteLine($"Measured value is {measurement}; too low.");
								              break;
								  
								          case > 15.0:
								              Console.WriteLine($"Measured value is {measurement}; too high.");
								              break;
								  
								          case double.NaN:
								              Console.WriteLine("Failed measurement.");
								              break;
								  
								          default:
								              Console.WriteLine($"Measured value is {measurement}.");
								              break;
								      }
								  }
								  ```
					- Jump statements
					- checked and unchecked statements
					- fixed statement
					- lock statement
					- using ctatement
					- yield statement
				- Special characters
				- Attributes read by the compiler
				- Unsafe code and pointers
				- Preprocessor directives
				- Compiler options
				- XML documentation comments
				- Compiler messages
		- [.NET API](https://learn.microsoft.com/en-us/dotnet/api/)
		  id:: 643a7f7d-e036-4029-9342-498f14235cdb
		  collapsed:: true
			- .NET 7
				- [System Namespace](https://learn.microsoft.com/en-us/dotnet/api/system?view=net-7.0)
				  id:: 643a7fac-0ab2-4e76-9c2e-a3dc715fcc66
					- [Classes](https://learn.microsoft.com/en-us/dotnet/standard/class-library-overview)
					- *Notable*
						- [Array](https://learn.microsoft.com/en-us/dotnet/api/system.array?view=net-7.0)
						  id:: 661bd63f-b51d-4fc9-97dc-caa71756b064
						  collapsed:: true
							- Properties
							- Methods
							  id:: 661bd645-c913-4608-9e3e-ecc7fcc391ac
								- ....
								- [Clear()](https://docs.microsoft.com/en-us/dotnet/api/system.array.clear)
								  collapsed:: true
									- ...
									- sets a range of elements in an array to the default value. It takes three parameters: the name of the array, the starting index of the range to clear, and the number of elements to clear.
									- To clear an entire array, set the index to 0 (if it is zero-indexed) and then pass in the length of the array for the third parameter.
									- ```c#
									  string[] players = { "Emily", "Kyle", "Todd", "Rachel", "Grayson" };
									  // This will return { null, null, null, null, null }
									  Array.Clear(players, 0, players.Length);
									  ```
								- [Copy](https://docs.microsoft.com/en-us/dotnet/api/system.array.copy)
								  collapsed:: true
									- ..
									- copies a range of elements from one array to a second array. It takes three parameters: the name of the array to be copied, the new array, and the length of the array elements.
									- ```c#
									  string[] players = { "Emily", "Kyle", "Todd", "Rachel", "Grayson" };
									  
									  // This creates a new array with default values
									  string[] playersCopy = new string[5];
									  
									  // This will populate the playersCopy array with { "Grayson", "Rachel", "Todd", "Kyle", "Emily" }
									  Array.Copy(players, playersCopy, 5);
									  ```
								- [Find](https://learn.microsoft.com/en-us/dotnet/api/system.array.find?view=net-8.0)
								  id:: 661bd669-105a-4d67-89c5-96be827aad87
								  collapsed:: true
									- ...
									- ..
									- The `Array` method `Array.Find()`([documentation](https://docs.microsoft.com/en-us/dotnet/api/system.array.find))
									  searches a one-dimensional array for a specific value or set of values 
									  that match a certain condition and returns the first occurrence in the 
									  array.
									- ```c#
									  int[] plantHeights = { 3, 6, 4, 1, 6, 8 };
									  // Find the first occurence of a plant height that is greater than 5 inches
									  int firstHeight = Array.Find(plantHeights, height => height > 5);
									  ```
									- `Find()` takes two parameters: the first is the array and the second is a *predicate* that defines what we’re looking for. A predicate is a method that takes one input and outputs a boolean. Unlike `IndexOf()`, `Find()` returns the actual values that match the condition, instead of their index.
									- It’s customary to use a lambda function for 
									  the predicate to determine if the value meets the necessary criteria. If
									  you need a refresher on lambda functions, check out our C# methods 
									  lesson.
									- **Examples**
										- ```c#
										  summerStrut = new string[] { "Juice", "Missing U", "Raspberry Beret", "New York Groove", "Make Me Feel", "Rebel Rebel", "Despacito", "Los Angeles" };
										  string ten = Array.Find(summerStrut, str => str.Length > 10);
										  Console.WriteLine($"The first song that has more than 10 characters in the title is {ten}.");
										  ```
								- [IndexOf](https://learn.microsoft.com/en-us/dotnet/api/system.array.indexof?view=net-8.0)
								  id:: 661bf369-6575-4555-861f-f2b02c78fccc
								- [Reverse()](https://docs.microsoft.com/en-us/dotnet/api/system.array.reverse)
								  collapsed:: true
									- ...
									- will switch the order of elements in an entire array. It can also reverse them in a portion of an array, if the overload is used:
									- ```c#
									  string[] players = { "Emily", "Kyle", "Todd", "Rachel", "Grayson" };
									  - // This will return { "Grayson", "Rachel", "Todd", "Kyle", "Emily" }
									  Array.Reverse(players);
									  ```
							- Explicit Interface Implementations
						- [Boolean](https://learn.microsoft.com/en-us/dotnet/api/system.boolean)
						  collapsed:: true
							- Methods
								- [CompareTo](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.compareto?view=net-7.0)
								- [Equals](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.equals?view=net-7.0)
								- [GetHashCode](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.gethashcode?view=net-7.0)
								- [GetTypeCode](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.gettypecode?view=net-7.0)
								- [Parse](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.parse?view=net-7.0)
								- [ToString](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.tostring?view=net-7.0)
								- [TryFormat](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.tryformat?view=net-7.0)
								- [TryParse](https://learn.microsoft.com/en-us/dotnet/api/system.boolean.tryparse?view=net-7.0)
							- https://learn.microsoft.com/en-us/dotnet/api/system.boolean
						- [Console](https://learn.microsoft.com/en-us/dotnet/api/system.console?view=net-7.0)
						  collapsed:: true
							- Methods
								- [Beep](https://learn.microsoft.com/en-us/dotnet/api/system.console.beep?view=net-7.0)
								- [Clear](https://learn.microsoft.com/en-us/dotnet/api/system.console.clear?view=net-7.0)
								- [GetCursorPosition](https://learn.microsoft.com/en-us/dotnet/api/system.console.getcursorposition?view=net-7.0)
								- [MoveBufferArea](https://learn.microsoft.com/en-us/dotnet/api/system.console.movebufferarea?view=net-7.0)
								- [OpenStandardError](https://learn.microsoft.com/en-us/dotnet/api/system.console.openstandarderror?view=net-7.0)
								- [OpenStandardInput](https://learn.microsoft.com/en-us/dotnet/api/system.console.openstandardinput?view=net-7.0)
								- [OpenStandardOutput](https://learn.microsoft.com/en-us/dotnet/api/system.console.openstandardoutput?view=net-7.0)
								- [Read](https://learn.microsoft.com/en-us/dotnet/api/system.console.read?view=net-7.0)
								- [ReadKey](https://learn.microsoft.com/en-us/dotnet/api/system.console.readkey?view=net-7.0)
								- [ReadLine](https://learn.microsoft.com/en-us/dotnet/api/system.console.readline?view=net-7.0)
								- [ResetColor](https://learn.microsoft.com/en-us/dotnet/api/system.console.resetcolor?view=net-7.0)
								- [SetBufferSize](https://learn.microsoft.com/en-us/dotnet/api/system.console.setbuffersize?view=net-7.0)
								- [SetCursorPosition](https://learn.microsoft.com/en-us/dotnet/api/system.console.setcursorposition?view=net-7.0)
								- [SetError](https://learn.microsoft.com/en-us/dotnet/api/system.console.seterror?view=net-7.0)
								- [SetIn](https://learn.microsoft.com/en-us/dotnet/api/system.console.setin?view=net-7.0)
								- [SetOut](https://learn.microsoft.com/en-us/dotnet/api/system.console.setout?view=net-7.0)
								- [SetWindowPosition](https://learn.microsoft.com/en-us/dotnet/api/system.console.setwindowposition?view=net-7.0)
								- [SetWindowSize](https://learn.microsoft.com/en-us/dotnet/api/system.console.setwindowsize?view=net-7.0)
								- [Write](https://learn.microsoft.com/en-us/dotnet/api/system.console.write?view=net-7.0)
								- [WriteLine](https://learn.microsoft.com/en-us/dotnet/api/system.console.writeline?view=net-7.0)
								  id:: 643aaea3-e008-4339-98a5-42d23d0eec80
								  Equivalent to ((63904f40-40ea-45ad-b746-cc99692a819d)) . ((64024e42-a0ab-4278-9c5b-4cc98409efd8))
									- Note: To use this method you'll need to import the `System` namespace at the top of the file
									- Example
										- With `using System`:
										  ```c#
										  using System;
										  
										  class Hello
										  {
										      static void Main()
										      {
										          // This line prints "Hello, World" 
										          Console.WriteLine("Hello, World");
										      }
										  }
										  ```
										- Without `using System`:
										  ```c#
										  class Hello
										  {
										    static void Main()
										    {
										        // This line prints "Hello, World" 
										        System.Console.WriteLine("Hello, World");
										    }
										  }
										  ```
						- [Enum](https://learn.microsoft.com/en-us/dotnet/api/system.enum?view=net-7.0)
						  collapsed:: true
							- Methods
								- [CompareTo](https://learn.microsoft.com/en-us/dotnet/api/system.enum.compareto?view=net-7.0)
								- [Equals](https://learn.microsoft.com/en-us/dotnet/api/system.enum.equals?view=net-7.0)
								- [Format](https://learn.microsoft.com/en-us/dotnet/api/system.enum.format?view=net-7.0)
								- [GetHashCode](https://learn.microsoft.com/en-us/dotnet/api/system.enum.gethashcode?view=net-7.0)
								- [GetName](https://learn.microsoft.com/en-us/dotnet/api/system.enum.getname?view=net-7.0)
								- [GetNames](https://learn.microsoft.com/en-us/dotnet/api/system.enum.getnames?view=net-7.0)
								- [GetTypeCode](https://learn.microsoft.com/en-us/dotnet/api/system.enum.gettypecode?view=net-7.0)
								- [GetUnderlyingType](https://learn.microsoft.com/en-us/dotnet/api/system.enum.getunderlyingtype?view=net-7.0)
								- [GetValues](https://learn.microsoft.com/en-us/dotnet/api/system.enum.getvalues?view=net-7.0)
								- [GetValuesAsUnderlyingType](https://learn.microsoft.com/en-us/dotnet/api/system.enum.getvaluesasunderlyingtype?view=net-7.0)
								- [HasFlag](https://learn.microsoft.com/en-us/dotnet/api/system.enum.hasflag?view=net-7.0)
								- [IsDefined](https://learn.microsoft.com/en-us/dotnet/api/system.enum.isdefined?view=net-7.0)
								- [Parse](https://learn.microsoft.com/en-us/dotnet/api/system.enum.parse?view=net-7.0)
								- [ToObject](https://learn.microsoft.com/en-us/dotnet/api/system.enum.toobject?view=net-7.0)
								- [ToString](https://learn.microsoft.com/en-us/dotnet/api/system.enum.tostring?view=net-7.0)
								- [TryParse](https://learn.microsoft.com/en-us/dotnet/api/system.enum.tryparse?view=net-7.0)
						- [Math](https://learn.microsoft.com/en-us/dotnet/api/system.math?view=net-7.0)
						  collapsed:: true
							- Methods
								- [Abs](https://learn.microsoft.com/en-us/dotnet/api/system.math.abs?view=net-7.0)
								- [Acos](https://learn.microsoft.com/en-us/dotnet/api/system.math.acos?view=net-7.0)
								- [Acosh](https://learn.microsoft.com/en-us/dotnet/api/system.math.acosh?view=net-7.0)
								- [Asin](https://learn.microsoft.com/en-us/dotnet/api/system.math.asin?view=net-7.0)
								- [Asinh](https://learn.microsoft.com/en-us/dotnet/api/system.math.asinh?view=net-7.0)
								- [Atan](https://learn.microsoft.com/en-us/dotnet/api/system.math.atan?view=net-7.0)
								- [Atan2](https://learn.microsoft.com/en-us/dotnet/api/system.math.atan2?view=net-7.0)
								- [Atanh](https://learn.microsoft.com/en-us/dotnet/api/system.math.atanh?view=net-7.0)
								- [BigMul](https://learn.microsoft.com/en-us/dotnet/api/system.math.bigmul?view=net-7.0)
								- [BitDecrement](https://learn.microsoft.com/en-us/dotnet/api/system.math.bitdecrement?view=net-7.0)
								- [BitIncrement](https://learn.microsoft.com/en-us/dotnet/api/system.math.bitincrement?view=net-7.0)
								- [Cbrt](https://learn.microsoft.com/en-us/dotnet/api/system.math.cbrt?view=net-7.0)
								- [Ceiling](https://learn.microsoft.com/en-us/dotnet/api/system.math.ceiling?view=net-7.0)
								- [Clamp](https://learn.microsoft.com/en-us/dotnet/api/system.math.clamp?view=net-7.0)
								- [CopySign](https://learn.microsoft.com/en-us/dotnet/api/system.math.copysign?view=net-7.0)
								- [Cos](https://learn.microsoft.com/en-us/dotnet/api/system.math.cos?view=net-7.0)
								- [Cosh](https://learn.microsoft.com/en-us/dotnet/api/system.math.cosh?view=net-7.0)
								- [DivRem](https://learn.microsoft.com/en-us/dotnet/api/system.math.divrem?view=net-7.0)
								- [Exp](https://learn.microsoft.com/en-us/dotnet/api/system.math.exp?view=net-7.0)
								- [Floor](https://learn.microsoft.com/en-us/dotnet/api/system.math.floor?view=net-7.0)
								- [FusedMultiplyAdd](https://learn.microsoft.com/en-us/dotnet/api/system.math.fusedmultiplyadd?view=net-7.0)
								- [IEEERemainder](https://learn.microsoft.com/en-us/dotnet/api/system.math.ieeeremainder?view=net-7.0)
								- [ILogB](https://learn.microsoft.com/en-us/dotnet/api/system.math.ilogb?view=net-7.0)
								- [Log](https://learn.microsoft.com/en-us/dotnet/api/system.math.log?view=net-7.0)
								- [Log10](https://learn.microsoft.com/en-us/dotnet/api/system.math.log10?view=net-7.0)
								- [Log2](https://learn.microsoft.com/en-us/dotnet/api/system.math.log2?view=net-7.0)
								- [Max](https://learn.microsoft.com/en-us/dotnet/api/system.math.max?view=net-7.0)
								- [MaxMagnitude](https://learn.microsoft.com/en-us/dotnet/api/system.math.maxmagnitude?view=net-7.0)
								- [Min](https://learn.microsoft.com/en-us/dotnet/api/system.math.min?view=net-7.0)
								- [MinMagnitude](https://learn.microsoft.com/en-us/dotnet/api/system.math.minmagnitude?view=net-7.0)
								- [Pow](https://learn.microsoft.com/en-us/dotnet/api/system.math.pow?view=net-7.0)
								- [ReciprocalEstimate](https://learn.microsoft.com/en-us/dotnet/api/system.math.reciprocalestimate?view=net-7.0)
								- [ReciprocalSqrtEstimate](https://learn.microsoft.com/en-us/dotnet/api/system.math.reciprocalsqrtestimate?view=net-7.0)
								- [Round](https://learn.microsoft.com/en-us/dotnet/api/system.math.round?view=net-7.0)
								  id:: 6463496c-441e-4d76-9967-68e280a31604
								- [ScaleB](https://learn.microsoft.com/en-us/dotnet/api/system.math.scaleb?view=net-7.0)
								- [Sign](https://learn.microsoft.com/en-us/dotnet/api/system.math.sign?view=net-7.0)
								- [Sin](https://learn.microsoft.com/en-us/dotnet/api/system.math.sin?view=net-7.0)
								- [SinCos](https://learn.microsoft.com/en-us/dotnet/api/system.math.sincos?view=net-7.0)
								- [Sinh](https://learn.microsoft.com/en-us/dotnet/api/system.math.sinh?view=net-7.0)
								- [Sqrt](https://learn.microsoft.com/en-us/dotnet/api/system.math.sqrt?view=net-7.0)
								- [Tan](https://learn.microsoft.com/en-us/dotnet/api/system.math.tan?view=net-7.0)
								- [Tanh](https://learn.microsoft.com/en-us/dotnet/api/system.math.tanh?view=net-7.0)
								- [Truncate](https://learn.microsoft.com/en-us/dotnet/api/system.math.truncate?view=net-7.0)
						- [Object](https://learn.microsoft.com/en-us/dotnet/api/system.object?view=net-7.0)
						  collapsed:: true
							- Methods
								- [Equals](https://learn.microsoft.com/en-us/dotnet/api/system.object.equals?view=net-7.0)
								- [Finalize](https://learn.microsoft.com/en-us/dotnet/api/system.object.finalize?view=net-7.0)
								- [GetHashCode](https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-7.0)
								- [GetType](https://learn.microsoft.com/en-us/dotnet/api/system.object.gettype?view=net-7.0)
								- [MemberwiseClone](https://learn.microsoft.com/en-us/dotnet/api/system.object.memberwiseclone?view=net-7.0)
								- [ReferenceEquals](https://learn.microsoft.com/en-us/dotnet/api/system.object.referenceequals?view=net-7.0)
								- [ToString](https://learn.microsoft.com/en-us/dotnet/api/system.object.tostring?view=net-7.0)
						- [String](https://learn.microsoft.com/en-us/dotnet/api/system.string?view=net-7.0)
						  id:: 6463496c-ee2f-4e6d-9d0f-de44fabf8ce3
						  collapsed:: true
							- Methods
							  id:: 6463496c-4dc7-41b4-a00c-b8c3ba16066b
								- [Clone](https://learn.microsoft.com/en-us/dotnet/api/system.string.clone?view=net-7.0)
								- [Compare](https://learn.microsoft.com/en-us/dotnet/api/system.string.compare?view=net-7.0)
								- [CompareOrdinal](https://learn.microsoft.com/en-us/dotnet/api/system.string.compareordinal?view=net-7.0)
								- [CompareTo](https://learn.microsoft.com/en-us/dotnet/api/system.string.compareto?view=net-7.0)
								- [Concat](https://learn.microsoft.com/en-us/dotnet/api/system.string.concat?view=net-7.0)
								- [Contains](https://learn.microsoft.com/en-us/dotnet/api/system.string.contains?view=net-7.0)
								  id:: 37afa87a-5bdc-403e-a94b-e30627308290
								  collapsed:: true
								  Check if a substring is inside it | Similar to ((502a2eb1-0412-4a8f-9651-155e7389102f)), ((b3f829c5-ae83-4971-9290-a6b93a6f4e51))
									- Example
										- ```c#
										  string songLyrics = "You say goodbye, and I say hello";
										  Console.WriteLine(songLyrics.Contains("goodbye"));
										  // True
										  Console.WriteLine(songLyrics.Contains("greetings"));
										  // False
										  ```
								- [Copy](https://learn.microsoft.com/en-us/dotnet/api/system.string.copy?view=net-7.0)
								- [CopyTo](https://learn.microsoft.com/en-us/dotnet/api/system.string.copyto?view=net-7.0)
								- [Create](https://learn.microsoft.com/en-us/dotnet/api/system.string.create?view=net-7.0)
								- [EndsWith](https://learn.microsoft.com/en-us/dotnet/api/system.string.endswith?view=net-7.0)
								  id:: b3f829c5-ae83-4971-9290-a6b93a6f4e51
								  collapsed:: true
								  Similar to ((502a2eb1-0412-4a8f-9651-155e7389102f)), ((37afa87a-5bdc-403e-a94b-e30627308290))
									- Example
										- ```c#
										  string songLyrics = "You say goodbye, and I say hello";
										  Console.WriteLine(songLyrics.EndsWith("hello"));
										  // True
										  ```
								- [EnumerateRunes](https://learn.microsoft.com/en-us/dotnet/api/system.string.enumeraterunes?view=net-7.0)
								- [Equals](https://learn.microsoft.com/en-us/dotnet/api/system.string.equals?view=net-7.0)
								- [Format](https://learn.microsoft.com/en-us/dotnet/api/system.string.format?view=net-7.0)
								- [GetEnumerator](https://learn.microsoft.com/en-us/dotnet/api/system.string.getenumerator?view=net-7.0)
								- [GetHashCode](https://learn.microsoft.com/en-us/dotnet/api/system.string.gethashcode?view=net-7.0)
								- [GetPinnableReference](https://learn.microsoft.com/en-us/dotnet/api/system.string.getpinnablereference?view=net-7.0)
								- [GetTypeCode](https://learn.microsoft.com/en-us/dotnet/api/system.string.gettypecode?view=net-7.0)
								- [IndexOf](https://learn.microsoft.com/en-us/dotnet/api/system.string.indexof?view=net-7.0)
								- [IndexOfAny](https://learn.microsoft.com/en-us/dotnet/api/system.string.indexofany?view=net-7.0)
								- [Insert](https://learn.microsoft.com/en-us/dotnet/api/system.string.insert?view=net-7.0)
								- [Intern](https://learn.microsoft.com/en-us/dotnet/api/system.string.intern?view=net-7.0)
								- [IsInterned](https://learn.microsoft.com/en-us/dotnet/api/system.string.isinterned?view=net-7.0)
								- [IsNormalized](https://learn.microsoft.com/en-us/dotnet/api/system.string.isnormalized?view=net-7.0)
								- [IsNullOrEmpty](https://learn.microsoft.com/en-us/dotnet/api/system.string.isnullorempty?view=net-7.0)
								- [IsNullOrWhiteSpace](https://learn.microsoft.com/en-us/dotnet/api/system.string.isnullorwhitespace?view=net-7.0)
								- [Join](https://learn.microsoft.com/en-us/dotnet/api/system.string.join?view=net-7.0)
								- [LastIndexOf](https://learn.microsoft.com/en-us/dotnet/api/system.string.lastindexof?view=net-7.0)
								- [LastIndexOfAny](https://learn.microsoft.com/en-us/dotnet/api/system.string.lastindexofany?view=net-7.0)
								- [Normalize](https://learn.microsoft.com/en-us/dotnet/api/system.string.normalize?view=net-7.0)
								- [PadLeft](https://learn.microsoft.com/en-us/dotnet/api/system.string.padleft?view=net-7.0)
								- [PadRight](https://learn.microsoft.com/en-us/dotnet/api/system.string.padright?view=net-7.0)
								- [Remove](https://learn.microsoft.com/en-us/dotnet/api/system.string.remove?view=net-7.0)
								- [Replace](https://learn.microsoft.com/en-us/dotnet/api/system.string.replace?view=net-7.0)
								  collapsed:: true
									- Example
									  collapsed:: true
										- ```c#
										  string sayHello = "Hello World!";
										  Console.WriteLine(sayHello);
										  // Hello World!
										  sayHello = sayHello.Replace("Hello", "Greetings");
										  Console.WriteLine(sayHello);
										  // Greetings World!
										  ```
								- [ReplaceLineEndings](https://learn.microsoft.com/en-us/dotnet/api/system.string.replacelineendings?view=net-7.0)
								- [Split](https://learn.microsoft.com/en-us/dotnet/api/system.string.split?view=net-7.0)
								- [StartsWith](https://learn.microsoft.com/en-us/dotnet/api/system.string.startswith?view=net-7.0)
								  id:: 502a2eb1-0412-4a8f-9651-155e7389102f
								  collapsed:: true
								  Similar to ((b3f829c5-ae83-4971-9290-a6b93a6f4e51)), ((37afa87a-5bdc-403e-a94b-e30627308290))
									- Example
										- ```c#
										  string songLyrics = "You say goodbye, and I say hello";
										  Console.WriteLine(songLyrics.StartsWith("You"));
										  // True
										  ```
								- [Substring](https://learn.microsoft.com/en-us/dotnet/api/system.string.substring?view=net-7.0)
								  id:: 6463496c-e95c-46b3-9a6e-2d76203ed4fd
									- ...
									- ...
									- `.Substring()` grabs part of a string using the specified character position, continues until the end of the string, and returns a new string. ((661ae9b4-ca33-493c-b058-e870b5ec6c14)) is usually used first to get the specific character position.
									- ```c#
									  string plantName = "Cactaceae, Cactus"; 
									  int charPosition = plantName.IndexOf("Cactus"); // returns 11
									  string commonName = plantName.Substring(charPosition); // returns Cactus
									  ```
									- `.Substring()` is useful if we only want to use part of a string but keep the original data intact. So in this instance, we want to keep the string `plantName`, but just grab the `"Cactus"` portion of the string. We use `.IndexOf()` to find where `"Cactus"` starts, then use `.Substring()` with the position information to save `"Cactus"` to the new variable `commonName`.
									- We can also pass `.Substring()` a second argument, which will determine the number of characters in the resulting substring. For example, the following code shows how we can use `.Substring()` with two arguments to specify the length of our substring:
										- ```C#
										  string name = "Codecademy"; 
										  int start = 2;
										  int length = 6;
										  string substringName = name.Substring(start, length); // returns 'decade'
										  ```
								- [ToCharArray](https://learn.microsoft.com/en-us/dotnet/api/system.string.tochararray?view=net-7.0)
								- [ToLower](https://learn.microsoft.com/en-us/dotnet/api/system.string.tolower?view=net-7.0)
								  collapsed:: true
									- Example
									  collapsed:: true
										- ```c#
										  string sayHello = "Hello World!";
										  Console.WriteLine(sayHello.ToLower());
										  // hello world!
										  ```
								- [ToLowerInvariant](https://learn.microsoft.com/en-us/dotnet/api/system.string.tolowerinvariant?view=net-7.0)
								- [ToString](https://learn.microsoft.com/en-us/dotnet/api/system.string.tostring?view=net-7.0)
								- [ToUpper](https://learn.microsoft.com/en-us/dotnet/api/system.string.toupper?view=net-7.0)
								  collapsed:: true
									- Example
									  collapsed:: true
										- ```c#
										  string sayHello = "Hello World!";
										  Console.WriteLine(sayHello.ToUpper());
										  // HELLO WORLD!
										  ```
								- [ToUpperInvariant](https://learn.microsoft.com/en-us/dotnet/api/system.string.toupperinvariant?view=net-7.0)
								- [Trim](https://learn.microsoft.com/en-us/dotnet/api/system.string.trim?view=net-7.0)
								  collapsed:: true
									- Can be used to easily remove whitespace
									  collapsed:: true
										- ```c#
										  string greeting = "      Hello World!       ";
										  Console.WriteLine($"[{greeting}]");
										  // [      Hello World!       ]
										  
										  string trimmedGreeting = greeting.TrimStart();
										  Console.WriteLine($"[{trimmedGreeting}]");
										  // [Hello World!       ]
										  
										  trimmedGreeting = greeting.TrimEnd();
										  Console.WriteLine($"[{trimmedGreeting}]");
										  // [      Hello World!]
										  
										  trimmedGreeting = greeting.Trim();
										  Console.WriteLine($"[{trimmedGreeting}]");
										  // [Hello World!]
										  ```
								- [TrimEnd](https://learn.microsoft.com/en-us/dotnet/api/system.string.trimend?view=net-7.0)
								- [TrimStart](https://learn.microsoft.com/en-us/dotnet/api/system.string.trimstart?view=net-7.0)
								- [TryCopyTo](https://learn.microsoft.com/en-us/dotnet/api/system.string.trycopyto?view=net-7.0)
						- [Tuple](https://learn.microsoft.com/en-us/dotnet/api/system.tuple?view=net-7.0)
						  collapsed:: true
							- Methods
								- [Create](https://learn.microsoft.com/en-us/dotnet/api/system.tuple.create?view=net-7.0)
				- [Convert](https://learn.microsoft.com/en-us/dotnet/api/system.convert?view=net-7.0)
				  collapsed:: true
					- ToBase64CharArray
					- ToBase64String
					- ToBoolean
					- ToByte
					- ToChar
					- ToDateTime
					- ToDecimal
					- ToDouble
					- ToHexString
					- Tolnt16
					- TolInt32
					- Toint64
					- ToSByte
					- ToSingle
					- ToString
					- ToUInt16
					- ToUInt32
					- ToUInt64
					- TryFromBase64Chars
	- Overview
	  collapsed:: true
		- Main language for the .NET framework, alongside F# and Visual Basic
		- C# runs aided by a JIT compiler
		- .NET Core = desktop apps
		- Xamarin = mobile apps
		- Blazor = web apps
		- Unity = videogames
	- Editors
		- ((63209272-1088-4824-a762-4ac7ded04b0a))
		- ((643a7412-56f4-4612-a067-12ea6d2f51d6))
- Other .NET application languages
	- Visual Basic
	- F#
- Frameworks
	- [ASP.NET](https://www.asp.net/)
	  id:: 6529189e-d194-44fe-8d48-13348d318139
	- [.NET](https://learn.microsoft.com/en-us/dotnet/)
	  id:: 659d38ce-a277-4a58-8530-b3527f40432a
	  collapsed:: true
	  AKA dotnet
		- Pros/Cons
		  id:: 661b9aa8-8199-440a-958a-1de5eb489a25
		  collapsed:: true
			- Pros
				-
			- Cons
				- Still not open platform
				  id:: 6463496d-5daf-4892-b9f0-ad45c649e777
				  collapsed:: true
					- Note: this is C#, F# and C++
					- https://isdotnetopen.com/
						- problems:
							- [ramming in a proprietary extension to continue to lockdown .NET.](https://github.com/omnisharp/omnisharp-vscode/issues/5276)
								- June 2023 - they made the [VSCode C# extension open-source](https://github.com/dotnet/vscode-csharp/) now
									- [C# - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp)
									- https://github.com/dotnet/vscode-csharp/issues/5708 announcement. Still a few FOSS issues noted
								- C# Dev Kit
									- [Announcing C# Dev Kit for Visual Studio Code - Visual Studio Blog](https://devblogs.microsoft.com/visualstudio/announcing-csharp-dev-kit-for-visual-studio-code/)
							- [an open programming language is missing a debugger](https://github.com/dotnet/core/issues/505)
							- [leadership decision to remove hotreload angers community and devdiv employees](https://www.theverge.com/2021/10/22/22740701/microsoft-dotnet-hot-reload-removal-decision-open-source)
							- [.NET foundation serves the interests of Microsoft](https://www.theregister.com/2021/10/05/microsoft_net_foundation_under_fire/)
							-
					- [Despite best efforts .NET is still not an open platform | Hacker News](https://news.ycombinator.com/item?id=31762778)
					-
				- Frontend frameworks (AKA UI libraries) built on it tend not to be supported long. Better off using React and TypeScript
				  collapsed:: true
					- ((661b9ae4-bcd1-4f47-8f1d-bc70be656215))
					- Comments
						- having lived and upgraded many projects through asp web forms, wpf, silverlight, and razor, I've decided "never trust .NET UI libraries to survive". So I'm avoiding Blazor entirely and just sticking with the react ecosystem. I trust that 100x more than I trust Blazor, partly because the ecosystem and user base is 100x larger. I won't be the slightest bit surprised to see Blazor tossed in the trash in three years, but I'll eat my hat if react is gone by then.
						- You've got good reasons for not trusting any .NET GUI libraries from Microsoft, I don't either since they all ultimately end up abandoned however that doesn't definitely doesn't apply to their premier Server frameworks which enjoys first class long lasting support.
						  
						  Razor didn't go anywhere, it's still the predominant language .NET Server HTML Views is written in since its release in 2010, whether it's in MVC, Razor Pages or even Blazor which enjoys the same familiar statically-typed syntax with great tooling and high performance compiled views.
						  
						  There's no chance that's going to happen with Blazor, which has become the future of .NET Web App development, it's a unique technology that's highly versatile whose multiple rendering options supports a wide number of different use-cases that's enjoyed by most of .NET developers.
						-
				- There's no 1st-party .NET GUI framework that works cross-platform. 3rd-party there's avalonia, GtkSharp, and Uno
			- Unclear
			- Comparisons
		- [Install .NET on Ubuntu 23.10](https://learn.microsoft.com/en-us/dotnet/core/install/linux-ubuntu-2310)
		  collapsed:: true
			- Install the SDK
				- ```bash
				  sudo apt-get update && \
				    sudo apt-get install -y dotnet-sdk-8.0
				  ```
			- Install the runtime, either:
				- ASP.NET Core Runtime - allows you to run apps that were made with ((659d38ce-a277-4a58-8530-b3527f40432a)) that didn't provide the runtime
					- `sudo apt-get install -y aspnetcore-runtime-8.0`
				- .NET Runtime, which doesn't include ASP.NET Core support
					- `sudo apt-get install -y dotnet-runtime-8.0`
	- Xamarin
	- Blazor
	  id:: 661b9ae4-bcd1-4f47-8f1d-bc70be656215
- _Example codebases to read/enhance_
  collapsed:: true
	- [SS3D](https://github.com/RE-SS3D/SS3D)
	- [Unitystation](https://github.com/unitystation/unitystation)
	- [Space Station 14](https://github.com/space-wizards/space-station-14)
- [Learning Resources]
	- ((64400aaf-af93-4739-a73b-97b213f053d6))
		- {{embed ((64400aaf-af93-4739-a73b-97b213f053d6))}}
	- [SS14 recommended resources](https://docs.spacestation14.io/en/getting-started/how-do-i-code)
	  id:: 6463496c-17d2-4ada-929b-8408842f5cd0
		- ((643aaea3-1255-47c9-abe2-948d39fa1470)) : ((643a7b39-a636-4105-a23f-49fc662cdd4f))
		  id:: 643a7179-82c1-4452-a66f-53c389bfac13
		- ((643aaea3-1dfd-4793-a1f6-4ba2cf253944))
		- **[C# A Player's Guide 5th Edition](https://www.amazon.com/dp/0985580151)**
		  A very engaging book for beginner's to C#. Very modern, making use of [[C#]] 10 and .NET 6 with tons of projects and challenges to actually make use of your coding skills. Highly recommended. Buy whatever the newest edition is (regardless of what this says), as we always stay up to date.
		- **[CSharp Fundamentals for Absolute Beginners | Channel 9](https://channel9.msdn.com/Series/CSharp-Fundamentals-for-Absolute-Beginners)**
		  A video series covering the absolute basics of programming, C# style. Also walks you through installing an IDE (a program that makes it much easier for you to write code).
		- **[Learn C# in Y minutes](https://learnxinyminutes.com/docs/csharp/)**
		  Reference sheet presented through a massive C# file. Again, this is more useful for those who already understand how to program and just need a quick reference for what the syntax is.
	- ((654f8d93-5a47-43db-a875-f8ac464fc412))